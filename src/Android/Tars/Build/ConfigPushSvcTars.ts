// **********************************************************************
// Parsed By TarsParser(1.2.0), Generated By tars2node(20200315)
// TarsParser Maintained By <TARS> and tars2node Maintained By <superzheng>
// Generated from "ConfigPushSvc.tars" by Structure Mode
// **********************************************************************

/* tslint:disable */
/* eslint-disable */

/// <reference types="node" />
import assert = require("assert");
import * as TarsStream from "@tars/stream";

const _hasOwnProperty = Object.prototype.hasOwnProperty;

export namespace ConfigPushSvcTars {
    export class PushReq {
        Type: number = 0;
        Buff: TarsStream.BinBuffer = new TarsStream.BinBuffer;
        Seq: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.PushReq";
        protected static _classname = "ConfigPushSvcTars.PushReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new PushReq;
            tmp.Type = is.readInt32(1, true, 0);
            tmp.Buff = is.readBytes(2, true, TarsStream.BinBuffer);
            tmp.Seq = is.readInt64(3, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt32(1, this.Type);
            os.writeBytes(2, this.Buff);
            os.writeInt64(3, this.Seq);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): PushReq.Object { 
            return {
                Type: this.Type,
                Buff: this.Buff.toObject(),
                Seq: this.Seq
            };
        }

        readFromObject(json: PushReq.Object) { 
            _hasOwnProperty.call(json, "Type") && (this.Type = json.Type);
            _hasOwnProperty.call(json, "Buff") && (this.Buff.readFromObject(json.Buff));
            _hasOwnProperty.call(json, "Seq") && (this.Seq = json.Seq);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new PushReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.PushReq._readFrom(is);
        }
    }

    export namespace PushReq {
        export interface Object {
            Type: number;
            Buff: Buffer;
            Seq: number;
        }
    }

    export class FileStorageServerListInfo {
        Ip: string = "";
        Port: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.FileStorageServerListInfo";
        protected static _classname = "ConfigPushSvcTars.FileStorageServerListInfo";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new FileStorageServerListInfo;
            tmp.Ip = is.readString(1, false, "");
            tmp.Port = is.readInt32(2, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(1, this.Ip);
            os.writeInt32(2, this.Port);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): FileStorageServerListInfo.Object { 
            return {
                Ip: this.Ip,
                Port: this.Port
            };
        }

        readFromObject(json: FileStorageServerListInfo.Object) { 
            _hasOwnProperty.call(json, "Ip") && (this.Ip = json.Ip!);
            _hasOwnProperty.call(json, "Port") && (this.Port = json.Port);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new FileStorageServerListInfo();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.FileStorageServerListInfo._readFrom(is);
        }
    }

    export namespace FileStorageServerListInfo {
        export interface Object {
            Ip?: string;
            Port: number;
        }
    }

    export class BigDataIpInfo {
        Type: number = 0;
        Ip: string = "";
        Port: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.BigDataIpInfo";
        protected static _classname = "ConfigPushSvcTars.BigDataIpInfo";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new BigDataIpInfo;
            tmp.Type = is.readInt64(0, false, 0);
            tmp.Ip = is.readString(1, true, "");
            tmp.Port = is.readInt64(2, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt64(0, this.Type);
            os.writeString(1, this.Ip);
            os.writeInt64(2, this.Port);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): BigDataIpInfo.Object { 
            return {
                Type: this.Type,
                Ip: this.Ip,
                Port: this.Port
            };
        }

        readFromObject(json: BigDataIpInfo.Object) { 
            _hasOwnProperty.call(json, "Type") && (this.Type = json.Type!);
            _hasOwnProperty.call(json, "Ip") && (this.Ip = json.Ip);
            _hasOwnProperty.call(json, "Port") && (this.Port = json.Port);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new BigDataIpInfo();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.BigDataIpInfo._readFrom(is);
        }
    }

    export namespace BigDataIpInfo {
        export interface Object {
            Type?: number;
            Ip: string;
            Port: number;
        }
    }

    export class NetSegConf {
        Uint32NetType: number = 0;
        Uint32Segsize: number = 0;
        Uint32Segnum: number = 0;
        Uint32Curconnnum: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.NetSegConf";
        protected static _classname = "ConfigPushSvcTars.NetSegConf";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new NetSegConf;
            tmp.Uint32NetType = is.readInt64(0, false, 0);
            tmp.Uint32Segsize = is.readInt64(1, false, 0);
            tmp.Uint32Segnum = is.readInt8(2, false, 0);
            tmp.Uint32Curconnnum = is.readInt64(3, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt64(0, this.Uint32NetType);
            os.writeInt64(1, this.Uint32Segsize);
            os.writeInt8(2, this.Uint32Segnum);
            os.writeInt64(3, this.Uint32Curconnnum);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): NetSegConf.Object { 
            return {
                Uint32NetType: this.Uint32NetType,
                Uint32Segsize: this.Uint32Segsize,
                Uint32Segnum: this.Uint32Segnum,
                Uint32Curconnnum: this.Uint32Curconnnum
            };
        }

        readFromObject(json: NetSegConf.Object) { 
            _hasOwnProperty.call(json, "Uint32NetType") && (this.Uint32NetType = json.Uint32NetType!);
            _hasOwnProperty.call(json, "Uint32Segsize") && (this.Uint32Segsize = json.Uint32Segsize!);
            _hasOwnProperty.call(json, "Uint32Segnum") && (this.Uint32Segnum = json.Uint32Segnum!);
            _hasOwnProperty.call(json, "Uint32Curconnnum") && (this.Uint32Curconnnum = json.Uint32Curconnnum!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new NetSegConf();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.NetSegConf._readFrom(is);
        }
    }

    export namespace NetSegConf {
        export interface Object {
            Uint32NetType?: number;
            Uint32Segsize?: number;
            Uint32Segnum?: number;
            Uint32Curconnnum?: number;
        }
    }

    export class BigDataIpList {
        ServiceType: number = 0;
        Iplist: TarsStream.List<ConfigPushSvcTars.BigDataIpInfo> = new TarsStream.List(ConfigPushSvcTars.BigDataIpInfo);
        NetSegConfs: TarsStream.List<ConfigPushSvcTars.NetSegConf> = new TarsStream.List(ConfigPushSvcTars.NetSegConf);
        fragmentSize: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.BigDataIpList";
        protected static _classname = "ConfigPushSvcTars.BigDataIpList";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new BigDataIpList;
            tmp.ServiceType = is.readInt64(0, false, 0);
            tmp.Iplist = is.readList(1, false, TarsStream.List(ConfigPushSvcTars.BigDataIpInfo));
            tmp.NetSegConfs = is.readList(2, false, TarsStream.List(ConfigPushSvcTars.NetSegConf));
            tmp.fragmentSize = is.readInt64(3, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt64(0, this.ServiceType);
            os.writeList(1, this.Iplist);
            os.writeList(2, this.NetSegConfs);
            os.writeInt64(3, this.fragmentSize);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): BigDataIpList.Object { 
            return {
                ServiceType: this.ServiceType,
                Iplist: this.Iplist.toObject(),
                NetSegConfs: this.NetSegConfs.toObject(),
                fragmentSize: this.fragmentSize
            };
        }

        readFromObject(json: BigDataIpList.Object) { 
            _hasOwnProperty.call(json, "ServiceType") && (this.ServiceType = json.ServiceType!);
            _hasOwnProperty.call(json, "Iplist") && (this.Iplist.readFromObject(json.Iplist!));
            _hasOwnProperty.call(json, "NetSegConfs") && (this.NetSegConfs.readFromObject(json.NetSegConfs!));
            _hasOwnProperty.call(json, "fragmentSize") && (this.fragmentSize = json.fragmentSize!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new BigDataIpList();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.BigDataIpList._readFrom(is);
        }
    }

    export namespace BigDataIpList {
        export interface Object {
            ServiceType?: number;
            Iplist?: Array<ConfigPushSvcTars.BigDataIpInfo.Object>;
            NetSegConfs?: Array<ConfigPushSvcTars.NetSegConf.Object>;
            fragmentSize?: number;
        }
    }

    export class BigDataChannel {
        BigdataIplists: TarsStream.List<ConfigPushSvcTars.BigDataIpList> = new TarsStream.List(ConfigPushSvcTars.BigDataIpList);
        BigdataSigSession: TarsStream.BinBuffer = new TarsStream.BinBuffer;
        BigdataKeySession: TarsStream.BinBuffer = new TarsStream.BinBuffer;
        SigUin: number = 0;
        ConnectFlag: number = 0;
        BigdataPbBuf: TarsStream.BinBuffer = new TarsStream.BinBuffer;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.BigDataChannel";
        protected static _classname = "ConfigPushSvcTars.BigDataChannel";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new BigDataChannel;
            tmp.BigdataIplists = is.readList(0, false, TarsStream.List(ConfigPushSvcTars.BigDataIpList));
            tmp.BigdataSigSession = is.readBytes(1, false, TarsStream.BinBuffer);
            tmp.BigdataKeySession = is.readBytes(2, false, TarsStream.BinBuffer);
            tmp.SigUin = is.readInt64(3, false, 0);
            tmp.ConnectFlag = is.readInt32(4, false, 0);
            tmp.BigdataPbBuf = is.readBytes(5, false, TarsStream.BinBuffer);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeList(0, this.BigdataIplists);
            os.writeBytes(1, this.BigdataSigSession);
            os.writeBytes(2, this.BigdataKeySession);
            os.writeInt64(3, this.SigUin);
            os.writeInt32(4, this.ConnectFlag);
            os.writeBytes(5, this.BigdataPbBuf);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): BigDataChannel.Object { 
            return {
                BigdataIplists: this.BigdataIplists.toObject(),
                BigdataSigSession: this.BigdataSigSession.toObject(),
                BigdataKeySession: this.BigdataKeySession.toObject(),
                SigUin: this.SigUin,
                ConnectFlag: this.ConnectFlag,
                BigdataPbBuf: this.BigdataPbBuf.toObject()
            };
        }

        readFromObject(json: BigDataChannel.Object) { 
            _hasOwnProperty.call(json, "BigdataIplists") && (this.BigdataIplists.readFromObject(json.BigdataIplists!));
            _hasOwnProperty.call(json, "BigdataSigSession") && (this.BigdataSigSession.readFromObject(json.BigdataSigSession!));
            _hasOwnProperty.call(json, "BigdataKeySession") && (this.BigdataKeySession.readFromObject(json.BigdataKeySession!));
            _hasOwnProperty.call(json, "SigUin") && (this.SigUin = json.SigUin!);
            _hasOwnProperty.call(json, "ConnectFlag") && (this.ConnectFlag = json.ConnectFlag!);
            _hasOwnProperty.call(json, "BigdataPbBuf") && (this.BigdataPbBuf.readFromObject(json.BigdataPbBuf!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new BigDataChannel();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.BigDataChannel._readFrom(is);
        }
    }

    export namespace BigDataChannel {
        export interface Object {
            BigdataIplists?: Array<ConfigPushSvcTars.BigDataIpList.Object>;
            BigdataSigSession?: Buffer;
            BigdataKeySession?: Buffer;
            SigUin?: number;
            ConnectFlag?: number;
            BigdataPbBuf?: Buffer;
        }
    }

    export class FmtIPInfo {
        GateIp: string = "";
        GateIpOper: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.FmtIPInfo";
        protected static _classname = "ConfigPushSvcTars.FmtIPInfo";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new FmtIPInfo;
            tmp.GateIp = is.readString(0, false, "");
            tmp.GateIpOper = is.readInt64(1, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.GateIp);
            os.writeInt64(1, this.GateIpOper);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): FmtIPInfo.Object { 
            return {
                GateIp: this.GateIp,
                GateIpOper: this.GateIpOper
            };
        }

        readFromObject(json: FmtIPInfo.Object) { 
            _hasOwnProperty.call(json, "GateIp") && (this.GateIp = json.GateIp!);
            _hasOwnProperty.call(json, "GateIpOper") && (this.GateIpOper = json.GateIpOper!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new FmtIPInfo();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.FmtIPInfo._readFrom(is);
        }
    }

    export namespace FmtIPInfo {
        export interface Object {
            GateIp?: string;
            GateIpOper?: number;
        }
    }

    export class DomainIpInfo {
        Ip: number = 0;
        Port: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.DomainIpInfo";
        protected static _classname = "ConfigPushSvcTars.DomainIpInfo";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new DomainIpInfo;
            tmp.Ip = is.readInt32(1, false, 0);
            tmp.Port = is.readInt32(2, true, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt32(1, this.Ip);
            os.writeInt32(2, this.Port);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): DomainIpInfo.Object { 
            return {
                Ip: this.Ip,
                Port: this.Port
            };
        }

        readFromObject(json: DomainIpInfo.Object) { 
            _hasOwnProperty.call(json, "Ip") && (this.Ip = json.Ip!);
            _hasOwnProperty.call(json, "Port") && (this.Port = json.Port);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new DomainIpInfo();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.DomainIpInfo._readFrom(is);
        }
    }

    export namespace DomainIpInfo {
        export interface Object {
            Ip?: number;
            Port: number;
        }
    }

    export class DomainIpList {
        DomainType: number = 0;
        IpList: TarsStream.List<ConfigPushSvcTars.DomainIpInfo> = new TarsStream.List(ConfigPushSvcTars.DomainIpInfo);
        Param: TarsStream.BinBuffer = new TarsStream.BinBuffer;
        Param2: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.DomainIpList";
        protected static _classname = "ConfigPushSvcTars.DomainIpList";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new DomainIpList;
            tmp.DomainType = is.readInt32(0, false, 0);
            tmp.IpList = is.readList(1, false, TarsStream.List(ConfigPushSvcTars.DomainIpInfo));
            tmp.Param = is.readBytes(2, false, TarsStream.BinBuffer);
            tmp.Param2 = is.readInt32(4, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt32(0, this.DomainType);
            os.writeList(1, this.IpList);
            os.writeBytes(2, this.Param);
            os.writeInt32(4, this.Param2);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): DomainIpList.Object { 
            return {
                DomainType: this.DomainType,
                IpList: this.IpList.toObject(),
                Param: this.Param.toObject(),
                Param2: this.Param2
            };
        }

        readFromObject(json: DomainIpList.Object) { 
            _hasOwnProperty.call(json, "DomainType") && (this.DomainType = json.DomainType!);
            _hasOwnProperty.call(json, "IpList") && (this.IpList.readFromObject(json.IpList!));
            _hasOwnProperty.call(json, "Param") && (this.Param.readFromObject(json.Param!));
            _hasOwnProperty.call(json, "Param2") && (this.Param2 = json.Param2!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new DomainIpList();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.DomainIpList._readFrom(is);
        }
    }

    export namespace DomainIpList {
        export interface Object {
            DomainType?: number;
            IpList?: Array<ConfigPushSvcTars.DomainIpInfo.Object>;
            Param?: Buffer;
            Param2?: number;
        }
    }

    export class DomainIpChannel {
        DomainIplists: TarsStream.List<ConfigPushSvcTars.DomainIpList> = new TarsStream.List(ConfigPushSvcTars.DomainIpList);

        protected _proto_struct_name_ = "";
        protected _classname = "ConfigPushSvcTars.DomainIpChannel";
        protected static _classname = "ConfigPushSvcTars.DomainIpChannel";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new DomainIpChannel;
            tmp.DomainIplists = is.readList(0, false, TarsStream.List(ConfigPushSvcTars.DomainIpList));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeList(0, this.DomainIplists);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): DomainIpChannel.Object { 
            return {
                DomainIplists: this.DomainIplists.toObject()
            };
        }

        readFromObject(json: DomainIpChannel.Object) { 
            _hasOwnProperty.call(json, "DomainIplists") && (this.DomainIplists.readFromObject(json.DomainIplists!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new DomainIpChannel();
        }

        static create(is: TarsStream.TarsInputStream) {
            return ConfigPushSvcTars.DomainIpChannel._readFrom(is);
        }
    }

    export namespace DomainIpChannel {
        export interface Object {
            DomainIplists?: Array<ConfigPushSvcTars.DomainIpList.Object>;
        }
    }

}


