// **********************************************************************
// Parsed By TarsParser(1.2.0), Generated By tars2node(20200315)
// TarsParser Maintained By <TARS> and tars2node Maintained By <superzheng>
// Generated from "PushForceOffline.tars" by Structure Mode
// **********************************************************************

/* tslint:disable */
/* eslint-disable */

/// <reference types="node" />
import assert = require("assert");
import * as TarsStream from "@tars/stream";

const _hasOwnProperty = Object.prototype.hasOwnProperty;

export namespace PushForceOffline {
    export class Pack {
        Uin: number = 0;
        Title: string = "";
        Ttips: string = "";
        SameDevice: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "PushForceOffline.Pack";
        protected static _classname = "PushForceOffline.Pack";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new Pack;
            tmp.Uin = is.readInt64(0, true, 0);
            tmp.Title = is.readString(1, true, "");
            tmp.Ttips = is.readString(2, true, "");
            tmp.SameDevice = is.readString(3, true, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt64(0, this.Uin);
            os.writeString(1, this.Title);
            os.writeString(2, this.Ttips);
            os.writeString(3, this.SameDevice);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): Pack.Object { 
            return {
                Uin: this.Uin,
                Title: this.Title,
                Ttips: this.Ttips,
                SameDevice: this.SameDevice
            };
        }

        readFromObject(json: Pack.Object) { 
            _hasOwnProperty.call(json, "Uin") && (this.Uin = json.Uin);
            _hasOwnProperty.call(json, "Title") && (this.Title = json.Title);
            _hasOwnProperty.call(json, "Ttips") && (this.Ttips = json.Ttips);
            _hasOwnProperty.call(json, "SameDevice") && (this.SameDevice = json.SameDevice);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new Pack();
        }

        static create(is: TarsStream.TarsInputStream) {
            return PushForceOffline.Pack._readFrom(is);
        }
    }

    export namespace Pack {
        export interface Object {
            Uin: number;
            Title: string;
            Ttips: string;
            SameDevice: string;
        }
    }

}


