/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.Msg = (function() {

    /**
     * Namespace Msg.
     * @exports Msg
     * @namespace
     */
    var Msg = {};

    Msg.MsgField = (function() {

        /**
         * Properties of a MsgField.
         * @memberof Msg
         * @interface IMsgField
         */

        /**
         * Constructs a new MsgField.
         * @memberof Msg
         * @classdesc Represents a MsgField.
         * @implements IMsgField
         * @constructor
         * @param {Msg.IMsgField=} [properties] Properties to set
         */
        function MsgField(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MsgField instance using the specified properties.
         * @function create
         * @memberof Msg.MsgField
         * @static
         * @param {Msg.IMsgField=} [properties] Properties to set
         * @returns {Msg.MsgField} MsgField instance
         */
        MsgField.create = function create(properties) {
            return new MsgField(properties);
        };

        /**
         * Encodes the specified MsgField message. Does not implicitly {@link Msg.MsgField.verify|verify} messages.
         * @function encode
         * @memberof Msg.MsgField
         * @static
         * @param {Msg.IMsgField} message MsgField message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgField.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MsgField message, length delimited. Does not implicitly {@link Msg.MsgField.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.MsgField
         * @static
         * @param {Msg.IMsgField} message MsgField message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgField.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgField message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.MsgField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.MsgField} MsgField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgField.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgField message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.MsgField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.MsgField} MsgField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgField.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgField message.
         * @function verify
         * @memberof Msg.MsgField
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgField.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MsgField message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.MsgField
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.MsgField} MsgField
         */
        MsgField.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.MsgField)
                return object;
            return new $root.Msg.MsgField();
        };

        /**
         * Creates a plain object from a MsgField message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.MsgField
         * @static
         * @param {Msg.MsgField} message MsgField
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgField.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MsgField to JSON.
         * @function toJSON
         * @memberof Msg.MsgField
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgField.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        MsgField.ImMsgBody = (function() {

            /**
             * Properties of an ImMsgBody.
             * @memberof Msg.MsgField
             * @interface IImMsgBody
             */

            /**
             * Constructs a new ImMsgBody.
             * @memberof Msg.MsgField
             * @classdesc Represents an ImMsgBody.
             * @implements IImMsgBody
             * @constructor
             * @param {Msg.MsgField.IImMsgBody=} [properties] Properties to set
             */
            function ImMsgBody(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ImMsgBody instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {Msg.MsgField.IImMsgBody=} [properties] Properties to set
             * @returns {Msg.MsgField.ImMsgBody} ImMsgBody instance
             */
            ImMsgBody.create = function create(properties) {
                return new ImMsgBody(properties);
            };

            /**
             * Encodes the specified ImMsgBody message. Does not implicitly {@link Msg.MsgField.ImMsgBody.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {Msg.MsgField.IImMsgBody} message ImMsgBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImMsgBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ImMsgBody message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {Msg.MsgField.IImMsgBody} message ImMsgBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImMsgBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImMsgBody message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.ImMsgBody} ImMsgBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImMsgBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImMsgBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.ImMsgBody} ImMsgBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImMsgBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImMsgBody message.
             * @function verify
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImMsgBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ImMsgBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.ImMsgBody} ImMsgBody
             */
            ImMsgBody.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.ImMsgBody)
                    return object;
                return new $root.Msg.MsgField.ImMsgBody();
            };

            /**
             * Creates a plain object from an ImMsgBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.ImMsgBody
             * @static
             * @param {Msg.MsgField.ImMsgBody} message ImMsgBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImMsgBody.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ImMsgBody to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.ImMsgBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImMsgBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ImMsgBody.Attribute = (function() {

                /**
                 * Properties of an Attribute.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IAttribute
                 * @property {number|null} [CodePage] Attribute CodePage
                 * @property {number|null} [Time] Attribute Time
                 * @property {number|null} [Random] Attribute Random
                 * @property {number|null} [Color] Attribute Color
                 * @property {number|null} [Size] Attribute Size
                 * @property {number|null} [Effect] Attribute Effect
                 * @property {number|null} [CharSet] Attribute CharSet
                 * @property {number|null} [PitchAndFamily] Attribute PitchAndFamily
                 * @property {Uint8Array|null} [FontName] Attribute FontName
                 * @property {Uint8Array|null} [ReserveData] Attribute ReserveData
                 */

                /**
                 * Constructs a new Attribute.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an Attribute.
                 * @implements IAttribute
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IAttribute=} [properties] Properties to set
                 */
                function Attribute(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Attribute CodePage.
                 * @member {number} CodePage
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.CodePage = 0;

                /**
                 * Attribute Time.
                 * @member {number} Time
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.Time = 0;

                /**
                 * Attribute Random.
                 * @member {number} Random
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.Random = 0;

                /**
                 * Attribute Color.
                 * @member {number} Color
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.Color = 0;

                /**
                 * Attribute Size.
                 * @member {number} Size
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.Size = 0;

                /**
                 * Attribute Effect.
                 * @member {number} Effect
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.Effect = 0;

                /**
                 * Attribute CharSet.
                 * @member {number} CharSet
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.CharSet = 0;

                /**
                 * Attribute PitchAndFamily.
                 * @member {number} PitchAndFamily
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.PitchAndFamily = 0;

                /**
                 * Attribute FontName.
                 * @member {Uint8Array} FontName
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.FontName = $util.newBuffer([]);

                /**
                 * Attribute ReserveData.
                 * @member {Uint8Array} ReserveData
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 */
                Attribute.prototype.ReserveData = $util.newBuffer([]);

                /**
                 * Creates a new Attribute instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IAttribute=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Attribute} Attribute instance
                 */
                Attribute.create = function create(properties) {
                    return new Attribute(properties);
                };

                /**
                 * Encodes the specified Attribute message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Attribute.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IAttribute} message Attribute message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attribute.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.CodePage != null && Object.hasOwnProperty.call(message, "CodePage"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CodePage);
                    if (message.Time != null && Object.hasOwnProperty.call(message, "Time"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Time);
                    if (message.Random != null && Object.hasOwnProperty.call(message, "Random"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Random);
                    if (message.Color != null && Object.hasOwnProperty.call(message, "Color"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Color);
                    if (message.Size != null && Object.hasOwnProperty.call(message, "Size"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Size);
                    if (message.Effect != null && Object.hasOwnProperty.call(message, "Effect"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Effect);
                    if (message.CharSet != null && Object.hasOwnProperty.call(message, "CharSet"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.CharSet);
                    if (message.PitchAndFamily != null && Object.hasOwnProperty.call(message, "PitchAndFamily"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.PitchAndFamily);
                    if (message.FontName != null && Object.hasOwnProperty.call(message, "FontName"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.FontName);
                    if (message.ReserveData != null && Object.hasOwnProperty.call(message, "ReserveData"))
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.ReserveData);
                    return writer;
                };

                /**
                 * Encodes the specified Attribute message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Attribute.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IAttribute} message Attribute message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attribute.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Attribute message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Attribute} Attribute
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attribute.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Attribute();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.CodePage = reader.int32();
                            break;
                        case 2:
                            message.Time = reader.int32();
                            break;
                        case 3:
                            message.Random = reader.int32();
                            break;
                        case 4:
                            message.Color = reader.int32();
                            break;
                        case 5:
                            message.Size = reader.int32();
                            break;
                        case 6:
                            message.Effect = reader.int32();
                            break;
                        case 7:
                            message.CharSet = reader.int32();
                            break;
                        case 8:
                            message.PitchAndFamily = reader.int32();
                            break;
                        case 9:
                            message.FontName = reader.bytes();
                            break;
                        case 10:
                            message.ReserveData = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Attribute message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Attribute} Attribute
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attribute.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Attribute message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Attribute.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.CodePage != null && message.hasOwnProperty("CodePage"))
                        if (!$util.isInteger(message.CodePage))
                            return "CodePage: integer expected";
                    if (message.Time != null && message.hasOwnProperty("Time"))
                        if (!$util.isInteger(message.Time))
                            return "Time: integer expected";
                    if (message.Random != null && message.hasOwnProperty("Random"))
                        if (!$util.isInteger(message.Random))
                            return "Random: integer expected";
                    if (message.Color != null && message.hasOwnProperty("Color"))
                        if (!$util.isInteger(message.Color))
                            return "Color: integer expected";
                    if (message.Size != null && message.hasOwnProperty("Size"))
                        if (!$util.isInteger(message.Size))
                            return "Size: integer expected";
                    if (message.Effect != null && message.hasOwnProperty("Effect"))
                        if (!$util.isInteger(message.Effect))
                            return "Effect: integer expected";
                    if (message.CharSet != null && message.hasOwnProperty("CharSet"))
                        if (!$util.isInteger(message.CharSet))
                            return "CharSet: integer expected";
                    if (message.PitchAndFamily != null && message.hasOwnProperty("PitchAndFamily"))
                        if (!$util.isInteger(message.PitchAndFamily))
                            return "PitchAndFamily: integer expected";
                    if (message.FontName != null && message.hasOwnProperty("FontName"))
                        if (!(message.FontName && typeof message.FontName.length === "number" || $util.isString(message.FontName)))
                            return "FontName: buffer expected";
                    if (message.ReserveData != null && message.hasOwnProperty("ReserveData"))
                        if (!(message.ReserveData && typeof message.ReserveData.length === "number" || $util.isString(message.ReserveData)))
                            return "ReserveData: buffer expected";
                    return null;
                };

                /**
                 * Creates an Attribute message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Attribute} Attribute
                 */
                Attribute.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Attribute)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Attribute();
                    if (object.CodePage != null)
                        message.CodePage = object.CodePage | 0;
                    if (object.Time != null)
                        message.Time = object.Time | 0;
                    if (object.Random != null)
                        message.Random = object.Random | 0;
                    if (object.Color != null)
                        message.Color = object.Color | 0;
                    if (object.Size != null)
                        message.Size = object.Size | 0;
                    if (object.Effect != null)
                        message.Effect = object.Effect | 0;
                    if (object.CharSet != null)
                        message.CharSet = object.CharSet | 0;
                    if (object.PitchAndFamily != null)
                        message.PitchAndFamily = object.PitchAndFamily | 0;
                    if (object.FontName != null)
                        if (typeof object.FontName === "string")
                            $util.base64.decode(object.FontName, message.FontName = $util.newBuffer($util.base64.length(object.FontName)), 0);
                        else if (object.FontName.length)
                            message.FontName = object.FontName;
                    if (object.ReserveData != null)
                        if (typeof object.ReserveData === "string")
                            $util.base64.decode(object.ReserveData, message.ReserveData = $util.newBuffer($util.base64.length(object.ReserveData)), 0);
                        else if (object.ReserveData.length)
                            message.ReserveData = object.ReserveData;
                    return message;
                };

                /**
                 * Creates a plain object from an Attribute message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Attribute} message Attribute
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Attribute.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.CodePage = 0;
                        object.Time = 0;
                        object.Random = 0;
                        object.Color = 0;
                        object.Size = 0;
                        object.Effect = 0;
                        object.CharSet = 0;
                        object.PitchAndFamily = 0;
                        if (options.bytes === String)
                            object.FontName = "";
                        else {
                            object.FontName = [];
                            if (options.bytes !== Array)
                                object.FontName = $util.newBuffer(object.FontName);
                        }
                        if (options.bytes === String)
                            object.ReserveData = "";
                        else {
                            object.ReserveData = [];
                            if (options.bytes !== Array)
                                object.ReserveData = $util.newBuffer(object.ReserveData);
                        }
                    }
                    if (message.CodePage != null && message.hasOwnProperty("CodePage"))
                        object.CodePage = message.CodePage;
                    if (message.Time != null && message.hasOwnProperty("Time"))
                        object.Time = message.Time;
                    if (message.Random != null && message.hasOwnProperty("Random"))
                        object.Random = message.Random;
                    if (message.Color != null && message.hasOwnProperty("Color"))
                        object.Color = message.Color;
                    if (message.Size != null && message.hasOwnProperty("Size"))
                        object.Size = message.Size;
                    if (message.Effect != null && message.hasOwnProperty("Effect"))
                        object.Effect = message.Effect;
                    if (message.CharSet != null && message.hasOwnProperty("CharSet"))
                        object.CharSet = message.CharSet;
                    if (message.PitchAndFamily != null && message.hasOwnProperty("PitchAndFamily"))
                        object.PitchAndFamily = message.PitchAndFamily;
                    if (message.FontName != null && message.hasOwnProperty("FontName"))
                        object.FontName = options.bytes === String ? $util.base64.encode(message.FontName, 0, message.FontName.length) : options.bytes === Array ? Array.prototype.slice.call(message.FontName) : message.FontName;
                    if (message.ReserveData != null && message.hasOwnProperty("ReserveData"))
                        object.ReserveData = options.bytes === String ? $util.base64.encode(message.ReserveData, 0, message.ReserveData.length) : options.bytes === Array ? Array.prototype.slice.call(message.ReserveData) : message.ReserveData;
                    return object;
                };

                /**
                 * Converts this Attribute to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Attribute
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Attribute.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Attribute;
            })();

            ImMsgBody.NotOnlineFile = (function() {

                /**
                 * Properties of a NotOnlineFile.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface INotOnlineFile
                 * @property {number|null} [FileType] NotOnlineFile FileType
                 * @property {Uint8Array|null} [Sig] NotOnlineFile Sig
                 * @property {Uint8Array|null} [FileUuid] NotOnlineFile FileUuid
                 * @property {Uint8Array|null} [FileMd5] NotOnlineFile FileMd5
                 * @property {Uint8Array|null} [FileName] NotOnlineFile FileName
                 * @property {number|null} [FileSize] NotOnlineFile FileSize
                 * @property {Uint8Array|null} [Note] NotOnlineFile Note
                 * @property {Uint8Array|null} [Reserved] NotOnlineFile Reserved
                 * @property {number|null} [Subcmd] NotOnlineFile Subcmd
                 * @property {number|null} [MicroCloud] NotOnlineFile MicroCloud
                 * @property {Array.<Uint8Array>|null} [BytesFileUrls] NotOnlineFile BytesFileUrls
                 * @property {number|null} [DownloadFlag] NotOnlineFile DownloadFlag
                 * @property {number|null} [DangerEvel] NotOnlineFile DangerEvel
                 * @property {number|null} [LifeTime] NotOnlineFile LifeTime
                 * @property {number|null} [UploadTime] NotOnlineFile UploadTime
                 * @property {number|null} [AbsFileType] NotOnlineFile AbsFileType
                 * @property {number|null} [ClientType] NotOnlineFile ClientType
                 * @property {number|null} [ExpireTime] NotOnlineFile ExpireTime
                 * @property {Uint8Array|null} [PbReserve] NotOnlineFile PbReserve
                 */

                /**
                 * Constructs a new NotOnlineFile.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a NotOnlineFile.
                 * @implements INotOnlineFile
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineFile=} [properties] Properties to set
                 */
                function NotOnlineFile(properties) {
                    this.BytesFileUrls = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NotOnlineFile FileType.
                 * @member {number} FileType
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.FileType = 0;

                /**
                 * NotOnlineFile Sig.
                 * @member {Uint8Array} Sig
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.Sig = $util.newBuffer([]);

                /**
                 * NotOnlineFile FileUuid.
                 * @member {Uint8Array} FileUuid
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.FileUuid = $util.newBuffer([]);

                /**
                 * NotOnlineFile FileMd5.
                 * @member {Uint8Array} FileMd5
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.FileMd5 = $util.newBuffer([]);

                /**
                 * NotOnlineFile FileName.
                 * @member {Uint8Array} FileName
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.FileName = $util.newBuffer([]);

                /**
                 * NotOnlineFile FileSize.
                 * @member {number} FileSize
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.FileSize = 0;

                /**
                 * NotOnlineFile Note.
                 * @member {Uint8Array} Note
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.Note = $util.newBuffer([]);

                /**
                 * NotOnlineFile Reserved.
                 * @member {Uint8Array} Reserved
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.Reserved = $util.newBuffer([]);

                /**
                 * NotOnlineFile Subcmd.
                 * @member {number} Subcmd
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.Subcmd = 0;

                /**
                 * NotOnlineFile MicroCloud.
                 * @member {number} MicroCloud
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.MicroCloud = 0;

                /**
                 * NotOnlineFile BytesFileUrls.
                 * @member {Array.<Uint8Array>} BytesFileUrls
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.BytesFileUrls = $util.emptyArray;

                /**
                 * NotOnlineFile DownloadFlag.
                 * @member {number} DownloadFlag
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.DownloadFlag = 0;

                /**
                 * NotOnlineFile DangerEvel.
                 * @member {number} DangerEvel
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.DangerEvel = 0;

                /**
                 * NotOnlineFile LifeTime.
                 * @member {number} LifeTime
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.LifeTime = 0;

                /**
                 * NotOnlineFile UploadTime.
                 * @member {number} UploadTime
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.UploadTime = 0;

                /**
                 * NotOnlineFile AbsFileType.
                 * @member {number} AbsFileType
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.AbsFileType = 0;

                /**
                 * NotOnlineFile ClientType.
                 * @member {number} ClientType
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.ClientType = 0;

                /**
                 * NotOnlineFile ExpireTime.
                 * @member {number} ExpireTime
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.ExpireTime = 0;

                /**
                 * NotOnlineFile PbReserve.
                 * @member {Uint8Array} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 */
                NotOnlineFile.prototype.PbReserve = $util.newBuffer([]);

                /**
                 * Creates a new NotOnlineFile instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineFile=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineFile} NotOnlineFile instance
                 */
                NotOnlineFile.create = function create(properties) {
                    return new NotOnlineFile(properties);
                };

                /**
                 * Encodes the specified NotOnlineFile message. Does not implicitly {@link Msg.MsgField.ImMsgBody.NotOnlineFile.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineFile} message NotOnlineFile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotOnlineFile.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FileType != null && Object.hasOwnProperty.call(message, "FileType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.FileType);
                    if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                    if (message.FileUuid != null && Object.hasOwnProperty.call(message, "FileUuid"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.FileUuid);
                    if (message.FileMd5 != null && Object.hasOwnProperty.call(message, "FileMd5"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.FileMd5);
                    if (message.FileName != null && Object.hasOwnProperty.call(message, "FileName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.FileName);
                    if (message.FileSize != null && Object.hasOwnProperty.call(message, "FileSize"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.FileSize);
                    if (message.Note != null && Object.hasOwnProperty.call(message, "Note"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Note);
                    if (message.Reserved != null && Object.hasOwnProperty.call(message, "Reserved"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Reserved);
                    if (message.Subcmd != null && Object.hasOwnProperty.call(message, "Subcmd"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Subcmd);
                    if (message.MicroCloud != null && Object.hasOwnProperty.call(message, "MicroCloud"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.MicroCloud);
                    if (message.BytesFileUrls != null && message.BytesFileUrls.length)
                        for (var i = 0; i < message.BytesFileUrls.length; ++i)
                            writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.BytesFileUrls[i]);
                    if (message.DownloadFlag != null && Object.hasOwnProperty.call(message, "DownloadFlag"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.DownloadFlag);
                    if (message.DangerEvel != null && Object.hasOwnProperty.call(message, "DangerEvel"))
                        writer.uint32(/* id 50, wireType 0 =*/400).int32(message.DangerEvel);
                    if (message.LifeTime != null && Object.hasOwnProperty.call(message, "LifeTime"))
                        writer.uint32(/* id 51, wireType 0 =*/408).int32(message.LifeTime);
                    if (message.UploadTime != null && Object.hasOwnProperty.call(message, "UploadTime"))
                        writer.uint32(/* id 52, wireType 0 =*/416).int32(message.UploadTime);
                    if (message.AbsFileType != null && Object.hasOwnProperty.call(message, "AbsFileType"))
                        writer.uint32(/* id 53, wireType 0 =*/424).int32(message.AbsFileType);
                    if (message.ClientType != null && Object.hasOwnProperty.call(message, "ClientType"))
                        writer.uint32(/* id 54, wireType 0 =*/432).int32(message.ClientType);
                    if (message.ExpireTime != null && Object.hasOwnProperty.call(message, "ExpireTime"))
                        writer.uint32(/* id 55, wireType 0 =*/440).int32(message.ExpireTime);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 56, wireType 2 =*/450).bytes(message.PbReserve);
                    return writer;
                };

                /**
                 * Encodes the specified NotOnlineFile message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.NotOnlineFile.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineFile} message NotOnlineFile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotOnlineFile.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NotOnlineFile message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineFile} NotOnlineFile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotOnlineFile.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.NotOnlineFile();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.FileType = reader.int32();
                            break;
                        case 2:
                            message.Sig = reader.bytes();
                            break;
                        case 3:
                            message.FileUuid = reader.bytes();
                            break;
                        case 4:
                            message.FileMd5 = reader.bytes();
                            break;
                        case 5:
                            message.FileName = reader.bytes();
                            break;
                        case 6:
                            message.FileSize = reader.float();
                            break;
                        case 7:
                            message.Note = reader.bytes();
                            break;
                        case 8:
                            message.Reserved = reader.bytes();
                            break;
                        case 9:
                            message.Subcmd = reader.int32();
                            break;
                        case 10:
                            message.MicroCloud = reader.int32();
                            break;
                        case 11:
                            if (!(message.BytesFileUrls && message.BytesFileUrls.length))
                                message.BytesFileUrls = [];
                            message.BytesFileUrls.push(reader.bytes());
                            break;
                        case 12:
                            message.DownloadFlag = reader.int32();
                            break;
                        case 50:
                            message.DangerEvel = reader.int32();
                            break;
                        case 51:
                            message.LifeTime = reader.int32();
                            break;
                        case 52:
                            message.UploadTime = reader.int32();
                            break;
                        case 53:
                            message.AbsFileType = reader.int32();
                            break;
                        case 54:
                            message.ClientType = reader.int32();
                            break;
                        case 55:
                            message.ExpireTime = reader.int32();
                            break;
                        case 56:
                            message.PbReserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NotOnlineFile message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineFile} NotOnlineFile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotOnlineFile.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NotOnlineFile message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NotOnlineFile.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        if (!$util.isInteger(message.FileType))
                            return "FileType: integer expected";
                    if (message.Sig != null && message.hasOwnProperty("Sig"))
                        if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                            return "Sig: buffer expected";
                    if (message.FileUuid != null && message.hasOwnProperty("FileUuid"))
                        if (!(message.FileUuid && typeof message.FileUuid.length === "number" || $util.isString(message.FileUuid)))
                            return "FileUuid: buffer expected";
                    if (message.FileMd5 != null && message.hasOwnProperty("FileMd5"))
                        if (!(message.FileMd5 && typeof message.FileMd5.length === "number" || $util.isString(message.FileMd5)))
                            return "FileMd5: buffer expected";
                    if (message.FileName != null && message.hasOwnProperty("FileName"))
                        if (!(message.FileName && typeof message.FileName.length === "number" || $util.isString(message.FileName)))
                            return "FileName: buffer expected";
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        if (typeof message.FileSize !== "number")
                            return "FileSize: number expected";
                    if (message.Note != null && message.hasOwnProperty("Note"))
                        if (!(message.Note && typeof message.Note.length === "number" || $util.isString(message.Note)))
                            return "Note: buffer expected";
                    if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                        if (!(message.Reserved && typeof message.Reserved.length === "number" || $util.isString(message.Reserved)))
                            return "Reserved: buffer expected";
                    if (message.Subcmd != null && message.hasOwnProperty("Subcmd"))
                        if (!$util.isInteger(message.Subcmd))
                            return "Subcmd: integer expected";
                    if (message.MicroCloud != null && message.hasOwnProperty("MicroCloud"))
                        if (!$util.isInteger(message.MicroCloud))
                            return "MicroCloud: integer expected";
                    if (message.BytesFileUrls != null && message.hasOwnProperty("BytesFileUrls")) {
                        if (!Array.isArray(message.BytesFileUrls))
                            return "BytesFileUrls: array expected";
                        for (var i = 0; i < message.BytesFileUrls.length; ++i)
                            if (!(message.BytesFileUrls[i] && typeof message.BytesFileUrls[i].length === "number" || $util.isString(message.BytesFileUrls[i])))
                                return "BytesFileUrls: buffer[] expected";
                    }
                    if (message.DownloadFlag != null && message.hasOwnProperty("DownloadFlag"))
                        if (!$util.isInteger(message.DownloadFlag))
                            return "DownloadFlag: integer expected";
                    if (message.DangerEvel != null && message.hasOwnProperty("DangerEvel"))
                        if (!$util.isInteger(message.DangerEvel))
                            return "DangerEvel: integer expected";
                    if (message.LifeTime != null && message.hasOwnProperty("LifeTime"))
                        if (!$util.isInteger(message.LifeTime))
                            return "LifeTime: integer expected";
                    if (message.UploadTime != null && message.hasOwnProperty("UploadTime"))
                        if (!$util.isInteger(message.UploadTime))
                            return "UploadTime: integer expected";
                    if (message.AbsFileType != null && message.hasOwnProperty("AbsFileType"))
                        if (!$util.isInteger(message.AbsFileType))
                            return "AbsFileType: integer expected";
                    if (message.ClientType != null && message.hasOwnProperty("ClientType"))
                        if (!$util.isInteger(message.ClientType))
                            return "ClientType: integer expected";
                    if (message.ExpireTime != null && message.hasOwnProperty("ExpireTime"))
                        if (!$util.isInteger(message.ExpireTime))
                            return "ExpireTime: integer expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                            return "PbReserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a NotOnlineFile message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineFile} NotOnlineFile
                 */
                NotOnlineFile.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.NotOnlineFile)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.NotOnlineFile();
                    if (object.FileType != null)
                        message.FileType = object.FileType | 0;
                    if (object.Sig != null)
                        if (typeof object.Sig === "string")
                            $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                        else if (object.Sig.length)
                            message.Sig = object.Sig;
                    if (object.FileUuid != null)
                        if (typeof object.FileUuid === "string")
                            $util.base64.decode(object.FileUuid, message.FileUuid = $util.newBuffer($util.base64.length(object.FileUuid)), 0);
                        else if (object.FileUuid.length)
                            message.FileUuid = object.FileUuid;
                    if (object.FileMd5 != null)
                        if (typeof object.FileMd5 === "string")
                            $util.base64.decode(object.FileMd5, message.FileMd5 = $util.newBuffer($util.base64.length(object.FileMd5)), 0);
                        else if (object.FileMd5.length)
                            message.FileMd5 = object.FileMd5;
                    if (object.FileName != null)
                        if (typeof object.FileName === "string")
                            $util.base64.decode(object.FileName, message.FileName = $util.newBuffer($util.base64.length(object.FileName)), 0);
                        else if (object.FileName.length)
                            message.FileName = object.FileName;
                    if (object.FileSize != null)
                        message.FileSize = Number(object.FileSize);
                    if (object.Note != null)
                        if (typeof object.Note === "string")
                            $util.base64.decode(object.Note, message.Note = $util.newBuffer($util.base64.length(object.Note)), 0);
                        else if (object.Note.length)
                            message.Note = object.Note;
                    if (object.Reserved != null)
                        if (typeof object.Reserved === "string")
                            $util.base64.decode(object.Reserved, message.Reserved = $util.newBuffer($util.base64.length(object.Reserved)), 0);
                        else if (object.Reserved.length)
                            message.Reserved = object.Reserved;
                    if (object.Subcmd != null)
                        message.Subcmd = object.Subcmd | 0;
                    if (object.MicroCloud != null)
                        message.MicroCloud = object.MicroCloud | 0;
                    if (object.BytesFileUrls) {
                        if (!Array.isArray(object.BytesFileUrls))
                            throw TypeError(".Msg.MsgField.ImMsgBody.NotOnlineFile.BytesFileUrls: array expected");
                        message.BytesFileUrls = [];
                        for (var i = 0; i < object.BytesFileUrls.length; ++i)
                            if (typeof object.BytesFileUrls[i] === "string")
                                $util.base64.decode(object.BytesFileUrls[i], message.BytesFileUrls[i] = $util.newBuffer($util.base64.length(object.BytesFileUrls[i])), 0);
                            else if (object.BytesFileUrls[i].length)
                                message.BytesFileUrls[i] = object.BytesFileUrls[i];
                    }
                    if (object.DownloadFlag != null)
                        message.DownloadFlag = object.DownloadFlag | 0;
                    if (object.DangerEvel != null)
                        message.DangerEvel = object.DangerEvel | 0;
                    if (object.LifeTime != null)
                        message.LifeTime = object.LifeTime | 0;
                    if (object.UploadTime != null)
                        message.UploadTime = object.UploadTime | 0;
                    if (object.AbsFileType != null)
                        message.AbsFileType = object.AbsFileType | 0;
                    if (object.ClientType != null)
                        message.ClientType = object.ClientType | 0;
                    if (object.ExpireTime != null)
                        message.ExpireTime = object.ExpireTime | 0;
                    if (object.PbReserve != null)
                        if (typeof object.PbReserve === "string")
                            $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                        else if (object.PbReserve.length)
                            message.PbReserve = object.PbReserve;
                    return message;
                };

                /**
                 * Creates a plain object from a NotOnlineFile message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.NotOnlineFile} message NotOnlineFile
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NotOnlineFile.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.BytesFileUrls = [];
                    if (options.defaults) {
                        object.FileType = 0;
                        if (options.bytes === String)
                            object.Sig = "";
                        else {
                            object.Sig = [];
                            if (options.bytes !== Array)
                                object.Sig = $util.newBuffer(object.Sig);
                        }
                        if (options.bytes === String)
                            object.FileUuid = "";
                        else {
                            object.FileUuid = [];
                            if (options.bytes !== Array)
                                object.FileUuid = $util.newBuffer(object.FileUuid);
                        }
                        if (options.bytes === String)
                            object.FileMd5 = "";
                        else {
                            object.FileMd5 = [];
                            if (options.bytes !== Array)
                                object.FileMd5 = $util.newBuffer(object.FileMd5);
                        }
                        if (options.bytes === String)
                            object.FileName = "";
                        else {
                            object.FileName = [];
                            if (options.bytes !== Array)
                                object.FileName = $util.newBuffer(object.FileName);
                        }
                        object.FileSize = 0;
                        if (options.bytes === String)
                            object.Note = "";
                        else {
                            object.Note = [];
                            if (options.bytes !== Array)
                                object.Note = $util.newBuffer(object.Note);
                        }
                        if (options.bytes === String)
                            object.Reserved = "";
                        else {
                            object.Reserved = [];
                            if (options.bytes !== Array)
                                object.Reserved = $util.newBuffer(object.Reserved);
                        }
                        object.Subcmd = 0;
                        object.MicroCloud = 0;
                        object.DownloadFlag = 0;
                        object.DangerEvel = 0;
                        object.LifeTime = 0;
                        object.UploadTime = 0;
                        object.AbsFileType = 0;
                        object.ClientType = 0;
                        object.ExpireTime = 0;
                        if (options.bytes === String)
                            object.PbReserve = "";
                        else {
                            object.PbReserve = [];
                            if (options.bytes !== Array)
                                object.PbReserve = $util.newBuffer(object.PbReserve);
                        }
                    }
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        object.FileType = message.FileType;
                    if (message.Sig != null && message.hasOwnProperty("Sig"))
                        object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                    if (message.FileUuid != null && message.hasOwnProperty("FileUuid"))
                        object.FileUuid = options.bytes === String ? $util.base64.encode(message.FileUuid, 0, message.FileUuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileUuid) : message.FileUuid;
                    if (message.FileMd5 != null && message.hasOwnProperty("FileMd5"))
                        object.FileMd5 = options.bytes === String ? $util.base64.encode(message.FileMd5, 0, message.FileMd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileMd5) : message.FileMd5;
                    if (message.FileName != null && message.hasOwnProperty("FileName"))
                        object.FileName = options.bytes === String ? $util.base64.encode(message.FileName, 0, message.FileName.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileName) : message.FileName;
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        object.FileSize = options.json && !isFinite(message.FileSize) ? String(message.FileSize) : message.FileSize;
                    if (message.Note != null && message.hasOwnProperty("Note"))
                        object.Note = options.bytes === String ? $util.base64.encode(message.Note, 0, message.Note.length) : options.bytes === Array ? Array.prototype.slice.call(message.Note) : message.Note;
                    if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                        object.Reserved = options.bytes === String ? $util.base64.encode(message.Reserved, 0, message.Reserved.length) : options.bytes === Array ? Array.prototype.slice.call(message.Reserved) : message.Reserved;
                    if (message.Subcmd != null && message.hasOwnProperty("Subcmd"))
                        object.Subcmd = message.Subcmd;
                    if (message.MicroCloud != null && message.hasOwnProperty("MicroCloud"))
                        object.MicroCloud = message.MicroCloud;
                    if (message.BytesFileUrls && message.BytesFileUrls.length) {
                        object.BytesFileUrls = [];
                        for (var j = 0; j < message.BytesFileUrls.length; ++j)
                            object.BytesFileUrls[j] = options.bytes === String ? $util.base64.encode(message.BytesFileUrls[j], 0, message.BytesFileUrls[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.BytesFileUrls[j]) : message.BytesFileUrls[j];
                    }
                    if (message.DownloadFlag != null && message.hasOwnProperty("DownloadFlag"))
                        object.DownloadFlag = message.DownloadFlag;
                    if (message.DangerEvel != null && message.hasOwnProperty("DangerEvel"))
                        object.DangerEvel = message.DangerEvel;
                    if (message.LifeTime != null && message.hasOwnProperty("LifeTime"))
                        object.LifeTime = message.LifeTime;
                    if (message.UploadTime != null && message.hasOwnProperty("UploadTime"))
                        object.UploadTime = message.UploadTime;
                    if (message.AbsFileType != null && message.hasOwnProperty("AbsFileType"))
                        object.AbsFileType = message.AbsFileType;
                    if (message.ClientType != null && message.hasOwnProperty("ClientType"))
                        object.ClientType = message.ClientType;
                    if (message.ExpireTime != null && message.hasOwnProperty("ExpireTime"))
                        object.ExpireTime = message.ExpireTime;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                    return object;
                };

                /**
                 * Converts this NotOnlineFile to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineFile
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NotOnlineFile.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NotOnlineFile;
            })();

            ImMsgBody.Ptt = (function() {

                /**
                 * Properties of a Ptt.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IPtt
                 * @property {number|null} [FileType] Ptt FileType
                 * @property {number|Long|null} [SrcUin] Ptt SrcUin
                 * @property {Uint8Array|null} [FileUuid] Ptt FileUuid
                 * @property {Uint8Array|null} [FileMd5] Ptt FileMd5
                 * @property {Uint8Array|null} [FileName] Ptt FileName
                 * @property {number|null} [FileSize] Ptt FileSize
                 * @property {Uint8Array|null} [Reserve] Ptt Reserve
                 * @property {number|null} [FileId] Ptt FileId
                 * @property {number|null} [ServerIp] Ptt ServerIp
                 * @property {number|null} [ServerPort] Ptt ServerPort
                 * @property {boolean|null} [BoolValid] Ptt BoolValid
                 * @property {Uint8Array|null} [Signature] Ptt Signature
                 * @property {Uint8Array|null} [Shortcut] Ptt Shortcut
                 * @property {Uint8Array|null} [FileKey] Ptt FileKey
                 * @property {number|null} [MagicPttIndex] Ptt MagicPttIndex
                 * @property {number|null} [VoiceSwitch] Ptt VoiceSwitch
                 * @property {Uint8Array|null} [PttUrl] Ptt PttUrl
                 * @property {Uint8Array|null} [GroupFileKey] Ptt GroupFileKey
                 * @property {number|null} [Time] Ptt Time
                 * @property {Uint8Array|null} [DownPara] Ptt DownPara
                 * @property {number|null} [Format] Ptt Format
                 * @property {Uint8Array|null} [PbReserve] Ptt PbReserve
                 * @property {Array.<Uint8Array>|null} [BytesPttUrls] Ptt BytesPttUrls
                 * @property {number|null} [DownloadFlag] Ptt DownloadFlag
                 */

                /**
                 * Constructs a new Ptt.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a Ptt.
                 * @implements IPtt
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IPtt=} [properties] Properties to set
                 */
                function Ptt(properties) {
                    this.BytesPttUrls = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Ptt FileType.
                 * @member {number} FileType
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.FileType = 0;

                /**
                 * Ptt SrcUin.
                 * @member {number|Long} SrcUin
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.SrcUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Ptt FileUuid.
                 * @member {Uint8Array} FileUuid
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.FileUuid = $util.newBuffer([]);

                /**
                 * Ptt FileMd5.
                 * @member {Uint8Array} FileMd5
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.FileMd5 = $util.newBuffer([]);

                /**
                 * Ptt FileName.
                 * @member {Uint8Array} FileName
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.FileName = $util.newBuffer([]);

                /**
                 * Ptt FileSize.
                 * @member {number} FileSize
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.FileSize = 0;

                /**
                 * Ptt Reserve.
                 * @member {Uint8Array} Reserve
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.Reserve = $util.newBuffer([]);

                /**
                 * Ptt FileId.
                 * @member {number} FileId
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.FileId = 0;

                /**
                 * Ptt ServerIp.
                 * @member {number} ServerIp
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.ServerIp = 0;

                /**
                 * Ptt ServerPort.
                 * @member {number} ServerPort
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.ServerPort = 0;

                /**
                 * Ptt BoolValid.
                 * @member {boolean} BoolValid
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.BoolValid = false;

                /**
                 * Ptt Signature.
                 * @member {Uint8Array} Signature
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.Signature = $util.newBuffer([]);

                /**
                 * Ptt Shortcut.
                 * @member {Uint8Array} Shortcut
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.Shortcut = $util.newBuffer([]);

                /**
                 * Ptt FileKey.
                 * @member {Uint8Array} FileKey
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.FileKey = $util.newBuffer([]);

                /**
                 * Ptt MagicPttIndex.
                 * @member {number} MagicPttIndex
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.MagicPttIndex = 0;

                /**
                 * Ptt VoiceSwitch.
                 * @member {number} VoiceSwitch
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.VoiceSwitch = 0;

                /**
                 * Ptt PttUrl.
                 * @member {Uint8Array} PttUrl
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.PttUrl = $util.newBuffer([]);

                /**
                 * Ptt GroupFileKey.
                 * @member {Uint8Array} GroupFileKey
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.GroupFileKey = $util.newBuffer([]);

                /**
                 * Ptt Time.
                 * @member {number} Time
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.Time = 0;

                /**
                 * Ptt DownPara.
                 * @member {Uint8Array} DownPara
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.DownPara = $util.newBuffer([]);

                /**
                 * Ptt Format.
                 * @member {number} Format
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.Format = 0;

                /**
                 * Ptt PbReserve.
                 * @member {Uint8Array} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.PbReserve = $util.newBuffer([]);

                /**
                 * Ptt BytesPttUrls.
                 * @member {Array.<Uint8Array>} BytesPttUrls
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.BytesPttUrls = $util.emptyArray;

                /**
                 * Ptt DownloadFlag.
                 * @member {number} DownloadFlag
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 */
                Ptt.prototype.DownloadFlag = 0;

                /**
                 * Creates a new Ptt instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPtt=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Ptt} Ptt instance
                 */
                Ptt.create = function create(properties) {
                    return new Ptt(properties);
                };

                /**
                 * Encodes the specified Ptt message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Ptt.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPtt} message Ptt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ptt.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FileType != null && Object.hasOwnProperty.call(message, "FileType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.FileType);
                    if (message.SrcUin != null && Object.hasOwnProperty.call(message, "SrcUin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.SrcUin);
                    if (message.FileUuid != null && Object.hasOwnProperty.call(message, "FileUuid"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.FileUuid);
                    if (message.FileMd5 != null && Object.hasOwnProperty.call(message, "FileMd5"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.FileMd5);
                    if (message.FileName != null && Object.hasOwnProperty.call(message, "FileName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.FileName);
                    if (message.FileSize != null && Object.hasOwnProperty.call(message, "FileSize"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.FileSize);
                    if (message.Reserve != null && Object.hasOwnProperty.call(message, "Reserve"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Reserve);
                    if (message.FileId != null && Object.hasOwnProperty.call(message, "FileId"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.FileId);
                    if (message.ServerIp != null && Object.hasOwnProperty.call(message, "ServerIp"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.ServerIp);
                    if (message.ServerPort != null && Object.hasOwnProperty.call(message, "ServerPort"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.ServerPort);
                    if (message.BoolValid != null && Object.hasOwnProperty.call(message, "BoolValid"))
                        writer.uint32(/* id 11, wireType 0 =*/88).bool(message.BoolValid);
                    if (message.Signature != null && Object.hasOwnProperty.call(message, "Signature"))
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.Signature);
                    if (message.Shortcut != null && Object.hasOwnProperty.call(message, "Shortcut"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.Shortcut);
                    if (message.FileKey != null && Object.hasOwnProperty.call(message, "FileKey"))
                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.FileKey);
                    if (message.MagicPttIndex != null && Object.hasOwnProperty.call(message, "MagicPttIndex"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.MagicPttIndex);
                    if (message.VoiceSwitch != null && Object.hasOwnProperty.call(message, "VoiceSwitch"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.VoiceSwitch);
                    if (message.PttUrl != null && Object.hasOwnProperty.call(message, "PttUrl"))
                        writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.PttUrl);
                    if (message.GroupFileKey != null && Object.hasOwnProperty.call(message, "GroupFileKey"))
                        writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.GroupFileKey);
                    if (message.Time != null && Object.hasOwnProperty.call(message, "Time"))
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.Time);
                    if (message.DownPara != null && Object.hasOwnProperty.call(message, "DownPara"))
                        writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.DownPara);
                    if (message.Format != null && Object.hasOwnProperty.call(message, "Format"))
                        writer.uint32(/* id 29, wireType 0 =*/232).int32(message.Format);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 30, wireType 2 =*/242).bytes(message.PbReserve);
                    if (message.BytesPttUrls != null && message.BytesPttUrls.length)
                        for (var i = 0; i < message.BytesPttUrls.length; ++i)
                            writer.uint32(/* id 31, wireType 2 =*/250).bytes(message.BytesPttUrls[i]);
                    if (message.DownloadFlag != null && Object.hasOwnProperty.call(message, "DownloadFlag"))
                        writer.uint32(/* id 32, wireType 0 =*/256).int32(message.DownloadFlag);
                    return writer;
                };

                /**
                 * Encodes the specified Ptt message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Ptt.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPtt} message Ptt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ptt.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Ptt message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Ptt} Ptt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ptt.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Ptt();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.FileType = reader.int32();
                            break;
                        case 2:
                            message.SrcUin = reader.int64();
                            break;
                        case 3:
                            message.FileUuid = reader.bytes();
                            break;
                        case 4:
                            message.FileMd5 = reader.bytes();
                            break;
                        case 5:
                            message.FileName = reader.bytes();
                            break;
                        case 6:
                            message.FileSize = reader.int32();
                            break;
                        case 7:
                            message.Reserve = reader.bytes();
                            break;
                        case 8:
                            message.FileId = reader.int32();
                            break;
                        case 9:
                            message.ServerIp = reader.int32();
                            break;
                        case 10:
                            message.ServerPort = reader.int32();
                            break;
                        case 11:
                            message.BoolValid = reader.bool();
                            break;
                        case 12:
                            message.Signature = reader.bytes();
                            break;
                        case 13:
                            message.Shortcut = reader.bytes();
                            break;
                        case 14:
                            message.FileKey = reader.bytes();
                            break;
                        case 15:
                            message.MagicPttIndex = reader.int32();
                            break;
                        case 16:
                            message.VoiceSwitch = reader.int32();
                            break;
                        case 17:
                            message.PttUrl = reader.bytes();
                            break;
                        case 18:
                            message.GroupFileKey = reader.bytes();
                            break;
                        case 19:
                            message.Time = reader.int32();
                            break;
                        case 20:
                            message.DownPara = reader.bytes();
                            break;
                        case 29:
                            message.Format = reader.int32();
                            break;
                        case 30:
                            message.PbReserve = reader.bytes();
                            break;
                        case 31:
                            if (!(message.BytesPttUrls && message.BytesPttUrls.length))
                                message.BytesPttUrls = [];
                            message.BytesPttUrls.push(reader.bytes());
                            break;
                        case 32:
                            message.DownloadFlag = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Ptt message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Ptt} Ptt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ptt.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Ptt message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ptt.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        if (!$util.isInteger(message.FileType))
                            return "FileType: integer expected";
                    if (message.SrcUin != null && message.hasOwnProperty("SrcUin"))
                        if (!$util.isInteger(message.SrcUin) && !(message.SrcUin && $util.isInteger(message.SrcUin.low) && $util.isInteger(message.SrcUin.high)))
                            return "SrcUin: integer|Long expected";
                    if (message.FileUuid != null && message.hasOwnProperty("FileUuid"))
                        if (!(message.FileUuid && typeof message.FileUuid.length === "number" || $util.isString(message.FileUuid)))
                            return "FileUuid: buffer expected";
                    if (message.FileMd5 != null && message.hasOwnProperty("FileMd5"))
                        if (!(message.FileMd5 && typeof message.FileMd5.length === "number" || $util.isString(message.FileMd5)))
                            return "FileMd5: buffer expected";
                    if (message.FileName != null && message.hasOwnProperty("FileName"))
                        if (!(message.FileName && typeof message.FileName.length === "number" || $util.isString(message.FileName)))
                            return "FileName: buffer expected";
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        if (!$util.isInteger(message.FileSize))
                            return "FileSize: integer expected";
                    if (message.Reserve != null && message.hasOwnProperty("Reserve"))
                        if (!(message.Reserve && typeof message.Reserve.length === "number" || $util.isString(message.Reserve)))
                            return "Reserve: buffer expected";
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        if (!$util.isInteger(message.FileId))
                            return "FileId: integer expected";
                    if (message.ServerIp != null && message.hasOwnProperty("ServerIp"))
                        if (!$util.isInteger(message.ServerIp))
                            return "ServerIp: integer expected";
                    if (message.ServerPort != null && message.hasOwnProperty("ServerPort"))
                        if (!$util.isInteger(message.ServerPort))
                            return "ServerPort: integer expected";
                    if (message.BoolValid != null && message.hasOwnProperty("BoolValid"))
                        if (typeof message.BoolValid !== "boolean")
                            return "BoolValid: boolean expected";
                    if (message.Signature != null && message.hasOwnProperty("Signature"))
                        if (!(message.Signature && typeof message.Signature.length === "number" || $util.isString(message.Signature)))
                            return "Signature: buffer expected";
                    if (message.Shortcut != null && message.hasOwnProperty("Shortcut"))
                        if (!(message.Shortcut && typeof message.Shortcut.length === "number" || $util.isString(message.Shortcut)))
                            return "Shortcut: buffer expected";
                    if (message.FileKey != null && message.hasOwnProperty("FileKey"))
                        if (!(message.FileKey && typeof message.FileKey.length === "number" || $util.isString(message.FileKey)))
                            return "FileKey: buffer expected";
                    if (message.MagicPttIndex != null && message.hasOwnProperty("MagicPttIndex"))
                        if (!$util.isInteger(message.MagicPttIndex))
                            return "MagicPttIndex: integer expected";
                    if (message.VoiceSwitch != null && message.hasOwnProperty("VoiceSwitch"))
                        if (!$util.isInteger(message.VoiceSwitch))
                            return "VoiceSwitch: integer expected";
                    if (message.PttUrl != null && message.hasOwnProperty("PttUrl"))
                        if (!(message.PttUrl && typeof message.PttUrl.length === "number" || $util.isString(message.PttUrl)))
                            return "PttUrl: buffer expected";
                    if (message.GroupFileKey != null && message.hasOwnProperty("GroupFileKey"))
                        if (!(message.GroupFileKey && typeof message.GroupFileKey.length === "number" || $util.isString(message.GroupFileKey)))
                            return "GroupFileKey: buffer expected";
                    if (message.Time != null && message.hasOwnProperty("Time"))
                        if (!$util.isInteger(message.Time))
                            return "Time: integer expected";
                    if (message.DownPara != null && message.hasOwnProperty("DownPara"))
                        if (!(message.DownPara && typeof message.DownPara.length === "number" || $util.isString(message.DownPara)))
                            return "DownPara: buffer expected";
                    if (message.Format != null && message.hasOwnProperty("Format"))
                        if (!$util.isInteger(message.Format))
                            return "Format: integer expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                            return "PbReserve: buffer expected";
                    if (message.BytesPttUrls != null && message.hasOwnProperty("BytesPttUrls")) {
                        if (!Array.isArray(message.BytesPttUrls))
                            return "BytesPttUrls: array expected";
                        for (var i = 0; i < message.BytesPttUrls.length; ++i)
                            if (!(message.BytesPttUrls[i] && typeof message.BytesPttUrls[i].length === "number" || $util.isString(message.BytesPttUrls[i])))
                                return "BytesPttUrls: buffer[] expected";
                    }
                    if (message.DownloadFlag != null && message.hasOwnProperty("DownloadFlag"))
                        if (!$util.isInteger(message.DownloadFlag))
                            return "DownloadFlag: integer expected";
                    return null;
                };

                /**
                 * Creates a Ptt message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Ptt} Ptt
                 */
                Ptt.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Ptt)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Ptt();
                    if (object.FileType != null)
                        message.FileType = object.FileType | 0;
                    if (object.SrcUin != null)
                        if ($util.Long)
                            (message.SrcUin = $util.Long.fromValue(object.SrcUin)).unsigned = false;
                        else if (typeof object.SrcUin === "string")
                            message.SrcUin = parseInt(object.SrcUin, 10);
                        else if (typeof object.SrcUin === "number")
                            message.SrcUin = object.SrcUin;
                        else if (typeof object.SrcUin === "object")
                            message.SrcUin = new $util.LongBits(object.SrcUin.low >>> 0, object.SrcUin.high >>> 0).toNumber();
                    if (object.FileUuid != null)
                        if (typeof object.FileUuid === "string")
                            $util.base64.decode(object.FileUuid, message.FileUuid = $util.newBuffer($util.base64.length(object.FileUuid)), 0);
                        else if (object.FileUuid.length)
                            message.FileUuid = object.FileUuid;
                    if (object.FileMd5 != null)
                        if (typeof object.FileMd5 === "string")
                            $util.base64.decode(object.FileMd5, message.FileMd5 = $util.newBuffer($util.base64.length(object.FileMd5)), 0);
                        else if (object.FileMd5.length)
                            message.FileMd5 = object.FileMd5;
                    if (object.FileName != null)
                        if (typeof object.FileName === "string")
                            $util.base64.decode(object.FileName, message.FileName = $util.newBuffer($util.base64.length(object.FileName)), 0);
                        else if (object.FileName.length)
                            message.FileName = object.FileName;
                    if (object.FileSize != null)
                        message.FileSize = object.FileSize | 0;
                    if (object.Reserve != null)
                        if (typeof object.Reserve === "string")
                            $util.base64.decode(object.Reserve, message.Reserve = $util.newBuffer($util.base64.length(object.Reserve)), 0);
                        else if (object.Reserve.length)
                            message.Reserve = object.Reserve;
                    if (object.FileId != null)
                        message.FileId = object.FileId | 0;
                    if (object.ServerIp != null)
                        message.ServerIp = object.ServerIp | 0;
                    if (object.ServerPort != null)
                        message.ServerPort = object.ServerPort | 0;
                    if (object.BoolValid != null)
                        message.BoolValid = Boolean(object.BoolValid);
                    if (object.Signature != null)
                        if (typeof object.Signature === "string")
                            $util.base64.decode(object.Signature, message.Signature = $util.newBuffer($util.base64.length(object.Signature)), 0);
                        else if (object.Signature.length)
                            message.Signature = object.Signature;
                    if (object.Shortcut != null)
                        if (typeof object.Shortcut === "string")
                            $util.base64.decode(object.Shortcut, message.Shortcut = $util.newBuffer($util.base64.length(object.Shortcut)), 0);
                        else if (object.Shortcut.length)
                            message.Shortcut = object.Shortcut;
                    if (object.FileKey != null)
                        if (typeof object.FileKey === "string")
                            $util.base64.decode(object.FileKey, message.FileKey = $util.newBuffer($util.base64.length(object.FileKey)), 0);
                        else if (object.FileKey.length)
                            message.FileKey = object.FileKey;
                    if (object.MagicPttIndex != null)
                        message.MagicPttIndex = object.MagicPttIndex | 0;
                    if (object.VoiceSwitch != null)
                        message.VoiceSwitch = object.VoiceSwitch | 0;
                    if (object.PttUrl != null)
                        if (typeof object.PttUrl === "string")
                            $util.base64.decode(object.PttUrl, message.PttUrl = $util.newBuffer($util.base64.length(object.PttUrl)), 0);
                        else if (object.PttUrl.length)
                            message.PttUrl = object.PttUrl;
                    if (object.GroupFileKey != null)
                        if (typeof object.GroupFileKey === "string")
                            $util.base64.decode(object.GroupFileKey, message.GroupFileKey = $util.newBuffer($util.base64.length(object.GroupFileKey)), 0);
                        else if (object.GroupFileKey.length)
                            message.GroupFileKey = object.GroupFileKey;
                    if (object.Time != null)
                        message.Time = object.Time | 0;
                    if (object.DownPara != null)
                        if (typeof object.DownPara === "string")
                            $util.base64.decode(object.DownPara, message.DownPara = $util.newBuffer($util.base64.length(object.DownPara)), 0);
                        else if (object.DownPara.length)
                            message.DownPara = object.DownPara;
                    if (object.Format != null)
                        message.Format = object.Format | 0;
                    if (object.PbReserve != null)
                        if (typeof object.PbReserve === "string")
                            $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                        else if (object.PbReserve.length)
                            message.PbReserve = object.PbReserve;
                    if (object.BytesPttUrls) {
                        if (!Array.isArray(object.BytesPttUrls))
                            throw TypeError(".Msg.MsgField.ImMsgBody.Ptt.BytesPttUrls: array expected");
                        message.BytesPttUrls = [];
                        for (var i = 0; i < object.BytesPttUrls.length; ++i)
                            if (typeof object.BytesPttUrls[i] === "string")
                                $util.base64.decode(object.BytesPttUrls[i], message.BytesPttUrls[i] = $util.newBuffer($util.base64.length(object.BytesPttUrls[i])), 0);
                            else if (object.BytesPttUrls[i].length)
                                message.BytesPttUrls[i] = object.BytesPttUrls[i];
                    }
                    if (object.DownloadFlag != null)
                        message.DownloadFlag = object.DownloadFlag | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Ptt message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Ptt} message Ptt
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ptt.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.BytesPttUrls = [];
                    if (options.defaults) {
                        object.FileType = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.SrcUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.SrcUin = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.FileUuid = "";
                        else {
                            object.FileUuid = [];
                            if (options.bytes !== Array)
                                object.FileUuid = $util.newBuffer(object.FileUuid);
                        }
                        if (options.bytes === String)
                            object.FileMd5 = "";
                        else {
                            object.FileMd5 = [];
                            if (options.bytes !== Array)
                                object.FileMd5 = $util.newBuffer(object.FileMd5);
                        }
                        if (options.bytes === String)
                            object.FileName = "";
                        else {
                            object.FileName = [];
                            if (options.bytes !== Array)
                                object.FileName = $util.newBuffer(object.FileName);
                        }
                        object.FileSize = 0;
                        if (options.bytes === String)
                            object.Reserve = "";
                        else {
                            object.Reserve = [];
                            if (options.bytes !== Array)
                                object.Reserve = $util.newBuffer(object.Reserve);
                        }
                        object.FileId = 0;
                        object.ServerIp = 0;
                        object.ServerPort = 0;
                        object.BoolValid = false;
                        if (options.bytes === String)
                            object.Signature = "";
                        else {
                            object.Signature = [];
                            if (options.bytes !== Array)
                                object.Signature = $util.newBuffer(object.Signature);
                        }
                        if (options.bytes === String)
                            object.Shortcut = "";
                        else {
                            object.Shortcut = [];
                            if (options.bytes !== Array)
                                object.Shortcut = $util.newBuffer(object.Shortcut);
                        }
                        if (options.bytes === String)
                            object.FileKey = "";
                        else {
                            object.FileKey = [];
                            if (options.bytes !== Array)
                                object.FileKey = $util.newBuffer(object.FileKey);
                        }
                        object.MagicPttIndex = 0;
                        object.VoiceSwitch = 0;
                        if (options.bytes === String)
                            object.PttUrl = "";
                        else {
                            object.PttUrl = [];
                            if (options.bytes !== Array)
                                object.PttUrl = $util.newBuffer(object.PttUrl);
                        }
                        if (options.bytes === String)
                            object.GroupFileKey = "";
                        else {
                            object.GroupFileKey = [];
                            if (options.bytes !== Array)
                                object.GroupFileKey = $util.newBuffer(object.GroupFileKey);
                        }
                        object.Time = 0;
                        if (options.bytes === String)
                            object.DownPara = "";
                        else {
                            object.DownPara = [];
                            if (options.bytes !== Array)
                                object.DownPara = $util.newBuffer(object.DownPara);
                        }
                        object.Format = 0;
                        if (options.bytes === String)
                            object.PbReserve = "";
                        else {
                            object.PbReserve = [];
                            if (options.bytes !== Array)
                                object.PbReserve = $util.newBuffer(object.PbReserve);
                        }
                        object.DownloadFlag = 0;
                    }
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        object.FileType = message.FileType;
                    if (message.SrcUin != null && message.hasOwnProperty("SrcUin"))
                        if (typeof message.SrcUin === "number")
                            object.SrcUin = options.longs === String ? String(message.SrcUin) : message.SrcUin;
                        else
                            object.SrcUin = options.longs === String ? $util.Long.prototype.toString.call(message.SrcUin) : options.longs === Number ? new $util.LongBits(message.SrcUin.low >>> 0, message.SrcUin.high >>> 0).toNumber() : message.SrcUin;
                    if (message.FileUuid != null && message.hasOwnProperty("FileUuid"))
                        object.FileUuid = options.bytes === String ? $util.base64.encode(message.FileUuid, 0, message.FileUuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileUuid) : message.FileUuid;
                    if (message.FileMd5 != null && message.hasOwnProperty("FileMd5"))
                        object.FileMd5 = options.bytes === String ? $util.base64.encode(message.FileMd5, 0, message.FileMd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileMd5) : message.FileMd5;
                    if (message.FileName != null && message.hasOwnProperty("FileName"))
                        object.FileName = options.bytes === String ? $util.base64.encode(message.FileName, 0, message.FileName.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileName) : message.FileName;
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        object.FileSize = message.FileSize;
                    if (message.Reserve != null && message.hasOwnProperty("Reserve"))
                        object.Reserve = options.bytes === String ? $util.base64.encode(message.Reserve, 0, message.Reserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Reserve) : message.Reserve;
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        object.FileId = message.FileId;
                    if (message.ServerIp != null && message.hasOwnProperty("ServerIp"))
                        object.ServerIp = message.ServerIp;
                    if (message.ServerPort != null && message.hasOwnProperty("ServerPort"))
                        object.ServerPort = message.ServerPort;
                    if (message.BoolValid != null && message.hasOwnProperty("BoolValid"))
                        object.BoolValid = message.BoolValid;
                    if (message.Signature != null && message.hasOwnProperty("Signature"))
                        object.Signature = options.bytes === String ? $util.base64.encode(message.Signature, 0, message.Signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.Signature) : message.Signature;
                    if (message.Shortcut != null && message.hasOwnProperty("Shortcut"))
                        object.Shortcut = options.bytes === String ? $util.base64.encode(message.Shortcut, 0, message.Shortcut.length) : options.bytes === Array ? Array.prototype.slice.call(message.Shortcut) : message.Shortcut;
                    if (message.FileKey != null && message.hasOwnProperty("FileKey"))
                        object.FileKey = options.bytes === String ? $util.base64.encode(message.FileKey, 0, message.FileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileKey) : message.FileKey;
                    if (message.MagicPttIndex != null && message.hasOwnProperty("MagicPttIndex"))
                        object.MagicPttIndex = message.MagicPttIndex;
                    if (message.VoiceSwitch != null && message.hasOwnProperty("VoiceSwitch"))
                        object.VoiceSwitch = message.VoiceSwitch;
                    if (message.PttUrl != null && message.hasOwnProperty("PttUrl"))
                        object.PttUrl = options.bytes === String ? $util.base64.encode(message.PttUrl, 0, message.PttUrl.length) : options.bytes === Array ? Array.prototype.slice.call(message.PttUrl) : message.PttUrl;
                    if (message.GroupFileKey != null && message.hasOwnProperty("GroupFileKey"))
                        object.GroupFileKey = options.bytes === String ? $util.base64.encode(message.GroupFileKey, 0, message.GroupFileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.GroupFileKey) : message.GroupFileKey;
                    if (message.Time != null && message.hasOwnProperty("Time"))
                        object.Time = message.Time;
                    if (message.DownPara != null && message.hasOwnProperty("DownPara"))
                        object.DownPara = options.bytes === String ? $util.base64.encode(message.DownPara, 0, message.DownPara.length) : options.bytes === Array ? Array.prototype.slice.call(message.DownPara) : message.DownPara;
                    if (message.Format != null && message.hasOwnProperty("Format"))
                        object.Format = message.Format;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                    if (message.BytesPttUrls && message.BytesPttUrls.length) {
                        object.BytesPttUrls = [];
                        for (var j = 0; j < message.BytesPttUrls.length; ++j)
                            object.BytesPttUrls[j] = options.bytes === String ? $util.base64.encode(message.BytesPttUrls[j], 0, message.BytesPttUrls[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.BytesPttUrls[j]) : message.BytesPttUrls[j];
                    }
                    if (message.DownloadFlag != null && message.hasOwnProperty("DownloadFlag"))
                        object.DownloadFlag = message.DownloadFlag;
                    return object;
                };

                /**
                 * Converts this Ptt to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Ptt
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ptt.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Ptt;
            })();

            ImMsgBody.TmpPtt = (function() {

                /**
                 * Properties of a TmpPtt.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ITmpPtt
                 * @property {number|null} [FileType] TmpPtt FileType
                 * @property {Uint8Array|null} [FileUuid] TmpPtt FileUuid
                 * @property {Uint8Array|null} [FileMd5] TmpPtt FileMd5
                 * @property {Uint8Array|null} [FileName] TmpPtt FileName
                 * @property {number|null} [FileSize] TmpPtt FileSize
                 * @property {number|null} [PttTimes] TmpPtt PttTimes
                 * @property {number|null} [UserType] TmpPtt UserType
                 * @property {number|null} [PtttransFlag] TmpPtt PtttransFlag
                 * @property {number|null} [BusiType] TmpPtt BusiType
                 * @property {number|Long|null} [MsgId] TmpPtt MsgId
                 * @property {Uint8Array|null} [PbReserve] TmpPtt PbReserve
                 * @property {Uint8Array|null} [PttEncodeData] TmpPtt PttEncodeData
                 */

                /**
                 * Constructs a new TmpPtt.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a TmpPtt.
                 * @implements ITmpPtt
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ITmpPtt=} [properties] Properties to set
                 */
                function TmpPtt(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TmpPtt FileType.
                 * @member {number} FileType
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.FileType = 0;

                /**
                 * TmpPtt FileUuid.
                 * @member {Uint8Array} FileUuid
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.FileUuid = $util.newBuffer([]);

                /**
                 * TmpPtt FileMd5.
                 * @member {Uint8Array} FileMd5
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.FileMd5 = $util.newBuffer([]);

                /**
                 * TmpPtt FileName.
                 * @member {Uint8Array} FileName
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.FileName = $util.newBuffer([]);

                /**
                 * TmpPtt FileSize.
                 * @member {number} FileSize
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.FileSize = 0;

                /**
                 * TmpPtt PttTimes.
                 * @member {number} PttTimes
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.PttTimes = 0;

                /**
                 * TmpPtt UserType.
                 * @member {number} UserType
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.UserType = 0;

                /**
                 * TmpPtt PtttransFlag.
                 * @member {number} PtttransFlag
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.PtttransFlag = 0;

                /**
                 * TmpPtt BusiType.
                 * @member {number} BusiType
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.BusiType = 0;

                /**
                 * TmpPtt MsgId.
                 * @member {number|Long} MsgId
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.MsgId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TmpPtt PbReserve.
                 * @member {Uint8Array} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.PbReserve = $util.newBuffer([]);

                /**
                 * TmpPtt PttEncodeData.
                 * @member {Uint8Array} PttEncodeData
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 */
                TmpPtt.prototype.PttEncodeData = $util.newBuffer([]);

                /**
                 * Creates a new TmpPtt instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITmpPtt=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.TmpPtt} TmpPtt instance
                 */
                TmpPtt.create = function create(properties) {
                    return new TmpPtt(properties);
                };

                /**
                 * Encodes the specified TmpPtt message. Does not implicitly {@link Msg.MsgField.ImMsgBody.TmpPtt.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITmpPtt} message TmpPtt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TmpPtt.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FileType != null && Object.hasOwnProperty.call(message, "FileType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.FileType);
                    if (message.FileUuid != null && Object.hasOwnProperty.call(message, "FileUuid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.FileUuid);
                    if (message.FileMd5 != null && Object.hasOwnProperty.call(message, "FileMd5"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.FileMd5);
                    if (message.FileName != null && Object.hasOwnProperty.call(message, "FileName"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.FileName);
                    if (message.FileSize != null && Object.hasOwnProperty.call(message, "FileSize"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.FileSize);
                    if (message.PttTimes != null && Object.hasOwnProperty.call(message, "PttTimes"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.PttTimes);
                    if (message.UserType != null && Object.hasOwnProperty.call(message, "UserType"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.UserType);
                    if (message.PtttransFlag != null && Object.hasOwnProperty.call(message, "PtttransFlag"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.PtttransFlag);
                    if (message.BusiType != null && Object.hasOwnProperty.call(message, "BusiType"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.BusiType);
                    if (message.MsgId != null && Object.hasOwnProperty.call(message, "MsgId"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int64(message.MsgId);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 30, wireType 2 =*/242).bytes(message.PbReserve);
                    if (message.PttEncodeData != null && Object.hasOwnProperty.call(message, "PttEncodeData"))
                        writer.uint32(/* id 31, wireType 2 =*/250).bytes(message.PttEncodeData);
                    return writer;
                };

                /**
                 * Encodes the specified TmpPtt message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.TmpPtt.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITmpPtt} message TmpPtt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TmpPtt.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TmpPtt message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.TmpPtt} TmpPtt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TmpPtt.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.TmpPtt();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.FileType = reader.int32();
                            break;
                        case 2:
                            message.FileUuid = reader.bytes();
                            break;
                        case 3:
                            message.FileMd5 = reader.bytes();
                            break;
                        case 4:
                            message.FileName = reader.bytes();
                            break;
                        case 5:
                            message.FileSize = reader.int32();
                            break;
                        case 6:
                            message.PttTimes = reader.int32();
                            break;
                        case 7:
                            message.UserType = reader.int32();
                            break;
                        case 8:
                            message.PtttransFlag = reader.int32();
                            break;
                        case 9:
                            message.BusiType = reader.int32();
                            break;
                        case 10:
                            message.MsgId = reader.int64();
                            break;
                        case 30:
                            message.PbReserve = reader.bytes();
                            break;
                        case 31:
                            message.PttEncodeData = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TmpPtt message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.TmpPtt} TmpPtt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TmpPtt.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TmpPtt message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TmpPtt.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        if (!$util.isInteger(message.FileType))
                            return "FileType: integer expected";
                    if (message.FileUuid != null && message.hasOwnProperty("FileUuid"))
                        if (!(message.FileUuid && typeof message.FileUuid.length === "number" || $util.isString(message.FileUuid)))
                            return "FileUuid: buffer expected";
                    if (message.FileMd5 != null && message.hasOwnProperty("FileMd5"))
                        if (!(message.FileMd5 && typeof message.FileMd5.length === "number" || $util.isString(message.FileMd5)))
                            return "FileMd5: buffer expected";
                    if (message.FileName != null && message.hasOwnProperty("FileName"))
                        if (!(message.FileName && typeof message.FileName.length === "number" || $util.isString(message.FileName)))
                            return "FileName: buffer expected";
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        if (!$util.isInteger(message.FileSize))
                            return "FileSize: integer expected";
                    if (message.PttTimes != null && message.hasOwnProperty("PttTimes"))
                        if (!$util.isInteger(message.PttTimes))
                            return "PttTimes: integer expected";
                    if (message.UserType != null && message.hasOwnProperty("UserType"))
                        if (!$util.isInteger(message.UserType))
                            return "UserType: integer expected";
                    if (message.PtttransFlag != null && message.hasOwnProperty("PtttransFlag"))
                        if (!$util.isInteger(message.PtttransFlag))
                            return "PtttransFlag: integer expected";
                    if (message.BusiType != null && message.hasOwnProperty("BusiType"))
                        if (!$util.isInteger(message.BusiType))
                            return "BusiType: integer expected";
                    if (message.MsgId != null && message.hasOwnProperty("MsgId"))
                        if (!$util.isInteger(message.MsgId) && !(message.MsgId && $util.isInteger(message.MsgId.low) && $util.isInteger(message.MsgId.high)))
                            return "MsgId: integer|Long expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                            return "PbReserve: buffer expected";
                    if (message.PttEncodeData != null && message.hasOwnProperty("PttEncodeData"))
                        if (!(message.PttEncodeData && typeof message.PttEncodeData.length === "number" || $util.isString(message.PttEncodeData)))
                            return "PttEncodeData: buffer expected";
                    return null;
                };

                /**
                 * Creates a TmpPtt message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.TmpPtt} TmpPtt
                 */
                TmpPtt.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.TmpPtt)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.TmpPtt();
                    if (object.FileType != null)
                        message.FileType = object.FileType | 0;
                    if (object.FileUuid != null)
                        if (typeof object.FileUuid === "string")
                            $util.base64.decode(object.FileUuid, message.FileUuid = $util.newBuffer($util.base64.length(object.FileUuid)), 0);
                        else if (object.FileUuid.length)
                            message.FileUuid = object.FileUuid;
                    if (object.FileMd5 != null)
                        if (typeof object.FileMd5 === "string")
                            $util.base64.decode(object.FileMd5, message.FileMd5 = $util.newBuffer($util.base64.length(object.FileMd5)), 0);
                        else if (object.FileMd5.length)
                            message.FileMd5 = object.FileMd5;
                    if (object.FileName != null)
                        if (typeof object.FileName === "string")
                            $util.base64.decode(object.FileName, message.FileName = $util.newBuffer($util.base64.length(object.FileName)), 0);
                        else if (object.FileName.length)
                            message.FileName = object.FileName;
                    if (object.FileSize != null)
                        message.FileSize = object.FileSize | 0;
                    if (object.PttTimes != null)
                        message.PttTimes = object.PttTimes | 0;
                    if (object.UserType != null)
                        message.UserType = object.UserType | 0;
                    if (object.PtttransFlag != null)
                        message.PtttransFlag = object.PtttransFlag | 0;
                    if (object.BusiType != null)
                        message.BusiType = object.BusiType | 0;
                    if (object.MsgId != null)
                        if ($util.Long)
                            (message.MsgId = $util.Long.fromValue(object.MsgId)).unsigned = false;
                        else if (typeof object.MsgId === "string")
                            message.MsgId = parseInt(object.MsgId, 10);
                        else if (typeof object.MsgId === "number")
                            message.MsgId = object.MsgId;
                        else if (typeof object.MsgId === "object")
                            message.MsgId = new $util.LongBits(object.MsgId.low >>> 0, object.MsgId.high >>> 0).toNumber();
                    if (object.PbReserve != null)
                        if (typeof object.PbReserve === "string")
                            $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                        else if (object.PbReserve.length)
                            message.PbReserve = object.PbReserve;
                    if (object.PttEncodeData != null)
                        if (typeof object.PttEncodeData === "string")
                            $util.base64.decode(object.PttEncodeData, message.PttEncodeData = $util.newBuffer($util.base64.length(object.PttEncodeData)), 0);
                        else if (object.PttEncodeData.length)
                            message.PttEncodeData = object.PttEncodeData;
                    return message;
                };

                /**
                 * Creates a plain object from a TmpPtt message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.TmpPtt} message TmpPtt
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TmpPtt.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.FileType = 0;
                        if (options.bytes === String)
                            object.FileUuid = "";
                        else {
                            object.FileUuid = [];
                            if (options.bytes !== Array)
                                object.FileUuid = $util.newBuffer(object.FileUuid);
                        }
                        if (options.bytes === String)
                            object.FileMd5 = "";
                        else {
                            object.FileMd5 = [];
                            if (options.bytes !== Array)
                                object.FileMd5 = $util.newBuffer(object.FileMd5);
                        }
                        if (options.bytes === String)
                            object.FileName = "";
                        else {
                            object.FileName = [];
                            if (options.bytes !== Array)
                                object.FileName = $util.newBuffer(object.FileName);
                        }
                        object.FileSize = 0;
                        object.PttTimes = 0;
                        object.UserType = 0;
                        object.PtttransFlag = 0;
                        object.BusiType = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.MsgId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.MsgId = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.PbReserve = "";
                        else {
                            object.PbReserve = [];
                            if (options.bytes !== Array)
                                object.PbReserve = $util.newBuffer(object.PbReserve);
                        }
                        if (options.bytes === String)
                            object.PttEncodeData = "";
                        else {
                            object.PttEncodeData = [];
                            if (options.bytes !== Array)
                                object.PttEncodeData = $util.newBuffer(object.PttEncodeData);
                        }
                    }
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        object.FileType = message.FileType;
                    if (message.FileUuid != null && message.hasOwnProperty("FileUuid"))
                        object.FileUuid = options.bytes === String ? $util.base64.encode(message.FileUuid, 0, message.FileUuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileUuid) : message.FileUuid;
                    if (message.FileMd5 != null && message.hasOwnProperty("FileMd5"))
                        object.FileMd5 = options.bytes === String ? $util.base64.encode(message.FileMd5, 0, message.FileMd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileMd5) : message.FileMd5;
                    if (message.FileName != null && message.hasOwnProperty("FileName"))
                        object.FileName = options.bytes === String ? $util.base64.encode(message.FileName, 0, message.FileName.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileName) : message.FileName;
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        object.FileSize = message.FileSize;
                    if (message.PttTimes != null && message.hasOwnProperty("PttTimes"))
                        object.PttTimes = message.PttTimes;
                    if (message.UserType != null && message.hasOwnProperty("UserType"))
                        object.UserType = message.UserType;
                    if (message.PtttransFlag != null && message.hasOwnProperty("PtttransFlag"))
                        object.PtttransFlag = message.PtttransFlag;
                    if (message.BusiType != null && message.hasOwnProperty("BusiType"))
                        object.BusiType = message.BusiType;
                    if (message.MsgId != null && message.hasOwnProperty("MsgId"))
                        if (typeof message.MsgId === "number")
                            object.MsgId = options.longs === String ? String(message.MsgId) : message.MsgId;
                        else
                            object.MsgId = options.longs === String ? $util.Long.prototype.toString.call(message.MsgId) : options.longs === Number ? new $util.LongBits(message.MsgId.low >>> 0, message.MsgId.high >>> 0).toNumber() : message.MsgId;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                    if (message.PttEncodeData != null && message.hasOwnProperty("PttEncodeData"))
                        object.PttEncodeData = options.bytes === String ? $util.base64.encode(message.PttEncodeData, 0, message.PttEncodeData.length) : options.bytes === Array ? Array.prototype.slice.call(message.PttEncodeData) : message.PttEncodeData;
                    return object;
                };

                /**
                 * Converts this TmpPtt to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.TmpPtt
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TmpPtt.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TmpPtt;
            })();

            ImMsgBody.Trans211TmpMsg = (function() {

                /**
                 * Properties of a Trans211TmpMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ITrans211TmpMsg
                 * @property {Uint8Array|null} [MsgBody] Trans211TmpMsg MsgBody
                 * @property {number|null} [C2cCmd] Trans211TmpMsg C2cCmd
                 */

                /**
                 * Constructs a new Trans211TmpMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a Trans211TmpMsg.
                 * @implements ITrans211TmpMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ITrans211TmpMsg=} [properties] Properties to set
                 */
                function Trans211TmpMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Trans211TmpMsg MsgBody.
                 * @member {Uint8Array} MsgBody
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @instance
                 */
                Trans211TmpMsg.prototype.MsgBody = $util.newBuffer([]);

                /**
                 * Trans211TmpMsg C2cCmd.
                 * @member {number} C2cCmd
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @instance
                 */
                Trans211TmpMsg.prototype.C2cCmd = 0;

                /**
                 * Creates a new Trans211TmpMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITrans211TmpMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Trans211TmpMsg} Trans211TmpMsg instance
                 */
                Trans211TmpMsg.create = function create(properties) {
                    return new Trans211TmpMsg(properties);
                };

                /**
                 * Encodes the specified Trans211TmpMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Trans211TmpMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITrans211TmpMsg} message Trans211TmpMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Trans211TmpMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MsgBody != null && Object.hasOwnProperty.call(message, "MsgBody"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.MsgBody);
                    if (message.C2cCmd != null && Object.hasOwnProperty.call(message, "C2cCmd"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.C2cCmd);
                    return writer;
                };

                /**
                 * Encodes the specified Trans211TmpMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Trans211TmpMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITrans211TmpMsg} message Trans211TmpMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Trans211TmpMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Trans211TmpMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Trans211TmpMsg} Trans211TmpMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Trans211TmpMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.MsgBody = reader.bytes();
                            break;
                        case 2:
                            message.C2cCmd = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Trans211TmpMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Trans211TmpMsg} Trans211TmpMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Trans211TmpMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Trans211TmpMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Trans211TmpMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MsgBody != null && message.hasOwnProperty("MsgBody"))
                        if (!(message.MsgBody && typeof message.MsgBody.length === "number" || $util.isString(message.MsgBody)))
                            return "MsgBody: buffer expected";
                    if (message.C2cCmd != null && message.hasOwnProperty("C2cCmd"))
                        if (!$util.isInteger(message.C2cCmd))
                            return "C2cCmd: integer expected";
                    return null;
                };

                /**
                 * Creates a Trans211TmpMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Trans211TmpMsg} Trans211TmpMsg
                 */
                Trans211TmpMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg();
                    if (object.MsgBody != null)
                        if (typeof object.MsgBody === "string")
                            $util.base64.decode(object.MsgBody, message.MsgBody = $util.newBuffer($util.base64.length(object.MsgBody)), 0);
                        else if (object.MsgBody.length)
                            message.MsgBody = object.MsgBody;
                    if (object.C2cCmd != null)
                        message.C2cCmd = object.C2cCmd | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Trans211TmpMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Trans211TmpMsg} message Trans211TmpMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Trans211TmpMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.MsgBody = "";
                        else {
                            object.MsgBody = [];
                            if (options.bytes !== Array)
                                object.MsgBody = $util.newBuffer(object.MsgBody);
                        }
                        object.C2cCmd = 0;
                    }
                    if (message.MsgBody != null && message.hasOwnProperty("MsgBody"))
                        object.MsgBody = options.bytes === String ? $util.base64.encode(message.MsgBody, 0, message.MsgBody.length) : options.bytes === Array ? Array.prototype.slice.call(message.MsgBody) : message.MsgBody;
                    if (message.C2cCmd != null && message.hasOwnProperty("C2cCmd"))
                        object.C2cCmd = message.C2cCmd;
                    return object;
                };

                /**
                 * Converts this Trans211TmpMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Trans211TmpMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Trans211TmpMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Trans211TmpMsg;
            })();

            ImMsgBody.Text = (function() {

                /**
                 * Properties of a Text.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IText
                 * @property {string|null} [Str] Text Str
                 * @property {string|null} [Link] Text Link
                 * @property {Uint8Array|null} [AttrBuff6] Text AttrBuff6
                 * @property {Uint8Array|null} [AttrBuff7] Text AttrBuff7
                 * @property {Uint8Array|null} [Buff] Text Buff
                 * @property {Uint8Array|null} [PbReserve] Text PbReserve
                 */

                /**
                 * Constructs a new Text.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a Text.
                 * @implements IText
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IText=} [properties] Properties to set
                 */
                function Text(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Text Str.
                 * @member {string} Str
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @instance
                 */
                Text.prototype.Str = "";

                /**
                 * Text Link.
                 * @member {string} Link
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @instance
                 */
                Text.prototype.Link = "";

                /**
                 * Text AttrBuff6.
                 * @member {Uint8Array} AttrBuff6
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @instance
                 */
                Text.prototype.AttrBuff6 = $util.newBuffer([]);

                /**
                 * Text AttrBuff7.
                 * @member {Uint8Array} AttrBuff7
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @instance
                 */
                Text.prototype.AttrBuff7 = $util.newBuffer([]);

                /**
                 * Text Buff.
                 * @member {Uint8Array} Buff
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @instance
                 */
                Text.prototype.Buff = $util.newBuffer([]);

                /**
                 * Text PbReserve.
                 * @member {Uint8Array} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @instance
                 */
                Text.prototype.PbReserve = $util.newBuffer([]);

                /**
                 * Creates a new Text instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IText=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Text} Text instance
                 */
                Text.create = function create(properties) {
                    return new Text(properties);
                };

                /**
                 * Encodes the specified Text message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Text.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IText} message Text message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Text.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Str != null && Object.hasOwnProperty.call(message, "Str"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.Str);
                    if (message.Link != null && Object.hasOwnProperty.call(message, "Link"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Link);
                    if (message.AttrBuff6 != null && Object.hasOwnProperty.call(message, "AttrBuff6"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.AttrBuff6);
                    if (message.AttrBuff7 != null && Object.hasOwnProperty.call(message, "AttrBuff7"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.AttrBuff7);
                    if (message.Buff != null && Object.hasOwnProperty.call(message, "Buff"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Buff);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.PbReserve);
                    return writer;
                };

                /**
                 * Encodes the specified Text message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Text.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IText} message Text message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Text.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Text message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Text} Text
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Text.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Text();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Str = reader.string();
                            break;
                        case 2:
                            message.Link = reader.string();
                            break;
                        case 3:
                            message.AttrBuff6 = reader.bytes();
                            break;
                        case 4:
                            message.AttrBuff7 = reader.bytes();
                            break;
                        case 5:
                            message.Buff = reader.bytes();
                            break;
                        case 6:
                            message.PbReserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Text message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Text} Text
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Text.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Text message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Text.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Str != null && message.hasOwnProperty("Str"))
                        if (!$util.isString(message.Str))
                            return "Str: string expected";
                    if (message.Link != null && message.hasOwnProperty("Link"))
                        if (!$util.isString(message.Link))
                            return "Link: string expected";
                    if (message.AttrBuff6 != null && message.hasOwnProperty("AttrBuff6"))
                        if (!(message.AttrBuff6 && typeof message.AttrBuff6.length === "number" || $util.isString(message.AttrBuff6)))
                            return "AttrBuff6: buffer expected";
                    if (message.AttrBuff7 != null && message.hasOwnProperty("AttrBuff7"))
                        if (!(message.AttrBuff7 && typeof message.AttrBuff7.length === "number" || $util.isString(message.AttrBuff7)))
                            return "AttrBuff7: buffer expected";
                    if (message.Buff != null && message.hasOwnProperty("Buff"))
                        if (!(message.Buff && typeof message.Buff.length === "number" || $util.isString(message.Buff)))
                            return "Buff: buffer expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                            return "PbReserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a Text message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Text} Text
                 */
                Text.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Text)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Text();
                    if (object.Str != null)
                        message.Str = String(object.Str);
                    if (object.Link != null)
                        message.Link = String(object.Link);
                    if (object.AttrBuff6 != null)
                        if (typeof object.AttrBuff6 === "string")
                            $util.base64.decode(object.AttrBuff6, message.AttrBuff6 = $util.newBuffer($util.base64.length(object.AttrBuff6)), 0);
                        else if (object.AttrBuff6.length)
                            message.AttrBuff6 = object.AttrBuff6;
                    if (object.AttrBuff7 != null)
                        if (typeof object.AttrBuff7 === "string")
                            $util.base64.decode(object.AttrBuff7, message.AttrBuff7 = $util.newBuffer($util.base64.length(object.AttrBuff7)), 0);
                        else if (object.AttrBuff7.length)
                            message.AttrBuff7 = object.AttrBuff7;
                    if (object.Buff != null)
                        if (typeof object.Buff === "string")
                            $util.base64.decode(object.Buff, message.Buff = $util.newBuffer($util.base64.length(object.Buff)), 0);
                        else if (object.Buff.length)
                            message.Buff = object.Buff;
                    if (object.PbReserve != null)
                        if (typeof object.PbReserve === "string")
                            $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                        else if (object.PbReserve.length)
                            message.PbReserve = object.PbReserve;
                    return message;
                };

                /**
                 * Creates a plain object from a Text message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Text} message Text
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Text.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Str = "";
                        object.Link = "";
                        if (options.bytes === String)
                            object.AttrBuff6 = "";
                        else {
                            object.AttrBuff6 = [];
                            if (options.bytes !== Array)
                                object.AttrBuff6 = $util.newBuffer(object.AttrBuff6);
                        }
                        if (options.bytes === String)
                            object.AttrBuff7 = "";
                        else {
                            object.AttrBuff7 = [];
                            if (options.bytes !== Array)
                                object.AttrBuff7 = $util.newBuffer(object.AttrBuff7);
                        }
                        if (options.bytes === String)
                            object.Buff = "";
                        else {
                            object.Buff = [];
                            if (options.bytes !== Array)
                                object.Buff = $util.newBuffer(object.Buff);
                        }
                        if (options.bytes === String)
                            object.PbReserve = "";
                        else {
                            object.PbReserve = [];
                            if (options.bytes !== Array)
                                object.PbReserve = $util.newBuffer(object.PbReserve);
                        }
                    }
                    if (message.Str != null && message.hasOwnProperty("Str"))
                        object.Str = message.Str;
                    if (message.Link != null && message.hasOwnProperty("Link"))
                        object.Link = message.Link;
                    if (message.AttrBuff6 != null && message.hasOwnProperty("AttrBuff6"))
                        object.AttrBuff6 = options.bytes === String ? $util.base64.encode(message.AttrBuff6, 0, message.AttrBuff6.length) : options.bytes === Array ? Array.prototype.slice.call(message.AttrBuff6) : message.AttrBuff6;
                    if (message.AttrBuff7 != null && message.hasOwnProperty("AttrBuff7"))
                        object.AttrBuff7 = options.bytes === String ? $util.base64.encode(message.AttrBuff7, 0, message.AttrBuff7.length) : options.bytes === Array ? Array.prototype.slice.call(message.AttrBuff7) : message.AttrBuff7;
                    if (message.Buff != null && message.hasOwnProperty("Buff"))
                        object.Buff = options.bytes === String ? $util.base64.encode(message.Buff, 0, message.Buff.length) : options.bytes === Array ? Array.prototype.slice.call(message.Buff) : message.Buff;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                    return object;
                };

                /**
                 * Converts this Text to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Text
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Text.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Text;
            })();

            ImMsgBody.Face = (function() {

                /**
                 * Properties of a Face.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IFace
                 * @property {number|null} [Index] Face Index
                 * @property {Uint8Array|null} [Old] Face Old
                 * @property {Uint8Array|null} [Buff] Face Buff
                 */

                /**
                 * Constructs a new Face.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a Face.
                 * @implements IFace
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IFace=} [properties] Properties to set
                 */
                function Face(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Face Index.
                 * @member {number} Index
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @instance
                 */
                Face.prototype.Index = 0;

                /**
                 * Face Old.
                 * @member {Uint8Array} Old
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @instance
                 */
                Face.prototype.Old = $util.newBuffer([]);

                /**
                 * Face Buff.
                 * @member {Uint8Array} Buff
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @instance
                 */
                Face.prototype.Buff = $util.newBuffer([]);

                /**
                 * Creates a new Face instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFace=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Face} Face instance
                 */
                Face.create = function create(properties) {
                    return new Face(properties);
                };

                /**
                 * Encodes the specified Face message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Face.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFace} message Face message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Face.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Index != null && Object.hasOwnProperty.call(message, "Index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Index);
                    if (message.Old != null && Object.hasOwnProperty.call(message, "Old"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Old);
                    if (message.Buff != null && Object.hasOwnProperty.call(message, "Buff"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Buff);
                    return writer;
                };

                /**
                 * Encodes the specified Face message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Face.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFace} message Face message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Face.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Face message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Face} Face
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Face.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Face();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Index = reader.int32();
                            break;
                        case 2:
                            message.Old = reader.bytes();
                            break;
                        case 3:
                            message.Buff = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Face message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Face} Face
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Face.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Face message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Face.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        if (!$util.isInteger(message.Index))
                            return "Index: integer expected";
                    if (message.Old != null && message.hasOwnProperty("Old"))
                        if (!(message.Old && typeof message.Old.length === "number" || $util.isString(message.Old)))
                            return "Old: buffer expected";
                    if (message.Buff != null && message.hasOwnProperty("Buff"))
                        if (!(message.Buff && typeof message.Buff.length === "number" || $util.isString(message.Buff)))
                            return "Buff: buffer expected";
                    return null;
                };

                /**
                 * Creates a Face message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Face} Face
                 */
                Face.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Face)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Face();
                    if (object.Index != null)
                        message.Index = object.Index | 0;
                    if (object.Old != null)
                        if (typeof object.Old === "string")
                            $util.base64.decode(object.Old, message.Old = $util.newBuffer($util.base64.length(object.Old)), 0);
                        else if (object.Old.length)
                            message.Old = object.Old;
                    if (object.Buff != null)
                        if (typeof object.Buff === "string")
                            $util.base64.decode(object.Buff, message.Buff = $util.newBuffer($util.base64.length(object.Buff)), 0);
                        else if (object.Buff.length)
                            message.Buff = object.Buff;
                    return message;
                };

                /**
                 * Creates a plain object from a Face message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Face} message Face
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Face.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Index = 0;
                        if (options.bytes === String)
                            object.Old = "";
                        else {
                            object.Old = [];
                            if (options.bytes !== Array)
                                object.Old = $util.newBuffer(object.Old);
                        }
                        if (options.bytes === String)
                            object.Buff = "";
                        else {
                            object.Buff = [];
                            if (options.bytes !== Array)
                                object.Buff = $util.newBuffer(object.Buff);
                        }
                    }
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        object.Index = message.Index;
                    if (message.Old != null && message.hasOwnProperty("Old"))
                        object.Old = options.bytes === String ? $util.base64.encode(message.Old, 0, message.Old.length) : options.bytes === Array ? Array.prototype.slice.call(message.Old) : message.Old;
                    if (message.Buff != null && message.hasOwnProperty("Buff"))
                        object.Buff = options.bytes === String ? $util.base64.encode(message.Buff, 0, message.Buff.length) : options.bytes === Array ? Array.prototype.slice.call(message.Buff) : message.Buff;
                    return object;
                };

                /**
                 * Converts this Face to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Face
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Face.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Face;
            })();

            ImMsgBody.OnlineImage = (function() {

                /**
                 * Properties of an OnlineImage.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IOnlineImage
                 * @property {Uint8Array|null} [Guid] OnlineImage Guid
                 * @property {Uint8Array|null} [FilePath] OnlineImage FilePath
                 * @property {Uint8Array|null} [OldVerSendFile] OnlineImage OldVerSendFile
                 */

                /**
                 * Constructs a new OnlineImage.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an OnlineImage.
                 * @implements IOnlineImage
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IOnlineImage=} [properties] Properties to set
                 */
                function OnlineImage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OnlineImage Guid.
                 * @member {Uint8Array} Guid
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @instance
                 */
                OnlineImage.prototype.Guid = $util.newBuffer([]);

                /**
                 * OnlineImage FilePath.
                 * @member {Uint8Array} FilePath
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @instance
                 */
                OnlineImage.prototype.FilePath = $util.newBuffer([]);

                /**
                 * OnlineImage OldVerSendFile.
                 * @member {Uint8Array} OldVerSendFile
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @instance
                 */
                OnlineImage.prototype.OldVerSendFile = $util.newBuffer([]);

                /**
                 * Creates a new OnlineImage instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IOnlineImage=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.OnlineImage} OnlineImage instance
                 */
                OnlineImage.create = function create(properties) {
                    return new OnlineImage(properties);
                };

                /**
                 * Encodes the specified OnlineImage message. Does not implicitly {@link Msg.MsgField.ImMsgBody.OnlineImage.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IOnlineImage} message OnlineImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OnlineImage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Guid != null && Object.hasOwnProperty.call(message, "Guid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Guid);
                    if (message.FilePath != null && Object.hasOwnProperty.call(message, "FilePath"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.FilePath);
                    if (message.OldVerSendFile != null && Object.hasOwnProperty.call(message, "OldVerSendFile"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.OldVerSendFile);
                    return writer;
                };

                /**
                 * Encodes the specified OnlineImage message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.OnlineImage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IOnlineImage} message OnlineImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OnlineImage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OnlineImage message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.OnlineImage} OnlineImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OnlineImage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.OnlineImage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Guid = reader.bytes();
                            break;
                        case 2:
                            message.FilePath = reader.bytes();
                            break;
                        case 3:
                            message.OldVerSendFile = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OnlineImage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.OnlineImage} OnlineImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OnlineImage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OnlineImage message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OnlineImage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Guid != null && message.hasOwnProperty("Guid"))
                        if (!(message.Guid && typeof message.Guid.length === "number" || $util.isString(message.Guid)))
                            return "Guid: buffer expected";
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        if (!(message.FilePath && typeof message.FilePath.length === "number" || $util.isString(message.FilePath)))
                            return "FilePath: buffer expected";
                    if (message.OldVerSendFile != null && message.hasOwnProperty("OldVerSendFile"))
                        if (!(message.OldVerSendFile && typeof message.OldVerSendFile.length === "number" || $util.isString(message.OldVerSendFile)))
                            return "OldVerSendFile: buffer expected";
                    return null;
                };

                /**
                 * Creates an OnlineImage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.OnlineImage} OnlineImage
                 */
                OnlineImage.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.OnlineImage)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.OnlineImage();
                    if (object.Guid != null)
                        if (typeof object.Guid === "string")
                            $util.base64.decode(object.Guid, message.Guid = $util.newBuffer($util.base64.length(object.Guid)), 0);
                        else if (object.Guid.length)
                            message.Guid = object.Guid;
                    if (object.FilePath != null)
                        if (typeof object.FilePath === "string")
                            $util.base64.decode(object.FilePath, message.FilePath = $util.newBuffer($util.base64.length(object.FilePath)), 0);
                        else if (object.FilePath.length)
                            message.FilePath = object.FilePath;
                    if (object.OldVerSendFile != null)
                        if (typeof object.OldVerSendFile === "string")
                            $util.base64.decode(object.OldVerSendFile, message.OldVerSendFile = $util.newBuffer($util.base64.length(object.OldVerSendFile)), 0);
                        else if (object.OldVerSendFile.length)
                            message.OldVerSendFile = object.OldVerSendFile;
                    return message;
                };

                /**
                 * Creates a plain object from an OnlineImage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.OnlineImage} message OnlineImage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OnlineImage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Guid = "";
                        else {
                            object.Guid = [];
                            if (options.bytes !== Array)
                                object.Guid = $util.newBuffer(object.Guid);
                        }
                        if (options.bytes === String)
                            object.FilePath = "";
                        else {
                            object.FilePath = [];
                            if (options.bytes !== Array)
                                object.FilePath = $util.newBuffer(object.FilePath);
                        }
                        if (options.bytes === String)
                            object.OldVerSendFile = "";
                        else {
                            object.OldVerSendFile = [];
                            if (options.bytes !== Array)
                                object.OldVerSendFile = $util.newBuffer(object.OldVerSendFile);
                        }
                    }
                    if (message.Guid != null && message.hasOwnProperty("Guid"))
                        object.Guid = options.bytes === String ? $util.base64.encode(message.Guid, 0, message.Guid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Guid) : message.Guid;
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        object.FilePath = options.bytes === String ? $util.base64.encode(message.FilePath, 0, message.FilePath.length) : options.bytes === Array ? Array.prototype.slice.call(message.FilePath) : message.FilePath;
                    if (message.OldVerSendFile != null && message.hasOwnProperty("OldVerSendFile"))
                        object.OldVerSendFile = options.bytes === String ? $util.base64.encode(message.OldVerSendFile, 0, message.OldVerSendFile.length) : options.bytes === Array ? Array.prototype.slice.call(message.OldVerSendFile) : message.OldVerSendFile;
                    return object;
                };

                /**
                 * Converts this OnlineImage to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.OnlineImage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OnlineImage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return OnlineImage;
            })();

            ImMsgBody.NotOnlineImage = (function() {

                /**
                 * Properties of a NotOnlineImage.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface INotOnlineImage
                 * @property {string|null} [FilePath] NotOnlineImage FilePath
                 * @property {number|null} [FileLen] NotOnlineImage FileLen
                 * @property {string|null} [DownloadPath] NotOnlineImage DownloadPath
                 * @property {Uint8Array|null} [OldVerSendFile] NotOnlineImage OldVerSendFile
                 * @property {number|null} [ImgType] NotOnlineImage ImgType
                 * @property {Uint8Array|null} [PreviewsImage] NotOnlineImage PreviewsImage
                 * @property {Uint8Array|null} [PicMd5] NotOnlineImage PicMd5
                 * @property {number|null} [PicHeight] NotOnlineImage PicHeight
                 * @property {number|null} [PicWidth] NotOnlineImage PicWidth
                 * @property {string|null} [ResId] NotOnlineImage ResId
                 * @property {Uint8Array|null} [Flag] NotOnlineImage Flag
                 * @property {string|null} [ThumbUrl] NotOnlineImage ThumbUrl
                 * @property {number|null} [Original] NotOnlineImage Original
                 * @property {string|null} [BigUrl] NotOnlineImage BigUrl
                 * @property {string|null} [OrigUrl] NotOnlineImage OrigUrl
                 * @property {number|null} [BizType] NotOnlineImage BizType
                 * @property {number|null} [Result] NotOnlineImage Result
                 * @property {number|null} [Index] NotOnlineImage Index
                 * @property {Uint8Array|null} [OpFaceBuf] NotOnlineImage OpFaceBuf
                 * @property {boolean|null} [OldPicMd5] NotOnlineImage OldPicMd5
                 * @property {number|null} [ThumbWidth] NotOnlineImage ThumbWidth
                 * @property {number|null} [ThumbHeight] NotOnlineImage ThumbHeight
                 * @property {number|null} [FileId] NotOnlineImage FileId
                 * @property {number|null} [ShowLen] NotOnlineImage ShowLen
                 * @property {number|null} [DownloadLen] NotOnlineImage DownloadLen
                 * @property {string|null} [Url] NotOnlineImage Url
                 * @property {string|null} [Width] NotOnlineImage Width
                 * @property {string|null} [Height] NotOnlineImage Height
                 * @property {boolean|null} [PbReserve] NotOnlineImage PbReserve
                 */

                /**
                 * Constructs a new NotOnlineImage.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a NotOnlineImage.
                 * @implements INotOnlineImage
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineImage=} [properties] Properties to set
                 */
                function NotOnlineImage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NotOnlineImage FilePath.
                 * @member {string} FilePath
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.FilePath = "";

                /**
                 * NotOnlineImage FileLen.
                 * @member {number} FileLen
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.FileLen = 0;

                /**
                 * NotOnlineImage DownloadPath.
                 * @member {string} DownloadPath
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.DownloadPath = "";

                /**
                 * NotOnlineImage OldVerSendFile.
                 * @member {Uint8Array} OldVerSendFile
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.OldVerSendFile = $util.newBuffer([]);

                /**
                 * NotOnlineImage ImgType.
                 * @member {number} ImgType
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.ImgType = 0;

                /**
                 * NotOnlineImage PreviewsImage.
                 * @member {Uint8Array} PreviewsImage
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.PreviewsImage = $util.newBuffer([]);

                /**
                 * NotOnlineImage PicMd5.
                 * @member {Uint8Array} PicMd5
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.PicMd5 = $util.newBuffer([]);

                /**
                 * NotOnlineImage PicHeight.
                 * @member {number} PicHeight
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.PicHeight = 0;

                /**
                 * NotOnlineImage PicWidth.
                 * @member {number} PicWidth
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.PicWidth = 0;

                /**
                 * NotOnlineImage ResId.
                 * @member {string} ResId
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.ResId = "";

                /**
                 * NotOnlineImage Flag.
                 * @member {Uint8Array} Flag
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Flag = $util.newBuffer([]);

                /**
                 * NotOnlineImage ThumbUrl.
                 * @member {string} ThumbUrl
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.ThumbUrl = "";

                /**
                 * NotOnlineImage Original.
                 * @member {number} Original
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Original = 0;

                /**
                 * NotOnlineImage BigUrl.
                 * @member {string} BigUrl
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.BigUrl = "";

                /**
                 * NotOnlineImage OrigUrl.
                 * @member {string} OrigUrl
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.OrigUrl = "";

                /**
                 * NotOnlineImage BizType.
                 * @member {number} BizType
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.BizType = 0;

                /**
                 * NotOnlineImage Result.
                 * @member {number} Result
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Result = 0;

                /**
                 * NotOnlineImage Index.
                 * @member {number} Index
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Index = 0;

                /**
                 * NotOnlineImage OpFaceBuf.
                 * @member {Uint8Array} OpFaceBuf
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.OpFaceBuf = $util.newBuffer([]);

                /**
                 * NotOnlineImage OldPicMd5.
                 * @member {boolean} OldPicMd5
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.OldPicMd5 = false;

                /**
                 * NotOnlineImage ThumbWidth.
                 * @member {number} ThumbWidth
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.ThumbWidth = 0;

                /**
                 * NotOnlineImage ThumbHeight.
                 * @member {number} ThumbHeight
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.ThumbHeight = 0;

                /**
                 * NotOnlineImage FileId.
                 * @member {number} FileId
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.FileId = 0;

                /**
                 * NotOnlineImage ShowLen.
                 * @member {number} ShowLen
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.ShowLen = 0;

                /**
                 * NotOnlineImage DownloadLen.
                 * @member {number} DownloadLen
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.DownloadLen = 0;

                /**
                 * NotOnlineImage Url.
                 * @member {string} Url
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Url = "";

                /**
                 * NotOnlineImage Width.
                 * @member {string} Width
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Width = "";

                /**
                 * NotOnlineImage Height.
                 * @member {string} Height
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Height = "";

                /**
                 * NotOnlineImage PbReserve.
                 * @member {boolean} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.PbReserve = false;

                /**
                 * Creates a new NotOnlineImage instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineImage=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineImage} NotOnlineImage instance
                 */
                NotOnlineImage.create = function create(properties) {
                    return new NotOnlineImage(properties);
                };

                /**
                 * Encodes the specified NotOnlineImage message. Does not implicitly {@link Msg.MsgField.ImMsgBody.NotOnlineImage.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineImage} message NotOnlineImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotOnlineImage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FilePath != null && Object.hasOwnProperty.call(message, "FilePath"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.FilePath);
                    if (message.FileLen != null && Object.hasOwnProperty.call(message, "FileLen"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.FileLen);
                    if (message.DownloadPath != null && Object.hasOwnProperty.call(message, "DownloadPath"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.DownloadPath);
                    if (message.OldVerSendFile != null && Object.hasOwnProperty.call(message, "OldVerSendFile"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.OldVerSendFile);
                    if (message.ImgType != null && Object.hasOwnProperty.call(message, "ImgType"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ImgType);
                    if (message.PreviewsImage != null && Object.hasOwnProperty.call(message, "PreviewsImage"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.PreviewsImage);
                    if (message.PicMd5 != null && Object.hasOwnProperty.call(message, "PicMd5"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.PicMd5);
                    if (message.PicHeight != null && Object.hasOwnProperty.call(message, "PicHeight"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.PicHeight);
                    if (message.PicWidth != null && Object.hasOwnProperty.call(message, "PicWidth"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.PicWidth);
                    if (message.ResId != null && Object.hasOwnProperty.call(message, "ResId"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.ResId);
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Flag);
                    if (message.ThumbUrl != null && Object.hasOwnProperty.call(message, "ThumbUrl"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.ThumbUrl);
                    if (message.Original != null && Object.hasOwnProperty.call(message, "Original"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.Original);
                    if (message.BigUrl != null && Object.hasOwnProperty.call(message, "BigUrl"))
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.BigUrl);
                    if (message.OrigUrl != null && Object.hasOwnProperty.call(message, "OrigUrl"))
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.OrigUrl);
                    if (message.BizType != null && Object.hasOwnProperty.call(message, "BizType"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.BizType);
                    if (message.Result != null && Object.hasOwnProperty.call(message, "Result"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.Result);
                    if (message.Index != null && Object.hasOwnProperty.call(message, "Index"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.Index);
                    if (message.OpFaceBuf != null && Object.hasOwnProperty.call(message, "OpFaceBuf"))
                        writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.OpFaceBuf);
                    if (message.OldPicMd5 != null && Object.hasOwnProperty.call(message, "OldPicMd5"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.OldPicMd5);
                    if (message.ThumbWidth != null && Object.hasOwnProperty.call(message, "ThumbWidth"))
                        writer.uint32(/* id 21, wireType 0 =*/168).int32(message.ThumbWidth);
                    if (message.ThumbHeight != null && Object.hasOwnProperty.call(message, "ThumbHeight"))
                        writer.uint32(/* id 22, wireType 0 =*/176).int32(message.ThumbHeight);
                    if (message.FileId != null && Object.hasOwnProperty.call(message, "FileId"))
                        writer.uint32(/* id 23, wireType 0 =*/184).int32(message.FileId);
                    if (message.ShowLen != null && Object.hasOwnProperty.call(message, "ShowLen"))
                        writer.uint32(/* id 24, wireType 0 =*/192).int32(message.ShowLen);
                    if (message.DownloadLen != null && Object.hasOwnProperty.call(message, "DownloadLen"))
                        writer.uint32(/* id 25, wireType 0 =*/200).int32(message.DownloadLen);
                    if (message.Url != null && Object.hasOwnProperty.call(message, "Url"))
                        writer.uint32(/* id 26, wireType 2 =*/210).string(message.Url);
                    if (message.Width != null && Object.hasOwnProperty.call(message, "Width"))
                        writer.uint32(/* id 27, wireType 2 =*/218).string(message.Width);
                    if (message.Height != null && Object.hasOwnProperty.call(message, "Height"))
                        writer.uint32(/* id 28, wireType 2 =*/226).string(message.Height);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 29, wireType 0 =*/232).bool(message.PbReserve);
                    return writer;
                };

                /**
                 * Encodes the specified NotOnlineImage message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.NotOnlineImage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INotOnlineImage} message NotOnlineImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotOnlineImage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NotOnlineImage message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineImage} NotOnlineImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotOnlineImage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.NotOnlineImage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.FilePath = reader.string();
                            break;
                        case 2:
                            message.FileLen = reader.int32();
                            break;
                        case 3:
                            message.DownloadPath = reader.string();
                            break;
                        case 4:
                            message.OldVerSendFile = reader.bytes();
                            break;
                        case 5:
                            message.ImgType = reader.int32();
                            break;
                        case 6:
                            message.PreviewsImage = reader.bytes();
                            break;
                        case 7:
                            message.PicMd5 = reader.bytes();
                            break;
                        case 8:
                            message.PicHeight = reader.int32();
                            break;
                        case 9:
                            message.PicWidth = reader.int32();
                            break;
                        case 10:
                            message.ResId = reader.string();
                            break;
                        case 11:
                            message.Flag = reader.bytes();
                            break;
                        case 12:
                            message.ThumbUrl = reader.string();
                            break;
                        case 13:
                            message.Original = reader.int32();
                            break;
                        case 14:
                            message.BigUrl = reader.string();
                            break;
                        case 15:
                            message.OrigUrl = reader.string();
                            break;
                        case 16:
                            message.BizType = reader.int32();
                            break;
                        case 17:
                            message.Result = reader.int32();
                            break;
                        case 18:
                            message.Index = reader.int32();
                            break;
                        case 19:
                            message.OpFaceBuf = reader.bytes();
                            break;
                        case 20:
                            message.OldPicMd5 = reader.bool();
                            break;
                        case 21:
                            message.ThumbWidth = reader.int32();
                            break;
                        case 22:
                            message.ThumbHeight = reader.int32();
                            break;
                        case 23:
                            message.FileId = reader.int32();
                            break;
                        case 24:
                            message.ShowLen = reader.int32();
                            break;
                        case 25:
                            message.DownloadLen = reader.int32();
                            break;
                        case 26:
                            message.Url = reader.string();
                            break;
                        case 27:
                            message.Width = reader.string();
                            break;
                        case 28:
                            message.Height = reader.string();
                            break;
                        case 29:
                            message.PbReserve = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NotOnlineImage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineImage} NotOnlineImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotOnlineImage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NotOnlineImage message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NotOnlineImage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        if (!$util.isString(message.FilePath))
                            return "FilePath: string expected";
                    if (message.FileLen != null && message.hasOwnProperty("FileLen"))
                        if (!$util.isInteger(message.FileLen))
                            return "FileLen: integer expected";
                    if (message.DownloadPath != null && message.hasOwnProperty("DownloadPath"))
                        if (!$util.isString(message.DownloadPath))
                            return "DownloadPath: string expected";
                    if (message.OldVerSendFile != null && message.hasOwnProperty("OldVerSendFile"))
                        if (!(message.OldVerSendFile && typeof message.OldVerSendFile.length === "number" || $util.isString(message.OldVerSendFile)))
                            return "OldVerSendFile: buffer expected";
                    if (message.ImgType != null && message.hasOwnProperty("ImgType"))
                        if (!$util.isInteger(message.ImgType))
                            return "ImgType: integer expected";
                    if (message.PreviewsImage != null && message.hasOwnProperty("PreviewsImage"))
                        if (!(message.PreviewsImage && typeof message.PreviewsImage.length === "number" || $util.isString(message.PreviewsImage)))
                            return "PreviewsImage: buffer expected";
                    if (message.PicMd5 != null && message.hasOwnProperty("PicMd5"))
                        if (!(message.PicMd5 && typeof message.PicMd5.length === "number" || $util.isString(message.PicMd5)))
                            return "PicMd5: buffer expected";
                    if (message.PicHeight != null && message.hasOwnProperty("PicHeight"))
                        if (!$util.isInteger(message.PicHeight))
                            return "PicHeight: integer expected";
                    if (message.PicWidth != null && message.hasOwnProperty("PicWidth"))
                        if (!$util.isInteger(message.PicWidth))
                            return "PicWidth: integer expected";
                    if (message.ResId != null && message.hasOwnProperty("ResId"))
                        if (!$util.isString(message.ResId))
                            return "ResId: string expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!(message.Flag && typeof message.Flag.length === "number" || $util.isString(message.Flag)))
                            return "Flag: buffer expected";
                    if (message.ThumbUrl != null && message.hasOwnProperty("ThumbUrl"))
                        if (!$util.isString(message.ThumbUrl))
                            return "ThumbUrl: string expected";
                    if (message.Original != null && message.hasOwnProperty("Original"))
                        if (!$util.isInteger(message.Original))
                            return "Original: integer expected";
                    if (message.BigUrl != null && message.hasOwnProperty("BigUrl"))
                        if (!$util.isString(message.BigUrl))
                            return "BigUrl: string expected";
                    if (message.OrigUrl != null && message.hasOwnProperty("OrigUrl"))
                        if (!$util.isString(message.OrigUrl))
                            return "OrigUrl: string expected";
                    if (message.BizType != null && message.hasOwnProperty("BizType"))
                        if (!$util.isInteger(message.BizType))
                            return "BizType: integer expected";
                    if (message.Result != null && message.hasOwnProperty("Result"))
                        if (!$util.isInteger(message.Result))
                            return "Result: integer expected";
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        if (!$util.isInteger(message.Index))
                            return "Index: integer expected";
                    if (message.OpFaceBuf != null && message.hasOwnProperty("OpFaceBuf"))
                        if (!(message.OpFaceBuf && typeof message.OpFaceBuf.length === "number" || $util.isString(message.OpFaceBuf)))
                            return "OpFaceBuf: buffer expected";
                    if (message.OldPicMd5 != null && message.hasOwnProperty("OldPicMd5"))
                        if (typeof message.OldPicMd5 !== "boolean")
                            return "OldPicMd5: boolean expected";
                    if (message.ThumbWidth != null && message.hasOwnProperty("ThumbWidth"))
                        if (!$util.isInteger(message.ThumbWidth))
                            return "ThumbWidth: integer expected";
                    if (message.ThumbHeight != null && message.hasOwnProperty("ThumbHeight"))
                        if (!$util.isInteger(message.ThumbHeight))
                            return "ThumbHeight: integer expected";
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        if (!$util.isInteger(message.FileId))
                            return "FileId: integer expected";
                    if (message.ShowLen != null && message.hasOwnProperty("ShowLen"))
                        if (!$util.isInteger(message.ShowLen))
                            return "ShowLen: integer expected";
                    if (message.DownloadLen != null && message.hasOwnProperty("DownloadLen"))
                        if (!$util.isInteger(message.DownloadLen))
                            return "DownloadLen: integer expected";
                    if (message.Url != null && message.hasOwnProperty("Url"))
                        if (!$util.isString(message.Url))
                            return "Url: string expected";
                    if (message.Width != null && message.hasOwnProperty("Width"))
                        if (!$util.isString(message.Width))
                            return "Width: string expected";
                    if (message.Height != null && message.hasOwnProperty("Height"))
                        if (!$util.isString(message.Height))
                            return "Height: string expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (typeof message.PbReserve !== "boolean")
                            return "PbReserve: boolean expected";
                    return null;
                };

                /**
                 * Creates a NotOnlineImage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.NotOnlineImage} NotOnlineImage
                 */
                NotOnlineImage.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.NotOnlineImage)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.NotOnlineImage();
                    if (object.FilePath != null)
                        message.FilePath = String(object.FilePath);
                    if (object.FileLen != null)
                        message.FileLen = object.FileLen | 0;
                    if (object.DownloadPath != null)
                        message.DownloadPath = String(object.DownloadPath);
                    if (object.OldVerSendFile != null)
                        if (typeof object.OldVerSendFile === "string")
                            $util.base64.decode(object.OldVerSendFile, message.OldVerSendFile = $util.newBuffer($util.base64.length(object.OldVerSendFile)), 0);
                        else if (object.OldVerSendFile.length)
                            message.OldVerSendFile = object.OldVerSendFile;
                    if (object.ImgType != null)
                        message.ImgType = object.ImgType | 0;
                    if (object.PreviewsImage != null)
                        if (typeof object.PreviewsImage === "string")
                            $util.base64.decode(object.PreviewsImage, message.PreviewsImage = $util.newBuffer($util.base64.length(object.PreviewsImage)), 0);
                        else if (object.PreviewsImage.length)
                            message.PreviewsImage = object.PreviewsImage;
                    if (object.PicMd5 != null)
                        if (typeof object.PicMd5 === "string")
                            $util.base64.decode(object.PicMd5, message.PicMd5 = $util.newBuffer($util.base64.length(object.PicMd5)), 0);
                        else if (object.PicMd5.length)
                            message.PicMd5 = object.PicMd5;
                    if (object.PicHeight != null)
                        message.PicHeight = object.PicHeight | 0;
                    if (object.PicWidth != null)
                        message.PicWidth = object.PicWidth | 0;
                    if (object.ResId != null)
                        message.ResId = String(object.ResId);
                    if (object.Flag != null)
                        if (typeof object.Flag === "string")
                            $util.base64.decode(object.Flag, message.Flag = $util.newBuffer($util.base64.length(object.Flag)), 0);
                        else if (object.Flag.length)
                            message.Flag = object.Flag;
                    if (object.ThumbUrl != null)
                        message.ThumbUrl = String(object.ThumbUrl);
                    if (object.Original != null)
                        message.Original = object.Original | 0;
                    if (object.BigUrl != null)
                        message.BigUrl = String(object.BigUrl);
                    if (object.OrigUrl != null)
                        message.OrigUrl = String(object.OrigUrl);
                    if (object.BizType != null)
                        message.BizType = object.BizType | 0;
                    if (object.Result != null)
                        message.Result = object.Result | 0;
                    if (object.Index != null)
                        message.Index = object.Index | 0;
                    if (object.OpFaceBuf != null)
                        if (typeof object.OpFaceBuf === "string")
                            $util.base64.decode(object.OpFaceBuf, message.OpFaceBuf = $util.newBuffer($util.base64.length(object.OpFaceBuf)), 0);
                        else if (object.OpFaceBuf.length)
                            message.OpFaceBuf = object.OpFaceBuf;
                    if (object.OldPicMd5 != null)
                        message.OldPicMd5 = Boolean(object.OldPicMd5);
                    if (object.ThumbWidth != null)
                        message.ThumbWidth = object.ThumbWidth | 0;
                    if (object.ThumbHeight != null)
                        message.ThumbHeight = object.ThumbHeight | 0;
                    if (object.FileId != null)
                        message.FileId = object.FileId | 0;
                    if (object.ShowLen != null)
                        message.ShowLen = object.ShowLen | 0;
                    if (object.DownloadLen != null)
                        message.DownloadLen = object.DownloadLen | 0;
                    if (object.Url != null)
                        message.Url = String(object.Url);
                    if (object.Width != null)
                        message.Width = String(object.Width);
                    if (object.Height != null)
                        message.Height = String(object.Height);
                    if (object.PbReserve != null)
                        message.PbReserve = Boolean(object.PbReserve);
                    return message;
                };

                /**
                 * Creates a plain object from a NotOnlineImage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.NotOnlineImage} message NotOnlineImage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NotOnlineImage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.FilePath = "";
                        object.FileLen = 0;
                        object.DownloadPath = "";
                        if (options.bytes === String)
                            object.OldVerSendFile = "";
                        else {
                            object.OldVerSendFile = [];
                            if (options.bytes !== Array)
                                object.OldVerSendFile = $util.newBuffer(object.OldVerSendFile);
                        }
                        object.ImgType = 0;
                        if (options.bytes === String)
                            object.PreviewsImage = "";
                        else {
                            object.PreviewsImage = [];
                            if (options.bytes !== Array)
                                object.PreviewsImage = $util.newBuffer(object.PreviewsImage);
                        }
                        if (options.bytes === String)
                            object.PicMd5 = "";
                        else {
                            object.PicMd5 = [];
                            if (options.bytes !== Array)
                                object.PicMd5 = $util.newBuffer(object.PicMd5);
                        }
                        object.PicHeight = 0;
                        object.PicWidth = 0;
                        object.ResId = "";
                        if (options.bytes === String)
                            object.Flag = "";
                        else {
                            object.Flag = [];
                            if (options.bytes !== Array)
                                object.Flag = $util.newBuffer(object.Flag);
                        }
                        object.ThumbUrl = "";
                        object.Original = 0;
                        object.BigUrl = "";
                        object.OrigUrl = "";
                        object.BizType = 0;
                        object.Result = 0;
                        object.Index = 0;
                        if (options.bytes === String)
                            object.OpFaceBuf = "";
                        else {
                            object.OpFaceBuf = [];
                            if (options.bytes !== Array)
                                object.OpFaceBuf = $util.newBuffer(object.OpFaceBuf);
                        }
                        object.OldPicMd5 = false;
                        object.ThumbWidth = 0;
                        object.ThumbHeight = 0;
                        object.FileId = 0;
                        object.ShowLen = 0;
                        object.DownloadLen = 0;
                        object.Url = "";
                        object.Width = "";
                        object.Height = "";
                        object.PbReserve = false;
                    }
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        object.FilePath = message.FilePath;
                    if (message.FileLen != null && message.hasOwnProperty("FileLen"))
                        object.FileLen = message.FileLen;
                    if (message.DownloadPath != null && message.hasOwnProperty("DownloadPath"))
                        object.DownloadPath = message.DownloadPath;
                    if (message.OldVerSendFile != null && message.hasOwnProperty("OldVerSendFile"))
                        object.OldVerSendFile = options.bytes === String ? $util.base64.encode(message.OldVerSendFile, 0, message.OldVerSendFile.length) : options.bytes === Array ? Array.prototype.slice.call(message.OldVerSendFile) : message.OldVerSendFile;
                    if (message.ImgType != null && message.hasOwnProperty("ImgType"))
                        object.ImgType = message.ImgType;
                    if (message.PreviewsImage != null && message.hasOwnProperty("PreviewsImage"))
                        object.PreviewsImage = options.bytes === String ? $util.base64.encode(message.PreviewsImage, 0, message.PreviewsImage.length) : options.bytes === Array ? Array.prototype.slice.call(message.PreviewsImage) : message.PreviewsImage;
                    if (message.PicMd5 != null && message.hasOwnProperty("PicMd5"))
                        object.PicMd5 = options.bytes === String ? $util.base64.encode(message.PicMd5, 0, message.PicMd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.PicMd5) : message.PicMd5;
                    if (message.PicHeight != null && message.hasOwnProperty("PicHeight"))
                        object.PicHeight = message.PicHeight;
                    if (message.PicWidth != null && message.hasOwnProperty("PicWidth"))
                        object.PicWidth = message.PicWidth;
                    if (message.ResId != null && message.hasOwnProperty("ResId"))
                        object.ResId = message.ResId;
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = options.bytes === String ? $util.base64.encode(message.Flag, 0, message.Flag.length) : options.bytes === Array ? Array.prototype.slice.call(message.Flag) : message.Flag;
                    if (message.ThumbUrl != null && message.hasOwnProperty("ThumbUrl"))
                        object.ThumbUrl = message.ThumbUrl;
                    if (message.Original != null && message.hasOwnProperty("Original"))
                        object.Original = message.Original;
                    if (message.BigUrl != null && message.hasOwnProperty("BigUrl"))
                        object.BigUrl = message.BigUrl;
                    if (message.OrigUrl != null && message.hasOwnProperty("OrigUrl"))
                        object.OrigUrl = message.OrigUrl;
                    if (message.BizType != null && message.hasOwnProperty("BizType"))
                        object.BizType = message.BizType;
                    if (message.Result != null && message.hasOwnProperty("Result"))
                        object.Result = message.Result;
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        object.Index = message.Index;
                    if (message.OpFaceBuf != null && message.hasOwnProperty("OpFaceBuf"))
                        object.OpFaceBuf = options.bytes === String ? $util.base64.encode(message.OpFaceBuf, 0, message.OpFaceBuf.length) : options.bytes === Array ? Array.prototype.slice.call(message.OpFaceBuf) : message.OpFaceBuf;
                    if (message.OldPicMd5 != null && message.hasOwnProperty("OldPicMd5"))
                        object.OldPicMd5 = message.OldPicMd5;
                    if (message.ThumbWidth != null && message.hasOwnProperty("ThumbWidth"))
                        object.ThumbWidth = message.ThumbWidth;
                    if (message.ThumbHeight != null && message.hasOwnProperty("ThumbHeight"))
                        object.ThumbHeight = message.ThumbHeight;
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        object.FileId = message.FileId;
                    if (message.ShowLen != null && message.hasOwnProperty("ShowLen"))
                        object.ShowLen = message.ShowLen;
                    if (message.DownloadLen != null && message.hasOwnProperty("DownloadLen"))
                        object.DownloadLen = message.DownloadLen;
                    if (message.Url != null && message.hasOwnProperty("Url"))
                        object.Url = message.Url;
                    if (message.Width != null && message.hasOwnProperty("Width"))
                        object.Width = message.Width;
                    if (message.Height != null && message.hasOwnProperty("Height"))
                        object.Height = message.Height;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = message.PbReserve;
                    return object;
                };

                /**
                 * Converts this NotOnlineImage to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.NotOnlineImage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NotOnlineImage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NotOnlineImage;
            })();

            ImMsgBody.TransElemInfo = (function() {

                /**
                 * Properties of a TransElemInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ITransElemInfo
                 * @property {number|null} [ElemType] TransElemInfo ElemType
                 * @property {Uint8Array|null} [ElemValue] TransElemInfo ElemValue
                 */

                /**
                 * Constructs a new TransElemInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a TransElemInfo.
                 * @implements ITransElemInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ITransElemInfo=} [properties] Properties to set
                 */
                function TransElemInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransElemInfo ElemType.
                 * @member {number} ElemType
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @instance
                 */
                TransElemInfo.prototype.ElemType = 0;

                /**
                 * TransElemInfo ElemValue.
                 * @member {Uint8Array} ElemValue
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @instance
                 */
                TransElemInfo.prototype.ElemValue = $util.newBuffer([]);

                /**
                 * Creates a new TransElemInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITransElemInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.TransElemInfo} TransElemInfo instance
                 */
                TransElemInfo.create = function create(properties) {
                    return new TransElemInfo(properties);
                };

                /**
                 * Encodes the specified TransElemInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.TransElemInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITransElemInfo} message TransElemInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransElemInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ElemType != null && Object.hasOwnProperty.call(message, "ElemType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ElemType);
                    if (message.ElemValue != null && Object.hasOwnProperty.call(message, "ElemValue"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ElemValue);
                    return writer;
                };

                /**
                 * Encodes the specified TransElemInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.TransElemInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITransElemInfo} message TransElemInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransElemInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransElemInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.TransElemInfo} TransElemInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransElemInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.TransElemInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ElemType = reader.int32();
                            break;
                        case 2:
                            message.ElemValue = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransElemInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.TransElemInfo} TransElemInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransElemInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransElemInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransElemInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ElemType != null && message.hasOwnProperty("ElemType"))
                        if (!$util.isInteger(message.ElemType))
                            return "ElemType: integer expected";
                    if (message.ElemValue != null && message.hasOwnProperty("ElemValue"))
                        if (!(message.ElemValue && typeof message.ElemValue.length === "number" || $util.isString(message.ElemValue)))
                            return "ElemValue: buffer expected";
                    return null;
                };

                /**
                 * Creates a TransElemInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.TransElemInfo} TransElemInfo
                 */
                TransElemInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.TransElemInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.TransElemInfo();
                    if (object.ElemType != null)
                        message.ElemType = object.ElemType | 0;
                    if (object.ElemValue != null)
                        if (typeof object.ElemValue === "string")
                            $util.base64.decode(object.ElemValue, message.ElemValue = $util.newBuffer($util.base64.length(object.ElemValue)), 0);
                        else if (object.ElemValue.length)
                            message.ElemValue = object.ElemValue;
                    return message;
                };

                /**
                 * Creates a plain object from a TransElemInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.TransElemInfo} message TransElemInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransElemInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ElemType = 0;
                        if (options.bytes === String)
                            object.ElemValue = "";
                        else {
                            object.ElemValue = [];
                            if (options.bytes !== Array)
                                object.ElemValue = $util.newBuffer(object.ElemValue);
                        }
                    }
                    if (message.ElemType != null && message.hasOwnProperty("ElemType"))
                        object.ElemType = message.ElemType;
                    if (message.ElemValue != null && message.hasOwnProperty("ElemValue"))
                        object.ElemValue = options.bytes === String ? $util.base64.encode(message.ElemValue, 0, message.ElemValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.ElemValue) : message.ElemValue;
                    return object;
                };

                /**
                 * Converts this TransElemInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.TransElemInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransElemInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TransElemInfo;
            })();

            ImMsgBody.MarketFace = (function() {

                /**
                 * Properties of a MarketFace.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IMarketFace
                 * @property {Uint8Array|null} [FaceName] MarketFace FaceName
                 * @property {number|null} [ItemType] MarketFace ItemType
                 * @property {number|null} [FaceInfo] MarketFace FaceInfo
                 * @property {Uint8Array|null} [FaceId] MarketFace FaceId
                 * @property {number|null} [TabId] MarketFace TabId
                 * @property {number|null} [SubType] MarketFace SubType
                 * @property {Uint8Array|null} [Key] MarketFace Key
                 * @property {Uint8Array|null} [Param] MarketFace Param
                 * @property {number|null} [MediaType] MarketFace MediaType
                 * @property {number|null} [ImageWidth] MarketFace ImageWidth
                 * @property {number|null} [ImageHeight] MarketFace ImageHeight
                 * @property {Uint8Array|null} [Mobileparam] MarketFace Mobileparam
                 * @property {Uint8Array|null} [PbReserve] MarketFace PbReserve
                 */

                /**
                 * Constructs a new MarketFace.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a MarketFace.
                 * @implements IMarketFace
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IMarketFace=} [properties] Properties to set
                 */
                function MarketFace(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MarketFace FaceName.
                 * @member {Uint8Array} FaceName
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.FaceName = $util.newBuffer([]);

                /**
                 * MarketFace ItemType.
                 * @member {number} ItemType
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.ItemType = 0;

                /**
                 * MarketFace FaceInfo.
                 * @member {number} FaceInfo
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.FaceInfo = 0;

                /**
                 * MarketFace FaceId.
                 * @member {Uint8Array} FaceId
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.FaceId = $util.newBuffer([]);

                /**
                 * MarketFace TabId.
                 * @member {number} TabId
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.TabId = 0;

                /**
                 * MarketFace SubType.
                 * @member {number} SubType
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.SubType = 0;

                /**
                 * MarketFace Key.
                 * @member {Uint8Array} Key
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.Key = $util.newBuffer([]);

                /**
                 * MarketFace Param.
                 * @member {Uint8Array} Param
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.Param = $util.newBuffer([]);

                /**
                 * MarketFace MediaType.
                 * @member {number} MediaType
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.MediaType = 0;

                /**
                 * MarketFace ImageWidth.
                 * @member {number} ImageWidth
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.ImageWidth = 0;

                /**
                 * MarketFace ImageHeight.
                 * @member {number} ImageHeight
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.ImageHeight = 0;

                /**
                 * MarketFace Mobileparam.
                 * @member {Uint8Array} Mobileparam
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.Mobileparam = $util.newBuffer([]);

                /**
                 * MarketFace PbReserve.
                 * @member {Uint8Array} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 */
                MarketFace.prototype.PbReserve = $util.newBuffer([]);

                /**
                 * Creates a new MarketFace instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMarketFace=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.MarketFace} MarketFace instance
                 */
                MarketFace.create = function create(properties) {
                    return new MarketFace(properties);
                };

                /**
                 * Encodes the specified MarketFace message. Does not implicitly {@link Msg.MsgField.ImMsgBody.MarketFace.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMarketFace} message MarketFace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarketFace.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FaceName != null && Object.hasOwnProperty.call(message, "FaceName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.FaceName);
                    if (message.ItemType != null && Object.hasOwnProperty.call(message, "ItemType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ItemType);
                    if (message.FaceInfo != null && Object.hasOwnProperty.call(message, "FaceInfo"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.FaceInfo);
                    if (message.FaceId != null && Object.hasOwnProperty.call(message, "FaceId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.FaceId);
                    if (message.TabId != null && Object.hasOwnProperty.call(message, "TabId"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.TabId);
                    if (message.SubType != null && Object.hasOwnProperty.call(message, "SubType"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.SubType);
                    if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Key);
                    if (message.Param != null && Object.hasOwnProperty.call(message, "Param"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Param);
                    if (message.MediaType != null && Object.hasOwnProperty.call(message, "MediaType"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.MediaType);
                    if (message.ImageWidth != null && Object.hasOwnProperty.call(message, "ImageWidth"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.ImageWidth);
                    if (message.ImageHeight != null && Object.hasOwnProperty.call(message, "ImageHeight"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.ImageHeight);
                    if (message.Mobileparam != null && Object.hasOwnProperty.call(message, "Mobileparam"))
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.Mobileparam);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.PbReserve);
                    return writer;
                };

                /**
                 * Encodes the specified MarketFace message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.MarketFace.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMarketFace} message MarketFace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarketFace.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MarketFace message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.MarketFace} MarketFace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarketFace.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.MarketFace();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.FaceName = reader.bytes();
                            break;
                        case 2:
                            message.ItemType = reader.int32();
                            break;
                        case 3:
                            message.FaceInfo = reader.int32();
                            break;
                        case 4:
                            message.FaceId = reader.bytes();
                            break;
                        case 5:
                            message.TabId = reader.int32();
                            break;
                        case 6:
                            message.SubType = reader.int32();
                            break;
                        case 7:
                            message.Key = reader.bytes();
                            break;
                        case 8:
                            message.Param = reader.bytes();
                            break;
                        case 9:
                            message.MediaType = reader.int32();
                            break;
                        case 10:
                            message.ImageWidth = reader.int32();
                            break;
                        case 11:
                            message.ImageHeight = reader.int32();
                            break;
                        case 12:
                            message.Mobileparam = reader.bytes();
                            break;
                        case 13:
                            message.PbReserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MarketFace message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.MarketFace} MarketFace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarketFace.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MarketFace message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MarketFace.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FaceName != null && message.hasOwnProperty("FaceName"))
                        if (!(message.FaceName && typeof message.FaceName.length === "number" || $util.isString(message.FaceName)))
                            return "FaceName: buffer expected";
                    if (message.ItemType != null && message.hasOwnProperty("ItemType"))
                        if (!$util.isInteger(message.ItemType))
                            return "ItemType: integer expected";
                    if (message.FaceInfo != null && message.hasOwnProperty("FaceInfo"))
                        if (!$util.isInteger(message.FaceInfo))
                            return "FaceInfo: integer expected";
                    if (message.FaceId != null && message.hasOwnProperty("FaceId"))
                        if (!(message.FaceId && typeof message.FaceId.length === "number" || $util.isString(message.FaceId)))
                            return "FaceId: buffer expected";
                    if (message.TabId != null && message.hasOwnProperty("TabId"))
                        if (!$util.isInteger(message.TabId))
                            return "TabId: integer expected";
                    if (message.SubType != null && message.hasOwnProperty("SubType"))
                        if (!$util.isInteger(message.SubType))
                            return "SubType: integer expected";
                    if (message.Key != null && message.hasOwnProperty("Key"))
                        if (!(message.Key && typeof message.Key.length === "number" || $util.isString(message.Key)))
                            return "Key: buffer expected";
                    if (message.Param != null && message.hasOwnProperty("Param"))
                        if (!(message.Param && typeof message.Param.length === "number" || $util.isString(message.Param)))
                            return "Param: buffer expected";
                    if (message.MediaType != null && message.hasOwnProperty("MediaType"))
                        if (!$util.isInteger(message.MediaType))
                            return "MediaType: integer expected";
                    if (message.ImageWidth != null && message.hasOwnProperty("ImageWidth"))
                        if (!$util.isInteger(message.ImageWidth))
                            return "ImageWidth: integer expected";
                    if (message.ImageHeight != null && message.hasOwnProperty("ImageHeight"))
                        if (!$util.isInteger(message.ImageHeight))
                            return "ImageHeight: integer expected";
                    if (message.Mobileparam != null && message.hasOwnProperty("Mobileparam"))
                        if (!(message.Mobileparam && typeof message.Mobileparam.length === "number" || $util.isString(message.Mobileparam)))
                            return "Mobileparam: buffer expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                            return "PbReserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a MarketFace message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.MarketFace} MarketFace
                 */
                MarketFace.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.MarketFace)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.MarketFace();
                    if (object.FaceName != null)
                        if (typeof object.FaceName === "string")
                            $util.base64.decode(object.FaceName, message.FaceName = $util.newBuffer($util.base64.length(object.FaceName)), 0);
                        else if (object.FaceName.length)
                            message.FaceName = object.FaceName;
                    if (object.ItemType != null)
                        message.ItemType = object.ItemType | 0;
                    if (object.FaceInfo != null)
                        message.FaceInfo = object.FaceInfo | 0;
                    if (object.FaceId != null)
                        if (typeof object.FaceId === "string")
                            $util.base64.decode(object.FaceId, message.FaceId = $util.newBuffer($util.base64.length(object.FaceId)), 0);
                        else if (object.FaceId.length)
                            message.FaceId = object.FaceId;
                    if (object.TabId != null)
                        message.TabId = object.TabId | 0;
                    if (object.SubType != null)
                        message.SubType = object.SubType | 0;
                    if (object.Key != null)
                        if (typeof object.Key === "string")
                            $util.base64.decode(object.Key, message.Key = $util.newBuffer($util.base64.length(object.Key)), 0);
                        else if (object.Key.length)
                            message.Key = object.Key;
                    if (object.Param != null)
                        if (typeof object.Param === "string")
                            $util.base64.decode(object.Param, message.Param = $util.newBuffer($util.base64.length(object.Param)), 0);
                        else if (object.Param.length)
                            message.Param = object.Param;
                    if (object.MediaType != null)
                        message.MediaType = object.MediaType | 0;
                    if (object.ImageWidth != null)
                        message.ImageWidth = object.ImageWidth | 0;
                    if (object.ImageHeight != null)
                        message.ImageHeight = object.ImageHeight | 0;
                    if (object.Mobileparam != null)
                        if (typeof object.Mobileparam === "string")
                            $util.base64.decode(object.Mobileparam, message.Mobileparam = $util.newBuffer($util.base64.length(object.Mobileparam)), 0);
                        else if (object.Mobileparam.length)
                            message.Mobileparam = object.Mobileparam;
                    if (object.PbReserve != null)
                        if (typeof object.PbReserve === "string")
                            $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                        else if (object.PbReserve.length)
                            message.PbReserve = object.PbReserve;
                    return message;
                };

                /**
                 * Creates a plain object from a MarketFace message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.MarketFace} message MarketFace
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MarketFace.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.FaceName = "";
                        else {
                            object.FaceName = [];
                            if (options.bytes !== Array)
                                object.FaceName = $util.newBuffer(object.FaceName);
                        }
                        object.ItemType = 0;
                        object.FaceInfo = 0;
                        if (options.bytes === String)
                            object.FaceId = "";
                        else {
                            object.FaceId = [];
                            if (options.bytes !== Array)
                                object.FaceId = $util.newBuffer(object.FaceId);
                        }
                        object.TabId = 0;
                        object.SubType = 0;
                        if (options.bytes === String)
                            object.Key = "";
                        else {
                            object.Key = [];
                            if (options.bytes !== Array)
                                object.Key = $util.newBuffer(object.Key);
                        }
                        if (options.bytes === String)
                            object.Param = "";
                        else {
                            object.Param = [];
                            if (options.bytes !== Array)
                                object.Param = $util.newBuffer(object.Param);
                        }
                        object.MediaType = 0;
                        object.ImageWidth = 0;
                        object.ImageHeight = 0;
                        if (options.bytes === String)
                            object.Mobileparam = "";
                        else {
                            object.Mobileparam = [];
                            if (options.bytes !== Array)
                                object.Mobileparam = $util.newBuffer(object.Mobileparam);
                        }
                        if (options.bytes === String)
                            object.PbReserve = "";
                        else {
                            object.PbReserve = [];
                            if (options.bytes !== Array)
                                object.PbReserve = $util.newBuffer(object.PbReserve);
                        }
                    }
                    if (message.FaceName != null && message.hasOwnProperty("FaceName"))
                        object.FaceName = options.bytes === String ? $util.base64.encode(message.FaceName, 0, message.FaceName.length) : options.bytes === Array ? Array.prototype.slice.call(message.FaceName) : message.FaceName;
                    if (message.ItemType != null && message.hasOwnProperty("ItemType"))
                        object.ItemType = message.ItemType;
                    if (message.FaceInfo != null && message.hasOwnProperty("FaceInfo"))
                        object.FaceInfo = message.FaceInfo;
                    if (message.FaceId != null && message.hasOwnProperty("FaceId"))
                        object.FaceId = options.bytes === String ? $util.base64.encode(message.FaceId, 0, message.FaceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.FaceId) : message.FaceId;
                    if (message.TabId != null && message.hasOwnProperty("TabId"))
                        object.TabId = message.TabId;
                    if (message.SubType != null && message.hasOwnProperty("SubType"))
                        object.SubType = message.SubType;
                    if (message.Key != null && message.hasOwnProperty("Key"))
                        object.Key = options.bytes === String ? $util.base64.encode(message.Key, 0, message.Key.length) : options.bytes === Array ? Array.prototype.slice.call(message.Key) : message.Key;
                    if (message.Param != null && message.hasOwnProperty("Param"))
                        object.Param = options.bytes === String ? $util.base64.encode(message.Param, 0, message.Param.length) : options.bytes === Array ? Array.prototype.slice.call(message.Param) : message.Param;
                    if (message.MediaType != null && message.hasOwnProperty("MediaType"))
                        object.MediaType = message.MediaType;
                    if (message.ImageWidth != null && message.hasOwnProperty("ImageWidth"))
                        object.ImageWidth = message.ImageWidth;
                    if (message.ImageHeight != null && message.hasOwnProperty("ImageHeight"))
                        object.ImageHeight = message.ImageHeight;
                    if (message.Mobileparam != null && message.hasOwnProperty("Mobileparam"))
                        object.Mobileparam = options.bytes === String ? $util.base64.encode(message.Mobileparam, 0, message.Mobileparam.length) : options.bytes === Array ? Array.prototype.slice.call(message.Mobileparam) : message.Mobileparam;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                    return object;
                };

                /**
                 * Converts this MarketFace to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.MarketFace
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MarketFace.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MarketFace;
            })();

            ImMsgBody.ElemFlags = (function() {

                /**
                 * Properties of an ElemFlags.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IElemFlags
                 * @property {Uint8Array|null} [Flags] ElemFlags Flags
                 * @property {Uint8Array|null} [BusinessData] ElemFlags BusinessData
                 */

                /**
                 * Constructs a new ElemFlags.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an ElemFlags.
                 * @implements IElemFlags
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags=} [properties] Properties to set
                 */
                function ElemFlags(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ElemFlags Flags.
                 * @member {Uint8Array} Flags
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @instance
                 */
                ElemFlags.prototype.Flags = $util.newBuffer([]);

                /**
                 * ElemFlags BusinessData.
                 * @member {Uint8Array} BusinessData
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @instance
                 */
                ElemFlags.prototype.BusinessData = $util.newBuffer([]);

                /**
                 * Creates a new ElemFlags instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags} ElemFlags instance
                 */
                ElemFlags.create = function create(properties) {
                    return new ElemFlags(properties);
                };

                /**
                 * Encodes the specified ElemFlags message. Does not implicitly {@link Msg.MsgField.ImMsgBody.ElemFlags.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags} message ElemFlags message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElemFlags.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Flags != null && Object.hasOwnProperty.call(message, "Flags"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Flags);
                    if (message.BusinessData != null && Object.hasOwnProperty.call(message, "BusinessData"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.BusinessData);
                    return writer;
                };

                /**
                 * Encodes the specified ElemFlags message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.ElemFlags.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags} message ElemFlags message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElemFlags.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ElemFlags message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags} ElemFlags
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElemFlags.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.ElemFlags();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Flags = reader.bytes();
                            break;
                        case 2:
                            message.BusinessData = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ElemFlags message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags} ElemFlags
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElemFlags.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ElemFlags message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ElemFlags.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        if (!(message.Flags && typeof message.Flags.length === "number" || $util.isString(message.Flags)))
                            return "Flags: buffer expected";
                    if (message.BusinessData != null && message.hasOwnProperty("BusinessData"))
                        if (!(message.BusinessData && typeof message.BusinessData.length === "number" || $util.isString(message.BusinessData)))
                            return "BusinessData: buffer expected";
                    return null;
                };

                /**
                 * Creates an ElemFlags message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags} ElemFlags
                 */
                ElemFlags.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.ElemFlags)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.ElemFlags();
                    if (object.Flags != null)
                        if (typeof object.Flags === "string")
                            $util.base64.decode(object.Flags, message.Flags = $util.newBuffer($util.base64.length(object.Flags)), 0);
                        else if (object.Flags.length)
                            message.Flags = object.Flags;
                    if (object.BusinessData != null)
                        if (typeof object.BusinessData === "string")
                            $util.base64.decode(object.BusinessData, message.BusinessData = $util.newBuffer($util.base64.length(object.BusinessData)), 0);
                        else if (object.BusinessData.length)
                            message.BusinessData = object.BusinessData;
                    return message;
                };

                /**
                 * Creates a plain object from an ElemFlags message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ElemFlags} message ElemFlags
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ElemFlags.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Flags = "";
                        else {
                            object.Flags = [];
                            if (options.bytes !== Array)
                                object.Flags = $util.newBuffer(object.Flags);
                        }
                        if (options.bytes === String)
                            object.BusinessData = "";
                        else {
                            object.BusinessData = [];
                            if (options.bytes !== Array)
                                object.BusinessData = $util.newBuffer(object.BusinessData);
                        }
                    }
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        object.Flags = options.bytes === String ? $util.base64.encode(message.Flags, 0, message.Flags.length) : options.bytes === Array ? Array.prototype.slice.call(message.Flags) : message.Flags;
                    if (message.BusinessData != null && message.hasOwnProperty("BusinessData"))
                        object.BusinessData = options.bytes === String ? $util.base64.encode(message.BusinessData, 0, message.BusinessData.length) : options.bytes === Array ? Array.prototype.slice.call(message.BusinessData) : message.BusinessData;
                    return object;
                };

                /**
                 * Converts this ElemFlags to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ElemFlags.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ElemFlags;
            })();

            ImMsgBody.CustomFace = (function() {

                /**
                 * Properties of a CustomFace.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ICustomFace
                 * @property {Uint8Array|null} [Guid] CustomFace Guid
                 * @property {string|null} [FilePath] CustomFace FilePath
                 * @property {string|null} [Shortcut] CustomFace Shortcut
                 * @property {Uint8Array|null} [Buffer] CustomFace Buffer
                 * @property {Uint8Array|null} [Flag] CustomFace Flag
                 * @property {Uint8Array|null} [OldData] CustomFace OldData
                 * @property {number|null} [FileId] CustomFace FileId
                 * @property {number|null} [ServerIp] CustomFace ServerIp
                 * @property {number|null} [ServerPort] CustomFace ServerPort
                 * @property {number|null} [FileType] CustomFace FileType
                 * @property {Uint8Array|null} [Signature] CustomFace Signature
                 * @property {number|null} [Useful] CustomFace Useful
                 * @property {Uint8Array|null} [Md5] CustomFace Md5
                 * @property {string|null} [ThumbUrl] CustomFace ThumbUrl
                 * @property {string|null} [BigUrl] CustomFace BigUrl
                 * @property {string|null} [OrigUrl] CustomFace OrigUrl
                 * @property {number|null} [BizType] CustomFace BizType
                 * @property {number|null} [RepeatIndex] CustomFace RepeatIndex
                 * @property {number|null} [RepeatImage] CustomFace RepeatImage
                 * @property {number|null} [ImageType] CustomFace ImageType
                 * @property {number|null} [Index] CustomFace Index
                 * @property {number|null} [Width] CustomFace Width
                 * @property {number|null} [Height] CustomFace Height
                 * @property {number|null} [Source] CustomFace Source
                 * @property {number|null} [Size] CustomFace Size
                 * @property {number|null} [Origin] CustomFace Origin
                 * @property {number|null} [ThumbWidth] CustomFace ThumbWidth
                 * @property {number|null} [ThumbHeight] CustomFace ThumbHeight
                 * @property {number|null} [ShowLen] CustomFace ShowLen
                 * @property {number|null} [DownloadLen] CustomFace DownloadLen
                 * @property {string|null} [Url] CustomFace Url
                 * @property {number|null} [OtherWidth] CustomFace OtherWidth
                 * @property {number|null} [OtherHeight] CustomFace OtherHeight
                 * @property {Uint8Array|null} [PbReserve] CustomFace PbReserve
                 */

                /**
                 * Constructs a new CustomFace.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a CustomFace.
                 * @implements ICustomFace
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ICustomFace=} [properties] Properties to set
                 */
                function CustomFace(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CustomFace Guid.
                 * @member {Uint8Array} Guid
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Guid = $util.newBuffer([]);

                /**
                 * CustomFace FilePath.
                 * @member {string} FilePath
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.FilePath = "";

                /**
                 * CustomFace Shortcut.
                 * @member {string} Shortcut
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Shortcut = "";

                /**
                 * CustomFace Buffer.
                 * @member {Uint8Array} Buffer
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Buffer = $util.newBuffer([]);

                /**
                 * CustomFace Flag.
                 * @member {Uint8Array} Flag
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Flag = $util.newBuffer([]);

                /**
                 * CustomFace OldData.
                 * @member {Uint8Array} OldData
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.OldData = $util.newBuffer([]);

                /**
                 * CustomFace FileId.
                 * @member {number} FileId
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.FileId = 0;

                /**
                 * CustomFace ServerIp.
                 * @member {number} ServerIp
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.ServerIp = 0;

                /**
                 * CustomFace ServerPort.
                 * @member {number} ServerPort
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.ServerPort = 0;

                /**
                 * CustomFace FileType.
                 * @member {number} FileType
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.FileType = 0;

                /**
                 * CustomFace Signature.
                 * @member {Uint8Array} Signature
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Signature = $util.newBuffer([]);

                /**
                 * CustomFace Useful.
                 * @member {number} Useful
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Useful = 0;

                /**
                 * CustomFace Md5.
                 * @member {Uint8Array} Md5
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Md5 = $util.newBuffer([]);

                /**
                 * CustomFace ThumbUrl.
                 * @member {string} ThumbUrl
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.ThumbUrl = "";

                /**
                 * CustomFace BigUrl.
                 * @member {string} BigUrl
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.BigUrl = "";

                /**
                 * CustomFace OrigUrl.
                 * @member {string} OrigUrl
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.OrigUrl = "";

                /**
                 * CustomFace BizType.
                 * @member {number} BizType
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.BizType = 0;

                /**
                 * CustomFace RepeatIndex.
                 * @member {number} RepeatIndex
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.RepeatIndex = 0;

                /**
                 * CustomFace RepeatImage.
                 * @member {number} RepeatImage
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.RepeatImage = 0;

                /**
                 * CustomFace ImageType.
                 * @member {number} ImageType
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.ImageType = 0;

                /**
                 * CustomFace Index.
                 * @member {number} Index
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Index = 0;

                /**
                 * CustomFace Width.
                 * @member {number} Width
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Width = 0;

                /**
                 * CustomFace Height.
                 * @member {number} Height
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Height = 0;

                /**
                 * CustomFace Source.
                 * @member {number} Source
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Source = 0;

                /**
                 * CustomFace Size.
                 * @member {number} Size
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Size = 0;

                /**
                 * CustomFace Origin.
                 * @member {number} Origin
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Origin = 0;

                /**
                 * CustomFace ThumbWidth.
                 * @member {number} ThumbWidth
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.ThumbWidth = 0;

                /**
                 * CustomFace ThumbHeight.
                 * @member {number} ThumbHeight
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.ThumbHeight = 0;

                /**
                 * CustomFace ShowLen.
                 * @member {number} ShowLen
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.ShowLen = 0;

                /**
                 * CustomFace DownloadLen.
                 * @member {number} DownloadLen
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.DownloadLen = 0;

                /**
                 * CustomFace Url.
                 * @member {string} Url
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.Url = "";

                /**
                 * CustomFace OtherWidth.
                 * @member {number} OtherWidth
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.OtherWidth = 0;

                /**
                 * CustomFace OtherHeight.
                 * @member {number} OtherHeight
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.OtherHeight = 0;

                /**
                 * CustomFace PbReserve.
                 * @member {Uint8Array} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 */
                CustomFace.prototype.PbReserve = $util.newBuffer([]);

                /**
                 * Creates a new CustomFace instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICustomFace=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.CustomFace} CustomFace instance
                 */
                CustomFace.create = function create(properties) {
                    return new CustomFace(properties);
                };

                /**
                 * Encodes the specified CustomFace message. Does not implicitly {@link Msg.MsgField.ImMsgBody.CustomFace.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICustomFace} message CustomFace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomFace.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Guid != null && Object.hasOwnProperty.call(message, "Guid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Guid);
                    if (message.FilePath != null && Object.hasOwnProperty.call(message, "FilePath"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.FilePath);
                    if (message.Shortcut != null && Object.hasOwnProperty.call(message, "Shortcut"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Shortcut);
                    if (message.Buffer != null && Object.hasOwnProperty.call(message, "Buffer"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Buffer);
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Flag);
                    if (message.OldData != null && Object.hasOwnProperty.call(message, "OldData"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.OldData);
                    if (message.FileId != null && Object.hasOwnProperty.call(message, "FileId"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.FileId);
                    if (message.ServerIp != null && Object.hasOwnProperty.call(message, "ServerIp"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.ServerIp);
                    if (message.ServerPort != null && Object.hasOwnProperty.call(message, "ServerPort"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.ServerPort);
                    if (message.FileType != null && Object.hasOwnProperty.call(message, "FileType"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.FileType);
                    if (message.Signature != null && Object.hasOwnProperty.call(message, "Signature"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Signature);
                    if (message.Useful != null && Object.hasOwnProperty.call(message, "Useful"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.Useful);
                    if (message.Md5 != null && Object.hasOwnProperty.call(message, "Md5"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.Md5);
                    if (message.ThumbUrl != null && Object.hasOwnProperty.call(message, "ThumbUrl"))
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.ThumbUrl);
                    if (message.BigUrl != null && Object.hasOwnProperty.call(message, "BigUrl"))
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.BigUrl);
                    if (message.OrigUrl != null && Object.hasOwnProperty.call(message, "OrigUrl"))
                        writer.uint32(/* id 16, wireType 2 =*/130).string(message.OrigUrl);
                    if (message.BizType != null && Object.hasOwnProperty.call(message, "BizType"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.BizType);
                    if (message.RepeatIndex != null && Object.hasOwnProperty.call(message, "RepeatIndex"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.RepeatIndex);
                    if (message.RepeatImage != null && Object.hasOwnProperty.call(message, "RepeatImage"))
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.RepeatImage);
                    if (message.ImageType != null && Object.hasOwnProperty.call(message, "ImageType"))
                        writer.uint32(/* id 20, wireType 0 =*/160).int32(message.ImageType);
                    if (message.Index != null && Object.hasOwnProperty.call(message, "Index"))
                        writer.uint32(/* id 21, wireType 0 =*/168).int32(message.Index);
                    if (message.Width != null && Object.hasOwnProperty.call(message, "Width"))
                        writer.uint32(/* id 22, wireType 0 =*/176).int32(message.Width);
                    if (message.Height != null && Object.hasOwnProperty.call(message, "Height"))
                        writer.uint32(/* id 23, wireType 0 =*/184).int32(message.Height);
                    if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                        writer.uint32(/* id 24, wireType 0 =*/192).int32(message.Source);
                    if (message.Size != null && Object.hasOwnProperty.call(message, "Size"))
                        writer.uint32(/* id 25, wireType 0 =*/200).int32(message.Size);
                    if (message.Origin != null && Object.hasOwnProperty.call(message, "Origin"))
                        writer.uint32(/* id 26, wireType 0 =*/208).int32(message.Origin);
                    if (message.ThumbWidth != null && Object.hasOwnProperty.call(message, "ThumbWidth"))
                        writer.uint32(/* id 27, wireType 0 =*/216).int32(message.ThumbWidth);
                    if (message.ThumbHeight != null && Object.hasOwnProperty.call(message, "ThumbHeight"))
                        writer.uint32(/* id 28, wireType 0 =*/224).int32(message.ThumbHeight);
                    if (message.ShowLen != null && Object.hasOwnProperty.call(message, "ShowLen"))
                        writer.uint32(/* id 29, wireType 0 =*/232).int32(message.ShowLen);
                    if (message.DownloadLen != null && Object.hasOwnProperty.call(message, "DownloadLen"))
                        writer.uint32(/* id 30, wireType 0 =*/240).int32(message.DownloadLen);
                    if (message.Url != null && Object.hasOwnProperty.call(message, "Url"))
                        writer.uint32(/* id 31, wireType 2 =*/250).string(message.Url);
                    if (message.OtherWidth != null && Object.hasOwnProperty.call(message, "OtherWidth"))
                        writer.uint32(/* id 32, wireType 0 =*/256).int32(message.OtherWidth);
                    if (message.OtherHeight != null && Object.hasOwnProperty.call(message, "OtherHeight"))
                        writer.uint32(/* id 33, wireType 0 =*/264).int32(message.OtherHeight);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 34, wireType 2 =*/274).bytes(message.PbReserve);
                    return writer;
                };

                /**
                 * Encodes the specified CustomFace message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.CustomFace.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICustomFace} message CustomFace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomFace.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CustomFace message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.CustomFace} CustomFace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomFace.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.CustomFace();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Guid = reader.bytes();
                            break;
                        case 2:
                            message.FilePath = reader.string();
                            break;
                        case 3:
                            message.Shortcut = reader.string();
                            break;
                        case 4:
                            message.Buffer = reader.bytes();
                            break;
                        case 5:
                            message.Flag = reader.bytes();
                            break;
                        case 6:
                            message.OldData = reader.bytes();
                            break;
                        case 7:
                            message.FileId = reader.int32();
                            break;
                        case 8:
                            message.ServerIp = reader.int32();
                            break;
                        case 9:
                            message.ServerPort = reader.int32();
                            break;
                        case 10:
                            message.FileType = reader.int32();
                            break;
                        case 11:
                            message.Signature = reader.bytes();
                            break;
                        case 12:
                            message.Useful = reader.int32();
                            break;
                        case 13:
                            message.Md5 = reader.bytes();
                            break;
                        case 14:
                            message.ThumbUrl = reader.string();
                            break;
                        case 15:
                            message.BigUrl = reader.string();
                            break;
                        case 16:
                            message.OrigUrl = reader.string();
                            break;
                        case 17:
                            message.BizType = reader.int32();
                            break;
                        case 18:
                            message.RepeatIndex = reader.int32();
                            break;
                        case 19:
                            message.RepeatImage = reader.int32();
                            break;
                        case 20:
                            message.ImageType = reader.int32();
                            break;
                        case 21:
                            message.Index = reader.int32();
                            break;
                        case 22:
                            message.Width = reader.int32();
                            break;
                        case 23:
                            message.Height = reader.int32();
                            break;
                        case 24:
                            message.Source = reader.int32();
                            break;
                        case 25:
                            message.Size = reader.int32();
                            break;
                        case 26:
                            message.Origin = reader.int32();
                            break;
                        case 27:
                            message.ThumbWidth = reader.int32();
                            break;
                        case 28:
                            message.ThumbHeight = reader.int32();
                            break;
                        case 29:
                            message.ShowLen = reader.int32();
                            break;
                        case 30:
                            message.DownloadLen = reader.int32();
                            break;
                        case 31:
                            message.Url = reader.string();
                            break;
                        case 32:
                            message.OtherWidth = reader.int32();
                            break;
                        case 33:
                            message.OtherHeight = reader.int32();
                            break;
                        case 34:
                            message.PbReserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CustomFace message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.CustomFace} CustomFace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomFace.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CustomFace message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CustomFace.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Guid != null && message.hasOwnProperty("Guid"))
                        if (!(message.Guid && typeof message.Guid.length === "number" || $util.isString(message.Guid)))
                            return "Guid: buffer expected";
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        if (!$util.isString(message.FilePath))
                            return "FilePath: string expected";
                    if (message.Shortcut != null && message.hasOwnProperty("Shortcut"))
                        if (!$util.isString(message.Shortcut))
                            return "Shortcut: string expected";
                    if (message.Buffer != null && message.hasOwnProperty("Buffer"))
                        if (!(message.Buffer && typeof message.Buffer.length === "number" || $util.isString(message.Buffer)))
                            return "Buffer: buffer expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!(message.Flag && typeof message.Flag.length === "number" || $util.isString(message.Flag)))
                            return "Flag: buffer expected";
                    if (message.OldData != null && message.hasOwnProperty("OldData"))
                        if (!(message.OldData && typeof message.OldData.length === "number" || $util.isString(message.OldData)))
                            return "OldData: buffer expected";
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        if (!$util.isInteger(message.FileId))
                            return "FileId: integer expected";
                    if (message.ServerIp != null && message.hasOwnProperty("ServerIp"))
                        if (!$util.isInteger(message.ServerIp))
                            return "ServerIp: integer expected";
                    if (message.ServerPort != null && message.hasOwnProperty("ServerPort"))
                        if (!$util.isInteger(message.ServerPort))
                            return "ServerPort: integer expected";
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        if (!$util.isInteger(message.FileType))
                            return "FileType: integer expected";
                    if (message.Signature != null && message.hasOwnProperty("Signature"))
                        if (!(message.Signature && typeof message.Signature.length === "number" || $util.isString(message.Signature)))
                            return "Signature: buffer expected";
                    if (message.Useful != null && message.hasOwnProperty("Useful"))
                        if (!$util.isInteger(message.Useful))
                            return "Useful: integer expected";
                    if (message.Md5 != null && message.hasOwnProperty("Md5"))
                        if (!(message.Md5 && typeof message.Md5.length === "number" || $util.isString(message.Md5)))
                            return "Md5: buffer expected";
                    if (message.ThumbUrl != null && message.hasOwnProperty("ThumbUrl"))
                        if (!$util.isString(message.ThumbUrl))
                            return "ThumbUrl: string expected";
                    if (message.BigUrl != null && message.hasOwnProperty("BigUrl"))
                        if (!$util.isString(message.BigUrl))
                            return "BigUrl: string expected";
                    if (message.OrigUrl != null && message.hasOwnProperty("OrigUrl"))
                        if (!$util.isString(message.OrigUrl))
                            return "OrigUrl: string expected";
                    if (message.BizType != null && message.hasOwnProperty("BizType"))
                        if (!$util.isInteger(message.BizType))
                            return "BizType: integer expected";
                    if (message.RepeatIndex != null && message.hasOwnProperty("RepeatIndex"))
                        if (!$util.isInteger(message.RepeatIndex))
                            return "RepeatIndex: integer expected";
                    if (message.RepeatImage != null && message.hasOwnProperty("RepeatImage"))
                        if (!$util.isInteger(message.RepeatImage))
                            return "RepeatImage: integer expected";
                    if (message.ImageType != null && message.hasOwnProperty("ImageType"))
                        if (!$util.isInteger(message.ImageType))
                            return "ImageType: integer expected";
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        if (!$util.isInteger(message.Index))
                            return "Index: integer expected";
                    if (message.Width != null && message.hasOwnProperty("Width"))
                        if (!$util.isInteger(message.Width))
                            return "Width: integer expected";
                    if (message.Height != null && message.hasOwnProperty("Height"))
                        if (!$util.isInteger(message.Height))
                            return "Height: integer expected";
                    if (message.Source != null && message.hasOwnProperty("Source"))
                        if (!$util.isInteger(message.Source))
                            return "Source: integer expected";
                    if (message.Size != null && message.hasOwnProperty("Size"))
                        if (!$util.isInteger(message.Size))
                            return "Size: integer expected";
                    if (message.Origin != null && message.hasOwnProperty("Origin"))
                        if (!$util.isInteger(message.Origin))
                            return "Origin: integer expected";
                    if (message.ThumbWidth != null && message.hasOwnProperty("ThumbWidth"))
                        if (!$util.isInteger(message.ThumbWidth))
                            return "ThumbWidth: integer expected";
                    if (message.ThumbHeight != null && message.hasOwnProperty("ThumbHeight"))
                        if (!$util.isInteger(message.ThumbHeight))
                            return "ThumbHeight: integer expected";
                    if (message.ShowLen != null && message.hasOwnProperty("ShowLen"))
                        if (!$util.isInteger(message.ShowLen))
                            return "ShowLen: integer expected";
                    if (message.DownloadLen != null && message.hasOwnProperty("DownloadLen"))
                        if (!$util.isInteger(message.DownloadLen))
                            return "DownloadLen: integer expected";
                    if (message.Url != null && message.hasOwnProperty("Url"))
                        if (!$util.isString(message.Url))
                            return "Url: string expected";
                    if (message.OtherWidth != null && message.hasOwnProperty("OtherWidth"))
                        if (!$util.isInteger(message.OtherWidth))
                            return "OtherWidth: integer expected";
                    if (message.OtherHeight != null && message.hasOwnProperty("OtherHeight"))
                        if (!$util.isInteger(message.OtherHeight))
                            return "OtherHeight: integer expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                            return "PbReserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a CustomFace message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.CustomFace} CustomFace
                 */
                CustomFace.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.CustomFace)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.CustomFace();
                    if (object.Guid != null)
                        if (typeof object.Guid === "string")
                            $util.base64.decode(object.Guid, message.Guid = $util.newBuffer($util.base64.length(object.Guid)), 0);
                        else if (object.Guid.length)
                            message.Guid = object.Guid;
                    if (object.FilePath != null)
                        message.FilePath = String(object.FilePath);
                    if (object.Shortcut != null)
                        message.Shortcut = String(object.Shortcut);
                    if (object.Buffer != null)
                        if (typeof object.Buffer === "string")
                            $util.base64.decode(object.Buffer, message.Buffer = $util.newBuffer($util.base64.length(object.Buffer)), 0);
                        else if (object.Buffer.length)
                            message.Buffer = object.Buffer;
                    if (object.Flag != null)
                        if (typeof object.Flag === "string")
                            $util.base64.decode(object.Flag, message.Flag = $util.newBuffer($util.base64.length(object.Flag)), 0);
                        else if (object.Flag.length)
                            message.Flag = object.Flag;
                    if (object.OldData != null)
                        if (typeof object.OldData === "string")
                            $util.base64.decode(object.OldData, message.OldData = $util.newBuffer($util.base64.length(object.OldData)), 0);
                        else if (object.OldData.length)
                            message.OldData = object.OldData;
                    if (object.FileId != null)
                        message.FileId = object.FileId | 0;
                    if (object.ServerIp != null)
                        message.ServerIp = object.ServerIp | 0;
                    if (object.ServerPort != null)
                        message.ServerPort = object.ServerPort | 0;
                    if (object.FileType != null)
                        message.FileType = object.FileType | 0;
                    if (object.Signature != null)
                        if (typeof object.Signature === "string")
                            $util.base64.decode(object.Signature, message.Signature = $util.newBuffer($util.base64.length(object.Signature)), 0);
                        else if (object.Signature.length)
                            message.Signature = object.Signature;
                    if (object.Useful != null)
                        message.Useful = object.Useful | 0;
                    if (object.Md5 != null)
                        if (typeof object.Md5 === "string")
                            $util.base64.decode(object.Md5, message.Md5 = $util.newBuffer($util.base64.length(object.Md5)), 0);
                        else if (object.Md5.length)
                            message.Md5 = object.Md5;
                    if (object.ThumbUrl != null)
                        message.ThumbUrl = String(object.ThumbUrl);
                    if (object.BigUrl != null)
                        message.BigUrl = String(object.BigUrl);
                    if (object.OrigUrl != null)
                        message.OrigUrl = String(object.OrigUrl);
                    if (object.BizType != null)
                        message.BizType = object.BizType | 0;
                    if (object.RepeatIndex != null)
                        message.RepeatIndex = object.RepeatIndex | 0;
                    if (object.RepeatImage != null)
                        message.RepeatImage = object.RepeatImage | 0;
                    if (object.ImageType != null)
                        message.ImageType = object.ImageType | 0;
                    if (object.Index != null)
                        message.Index = object.Index | 0;
                    if (object.Width != null)
                        message.Width = object.Width | 0;
                    if (object.Height != null)
                        message.Height = object.Height | 0;
                    if (object.Source != null)
                        message.Source = object.Source | 0;
                    if (object.Size != null)
                        message.Size = object.Size | 0;
                    if (object.Origin != null)
                        message.Origin = object.Origin | 0;
                    if (object.ThumbWidth != null)
                        message.ThumbWidth = object.ThumbWidth | 0;
                    if (object.ThumbHeight != null)
                        message.ThumbHeight = object.ThumbHeight | 0;
                    if (object.ShowLen != null)
                        message.ShowLen = object.ShowLen | 0;
                    if (object.DownloadLen != null)
                        message.DownloadLen = object.DownloadLen | 0;
                    if (object.Url != null)
                        message.Url = String(object.Url);
                    if (object.OtherWidth != null)
                        message.OtherWidth = object.OtherWidth | 0;
                    if (object.OtherHeight != null)
                        message.OtherHeight = object.OtherHeight | 0;
                    if (object.PbReserve != null)
                        if (typeof object.PbReserve === "string")
                            $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                        else if (object.PbReserve.length)
                            message.PbReserve = object.PbReserve;
                    return message;
                };

                /**
                 * Creates a plain object from a CustomFace message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.CustomFace} message CustomFace
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CustomFace.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Guid = "";
                        else {
                            object.Guid = [];
                            if (options.bytes !== Array)
                                object.Guid = $util.newBuffer(object.Guid);
                        }
                        object.FilePath = "";
                        object.Shortcut = "";
                        if (options.bytes === String)
                            object.Buffer = "";
                        else {
                            object.Buffer = [];
                            if (options.bytes !== Array)
                                object.Buffer = $util.newBuffer(object.Buffer);
                        }
                        if (options.bytes === String)
                            object.Flag = "";
                        else {
                            object.Flag = [];
                            if (options.bytes !== Array)
                                object.Flag = $util.newBuffer(object.Flag);
                        }
                        if (options.bytes === String)
                            object.OldData = "";
                        else {
                            object.OldData = [];
                            if (options.bytes !== Array)
                                object.OldData = $util.newBuffer(object.OldData);
                        }
                        object.FileId = 0;
                        object.ServerIp = 0;
                        object.ServerPort = 0;
                        object.FileType = 0;
                        if (options.bytes === String)
                            object.Signature = "";
                        else {
                            object.Signature = [];
                            if (options.bytes !== Array)
                                object.Signature = $util.newBuffer(object.Signature);
                        }
                        object.Useful = 0;
                        if (options.bytes === String)
                            object.Md5 = "";
                        else {
                            object.Md5 = [];
                            if (options.bytes !== Array)
                                object.Md5 = $util.newBuffer(object.Md5);
                        }
                        object.ThumbUrl = "";
                        object.BigUrl = "";
                        object.OrigUrl = "";
                        object.BizType = 0;
                        object.RepeatIndex = 0;
                        object.RepeatImage = 0;
                        object.ImageType = 0;
                        object.Index = 0;
                        object.Width = 0;
                        object.Height = 0;
                        object.Source = 0;
                        object.Size = 0;
                        object.Origin = 0;
                        object.ThumbWidth = 0;
                        object.ThumbHeight = 0;
                        object.ShowLen = 0;
                        object.DownloadLen = 0;
                        object.Url = "";
                        object.OtherWidth = 0;
                        object.OtherHeight = 0;
                        if (options.bytes === String)
                            object.PbReserve = "";
                        else {
                            object.PbReserve = [];
                            if (options.bytes !== Array)
                                object.PbReserve = $util.newBuffer(object.PbReserve);
                        }
                    }
                    if (message.Guid != null && message.hasOwnProperty("Guid"))
                        object.Guid = options.bytes === String ? $util.base64.encode(message.Guid, 0, message.Guid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Guid) : message.Guid;
                    if (message.FilePath != null && message.hasOwnProperty("FilePath"))
                        object.FilePath = message.FilePath;
                    if (message.Shortcut != null && message.hasOwnProperty("Shortcut"))
                        object.Shortcut = message.Shortcut;
                    if (message.Buffer != null && message.hasOwnProperty("Buffer"))
                        object.Buffer = options.bytes === String ? $util.base64.encode(message.Buffer, 0, message.Buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.Buffer) : message.Buffer;
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = options.bytes === String ? $util.base64.encode(message.Flag, 0, message.Flag.length) : options.bytes === Array ? Array.prototype.slice.call(message.Flag) : message.Flag;
                    if (message.OldData != null && message.hasOwnProperty("OldData"))
                        object.OldData = options.bytes === String ? $util.base64.encode(message.OldData, 0, message.OldData.length) : options.bytes === Array ? Array.prototype.slice.call(message.OldData) : message.OldData;
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        object.FileId = message.FileId;
                    if (message.ServerIp != null && message.hasOwnProperty("ServerIp"))
                        object.ServerIp = message.ServerIp;
                    if (message.ServerPort != null && message.hasOwnProperty("ServerPort"))
                        object.ServerPort = message.ServerPort;
                    if (message.FileType != null && message.hasOwnProperty("FileType"))
                        object.FileType = message.FileType;
                    if (message.Signature != null && message.hasOwnProperty("Signature"))
                        object.Signature = options.bytes === String ? $util.base64.encode(message.Signature, 0, message.Signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.Signature) : message.Signature;
                    if (message.Useful != null && message.hasOwnProperty("Useful"))
                        object.Useful = message.Useful;
                    if (message.Md5 != null && message.hasOwnProperty("Md5"))
                        object.Md5 = options.bytes === String ? $util.base64.encode(message.Md5, 0, message.Md5.length) : options.bytes === Array ? Array.prototype.slice.call(message.Md5) : message.Md5;
                    if (message.ThumbUrl != null && message.hasOwnProperty("ThumbUrl"))
                        object.ThumbUrl = message.ThumbUrl;
                    if (message.BigUrl != null && message.hasOwnProperty("BigUrl"))
                        object.BigUrl = message.BigUrl;
                    if (message.OrigUrl != null && message.hasOwnProperty("OrigUrl"))
                        object.OrigUrl = message.OrigUrl;
                    if (message.BizType != null && message.hasOwnProperty("BizType"))
                        object.BizType = message.BizType;
                    if (message.RepeatIndex != null && message.hasOwnProperty("RepeatIndex"))
                        object.RepeatIndex = message.RepeatIndex;
                    if (message.RepeatImage != null && message.hasOwnProperty("RepeatImage"))
                        object.RepeatImage = message.RepeatImage;
                    if (message.ImageType != null && message.hasOwnProperty("ImageType"))
                        object.ImageType = message.ImageType;
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        object.Index = message.Index;
                    if (message.Width != null && message.hasOwnProperty("Width"))
                        object.Width = message.Width;
                    if (message.Height != null && message.hasOwnProperty("Height"))
                        object.Height = message.Height;
                    if (message.Source != null && message.hasOwnProperty("Source"))
                        object.Source = message.Source;
                    if (message.Size != null && message.hasOwnProperty("Size"))
                        object.Size = message.Size;
                    if (message.Origin != null && message.hasOwnProperty("Origin"))
                        object.Origin = message.Origin;
                    if (message.ThumbWidth != null && message.hasOwnProperty("ThumbWidth"))
                        object.ThumbWidth = message.ThumbWidth;
                    if (message.ThumbHeight != null && message.hasOwnProperty("ThumbHeight"))
                        object.ThumbHeight = message.ThumbHeight;
                    if (message.ShowLen != null && message.hasOwnProperty("ShowLen"))
                        object.ShowLen = message.ShowLen;
                    if (message.DownloadLen != null && message.hasOwnProperty("DownloadLen"))
                        object.DownloadLen = message.DownloadLen;
                    if (message.Url != null && message.hasOwnProperty("Url"))
                        object.Url = message.Url;
                    if (message.OtherWidth != null && message.hasOwnProperty("OtherWidth"))
                        object.OtherWidth = message.OtherWidth;
                    if (message.OtherHeight != null && message.hasOwnProperty("OtherHeight"))
                        object.OtherHeight = message.OtherHeight;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                    return object;
                };

                /**
                 * Converts this CustomFace to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.CustomFace
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CustomFace.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CustomFace;
            })();

            ImMsgBody.Inst = (function() {

                /**
                 * Properties of an Inst.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IInst
                 * @property {number|null} [AppId] Inst AppId
                 * @property {number|null} [InstId] Inst InstId
                 */

                /**
                 * Constructs a new Inst.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an Inst.
                 * @implements IInst
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IInst=} [properties] Properties to set
                 */
                function Inst(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Inst AppId.
                 * @member {number} AppId
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @instance
                 */
                Inst.prototype.AppId = 0;

                /**
                 * Inst InstId.
                 * @member {number} InstId
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @instance
                 */
                Inst.prototype.InstId = 0;

                /**
                 * Creates a new Inst instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IInst=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Inst} Inst instance
                 */
                Inst.create = function create(properties) {
                    return new Inst(properties);
                };

                /**
                 * Encodes the specified Inst message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Inst.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IInst} message Inst message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Inst.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.AppId != null && Object.hasOwnProperty.call(message, "AppId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AppId);
                    if (message.InstId != null && Object.hasOwnProperty.call(message, "InstId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.InstId);
                    return writer;
                };

                /**
                 * Encodes the specified Inst message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Inst.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IInst} message Inst message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Inst.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Inst message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Inst} Inst
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Inst.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Inst();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.AppId = reader.int32();
                            break;
                        case 2:
                            message.InstId = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Inst message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Inst} Inst
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Inst.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Inst message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Inst.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.AppId != null && message.hasOwnProperty("AppId"))
                        if (!$util.isInteger(message.AppId))
                            return "AppId: integer expected";
                    if (message.InstId != null && message.hasOwnProperty("InstId"))
                        if (!$util.isInteger(message.InstId))
                            return "InstId: integer expected";
                    return null;
                };

                /**
                 * Creates an Inst message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Inst} Inst
                 */
                Inst.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Inst)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Inst();
                    if (object.AppId != null)
                        message.AppId = object.AppId | 0;
                    if (object.InstId != null)
                        message.InstId = object.InstId | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Inst message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Inst} message Inst
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Inst.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.AppId = 0;
                        object.InstId = 0;
                    }
                    if (message.AppId != null && message.hasOwnProperty("AppId"))
                        object.AppId = message.AppId;
                    if (message.InstId != null && message.hasOwnProperty("InstId"))
                        object.InstId = message.InstId;
                    return object;
                };

                /**
                 * Converts this Inst to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Inst
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Inst.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Inst;
            })();

            ImMsgBody.PcSupportDef = (function() {

                /**
                 * Properties of a PcSupportDef.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IPcSupportDef
                 * @property {number|null} [PcPtlBegin] PcSupportDef PcPtlBegin
                 * @property {number|null} [PcPtlEnd] PcSupportDef PcPtlEnd
                 * @property {number|null} [MacPtlBegin] PcSupportDef MacPtlBegin
                 * @property {number|null} [MacPtlEnd] PcSupportDef MacPtlEnd
                 * @property {Array.<number>|null} [PtlsSupport] PcSupportDef PtlsSupport
                 * @property {Array.<number>|null} [PtlsNotSupport] PcSupportDef PtlsNotSupport
                 */

                /**
                 * Constructs a new PcSupportDef.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a PcSupportDef.
                 * @implements IPcSupportDef
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IPcSupportDef=} [properties] Properties to set
                 */
                function PcSupportDef(properties) {
                    this.PtlsSupport = [];
                    this.PtlsNotSupport = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PcSupportDef PcPtlBegin.
                 * @member {number} PcPtlBegin
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @instance
                 */
                PcSupportDef.prototype.PcPtlBegin = 0;

                /**
                 * PcSupportDef PcPtlEnd.
                 * @member {number} PcPtlEnd
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @instance
                 */
                PcSupportDef.prototype.PcPtlEnd = 0;

                /**
                 * PcSupportDef MacPtlBegin.
                 * @member {number} MacPtlBegin
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @instance
                 */
                PcSupportDef.prototype.MacPtlBegin = 0;

                /**
                 * PcSupportDef MacPtlEnd.
                 * @member {number} MacPtlEnd
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @instance
                 */
                PcSupportDef.prototype.MacPtlEnd = 0;

                /**
                 * PcSupportDef PtlsSupport.
                 * @member {Array.<number>} PtlsSupport
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @instance
                 */
                PcSupportDef.prototype.PtlsSupport = $util.emptyArray;

                /**
                 * PcSupportDef PtlsNotSupport.
                 * @member {Array.<number>} PtlsNotSupport
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @instance
                 */
                PcSupportDef.prototype.PtlsNotSupport = $util.emptyArray;

                /**
                 * Creates a new PcSupportDef instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPcSupportDef=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.PcSupportDef} PcSupportDef instance
                 */
                PcSupportDef.create = function create(properties) {
                    return new PcSupportDef(properties);
                };

                /**
                 * Encodes the specified PcSupportDef message. Does not implicitly {@link Msg.MsgField.ImMsgBody.PcSupportDef.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPcSupportDef} message PcSupportDef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PcSupportDef.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.PcPtlBegin != null && Object.hasOwnProperty.call(message, "PcPtlBegin"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PcPtlBegin);
                    if (message.PcPtlEnd != null && Object.hasOwnProperty.call(message, "PcPtlEnd"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PcPtlEnd);
                    if (message.MacPtlBegin != null && Object.hasOwnProperty.call(message, "MacPtlBegin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MacPtlBegin);
                    if (message.MacPtlEnd != null && Object.hasOwnProperty.call(message, "MacPtlEnd"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MacPtlEnd);
                    if (message.PtlsSupport != null && message.PtlsSupport.length) {
                        writer.uint32(/* id 5, wireType 2 =*/42).fork();
                        for (var i = 0; i < message.PtlsSupport.length; ++i)
                            writer.int32(message.PtlsSupport[i]);
                        writer.ldelim();
                    }
                    if (message.PtlsNotSupport != null && message.PtlsNotSupport.length) {
                        writer.uint32(/* id 6, wireType 2 =*/50).fork();
                        for (var i = 0; i < message.PtlsNotSupport.length; ++i)
                            writer.int32(message.PtlsNotSupport[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified PcSupportDef message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.PcSupportDef.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPcSupportDef} message PcSupportDef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PcSupportDef.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PcSupportDef message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.PcSupportDef} PcSupportDef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PcSupportDef.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.PcSupportDef();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.PcPtlBegin = reader.int32();
                            break;
                        case 2:
                            message.PcPtlEnd = reader.int32();
                            break;
                        case 3:
                            message.MacPtlBegin = reader.int32();
                            break;
                        case 4:
                            message.MacPtlEnd = reader.int32();
                            break;
                        case 5:
                            if (!(message.PtlsSupport && message.PtlsSupport.length))
                                message.PtlsSupport = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.PtlsSupport.push(reader.int32());
                            } else
                                message.PtlsSupport.push(reader.int32());
                            break;
                        case 6:
                            if (!(message.PtlsNotSupport && message.PtlsNotSupport.length))
                                message.PtlsNotSupport = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.PtlsNotSupport.push(reader.int32());
                            } else
                                message.PtlsNotSupport.push(reader.int32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PcSupportDef message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.PcSupportDef} PcSupportDef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PcSupportDef.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PcSupportDef message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PcSupportDef.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.PcPtlBegin != null && message.hasOwnProperty("PcPtlBegin"))
                        if (!$util.isInteger(message.PcPtlBegin))
                            return "PcPtlBegin: integer expected";
                    if (message.PcPtlEnd != null && message.hasOwnProperty("PcPtlEnd"))
                        if (!$util.isInteger(message.PcPtlEnd))
                            return "PcPtlEnd: integer expected";
                    if (message.MacPtlBegin != null && message.hasOwnProperty("MacPtlBegin"))
                        if (!$util.isInteger(message.MacPtlBegin))
                            return "MacPtlBegin: integer expected";
                    if (message.MacPtlEnd != null && message.hasOwnProperty("MacPtlEnd"))
                        if (!$util.isInteger(message.MacPtlEnd))
                            return "MacPtlEnd: integer expected";
                    if (message.PtlsSupport != null && message.hasOwnProperty("PtlsSupport")) {
                        if (!Array.isArray(message.PtlsSupport))
                            return "PtlsSupport: array expected";
                        for (var i = 0; i < message.PtlsSupport.length; ++i)
                            if (!$util.isInteger(message.PtlsSupport[i]))
                                return "PtlsSupport: integer[] expected";
                    }
                    if (message.PtlsNotSupport != null && message.hasOwnProperty("PtlsNotSupport")) {
                        if (!Array.isArray(message.PtlsNotSupport))
                            return "PtlsNotSupport: array expected";
                        for (var i = 0; i < message.PtlsNotSupport.length; ++i)
                            if (!$util.isInteger(message.PtlsNotSupport[i]))
                                return "PtlsNotSupport: integer[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a PcSupportDef message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.PcSupportDef} PcSupportDef
                 */
                PcSupportDef.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.PcSupportDef)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.PcSupportDef();
                    if (object.PcPtlBegin != null)
                        message.PcPtlBegin = object.PcPtlBegin | 0;
                    if (object.PcPtlEnd != null)
                        message.PcPtlEnd = object.PcPtlEnd | 0;
                    if (object.MacPtlBegin != null)
                        message.MacPtlBegin = object.MacPtlBegin | 0;
                    if (object.MacPtlEnd != null)
                        message.MacPtlEnd = object.MacPtlEnd | 0;
                    if (object.PtlsSupport) {
                        if (!Array.isArray(object.PtlsSupport))
                            throw TypeError(".Msg.MsgField.ImMsgBody.PcSupportDef.PtlsSupport: array expected");
                        message.PtlsSupport = [];
                        for (var i = 0; i < object.PtlsSupport.length; ++i)
                            message.PtlsSupport[i] = object.PtlsSupport[i] | 0;
                    }
                    if (object.PtlsNotSupport) {
                        if (!Array.isArray(object.PtlsNotSupport))
                            throw TypeError(".Msg.MsgField.ImMsgBody.PcSupportDef.PtlsNotSupport: array expected");
                        message.PtlsNotSupport = [];
                        for (var i = 0; i < object.PtlsNotSupport.length; ++i)
                            message.PtlsNotSupport[i] = object.PtlsNotSupport[i] | 0;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PcSupportDef message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.PcSupportDef} message PcSupportDef
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PcSupportDef.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.PtlsSupport = [];
                        object.PtlsNotSupport = [];
                    }
                    if (options.defaults) {
                        object.PcPtlBegin = 0;
                        object.PcPtlEnd = 0;
                        object.MacPtlBegin = 0;
                        object.MacPtlEnd = 0;
                    }
                    if (message.PcPtlBegin != null && message.hasOwnProperty("PcPtlBegin"))
                        object.PcPtlBegin = message.PcPtlBegin;
                    if (message.PcPtlEnd != null && message.hasOwnProperty("PcPtlEnd"))
                        object.PcPtlEnd = message.PcPtlEnd;
                    if (message.MacPtlBegin != null && message.hasOwnProperty("MacPtlBegin"))
                        object.MacPtlBegin = message.MacPtlBegin;
                    if (message.MacPtlEnd != null && message.hasOwnProperty("MacPtlEnd"))
                        object.MacPtlEnd = message.MacPtlEnd;
                    if (message.PtlsSupport && message.PtlsSupport.length) {
                        object.PtlsSupport = [];
                        for (var j = 0; j < message.PtlsSupport.length; ++j)
                            object.PtlsSupport[j] = message.PtlsSupport[j];
                    }
                    if (message.PtlsNotSupport && message.PtlsNotSupport.length) {
                        object.PtlsNotSupport = [];
                        for (var j = 0; j < message.PtlsNotSupport.length; ++j)
                            object.PtlsNotSupport[j] = message.PtlsNotSupport[j];
                    }
                    return object;
                };

                /**
                 * Converts this PcSupportDef to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.PcSupportDef
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PcSupportDef.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PcSupportDef;
            })();

            ImMsgBody.ElemFlags2 = (function() {

                /**
                 * Properties of an ElemFlags2.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IElemFlags2
                 * @property {number|null} [ColorTextId] ElemFlags2 ColorTextId
                 * @property {number|Long|null} [MsgId] ElemFlags2 MsgId
                 * @property {number|null} [WhisperSessionId] ElemFlags2 WhisperSessionId
                 * @property {number|null} [PttChangeBit] ElemFlags2 PttChangeBit
                 * @property {number|null} [VipStatus] ElemFlags2 VipStatus
                 * @property {number|null} [CompatibleId] ElemFlags2 CompatibleId
                 * @property {Array.<Msg.MsgField.ImMsgBody.IInst>|null} [Insts] ElemFlags2 Insts
                 * @property {number|null} [MsgRptCnt] ElemFlags2 MsgRptCnt
                 * @property {Msg.MsgField.ImMsgBody.IInst|null} [SrcInst] ElemFlags2 SrcInst
                 * @property {number|null} [Longtitude] ElemFlags2 Longtitude
                 * @property {number|null} [Latitude] ElemFlags2 Latitude
                 * @property {number|null} [CustomFont] ElemFlags2 CustomFont
                 * @property {Msg.MsgField.ImMsgBody.IPcSupportDef|null} [PcSupportDef] ElemFlags2 PcSupportDef
                 * @property {number|null} [CrmFlags] ElemFlags2 CrmFlags
                 */

                /**
                 * Constructs a new ElemFlags2.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an ElemFlags2.
                 * @implements IElemFlags2
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags2=} [properties] Properties to set
                 */
                function ElemFlags2(properties) {
                    this.Insts = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ElemFlags2 ColorTextId.
                 * @member {number} ColorTextId
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.ColorTextId = 0;

                /**
                 * ElemFlags2 MsgId.
                 * @member {number|Long} MsgId
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.MsgId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ElemFlags2 WhisperSessionId.
                 * @member {number} WhisperSessionId
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.WhisperSessionId = 0;

                /**
                 * ElemFlags2 PttChangeBit.
                 * @member {number} PttChangeBit
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.PttChangeBit = 0;

                /**
                 * ElemFlags2 VipStatus.
                 * @member {number} VipStatus
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.VipStatus = 0;

                /**
                 * ElemFlags2 CompatibleId.
                 * @member {number} CompatibleId
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.CompatibleId = 0;

                /**
                 * ElemFlags2 Insts.
                 * @member {Array.<Msg.MsgField.ImMsgBody.IInst>} Insts
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.Insts = $util.emptyArray;

                /**
                 * ElemFlags2 MsgRptCnt.
                 * @member {number} MsgRptCnt
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.MsgRptCnt = 0;

                /**
                 * ElemFlags2 SrcInst.
                 * @member {Msg.MsgField.ImMsgBody.IInst|null|undefined} SrcInst
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.SrcInst = null;

                /**
                 * ElemFlags2 Longtitude.
                 * @member {number} Longtitude
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.Longtitude = 0;

                /**
                 * ElemFlags2 Latitude.
                 * @member {number} Latitude
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.Latitude = 0;

                /**
                 * ElemFlags2 CustomFont.
                 * @member {number} CustomFont
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.CustomFont = 0;

                /**
                 * ElemFlags2 PcSupportDef.
                 * @member {Msg.MsgField.ImMsgBody.IPcSupportDef|null|undefined} PcSupportDef
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.PcSupportDef = null;

                /**
                 * ElemFlags2 CrmFlags.
                 * @member {number} CrmFlags
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 */
                ElemFlags2.prototype.CrmFlags = 0;

                /**
                 * Creates a new ElemFlags2 instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags2=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags2} ElemFlags2 instance
                 */
                ElemFlags2.create = function create(properties) {
                    return new ElemFlags2(properties);
                };

                /**
                 * Encodes the specified ElemFlags2 message. Does not implicitly {@link Msg.MsgField.ImMsgBody.ElemFlags2.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags2} message ElemFlags2 message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElemFlags2.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ColorTextId != null && Object.hasOwnProperty.call(message, "ColorTextId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ColorTextId);
                    if (message.MsgId != null && Object.hasOwnProperty.call(message, "MsgId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.MsgId);
                    if (message.WhisperSessionId != null && Object.hasOwnProperty.call(message, "WhisperSessionId"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.WhisperSessionId);
                    if (message.PttChangeBit != null && Object.hasOwnProperty.call(message, "PttChangeBit"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.PttChangeBit);
                    if (message.VipStatus != null && Object.hasOwnProperty.call(message, "VipStatus"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.VipStatus);
                    if (message.CompatibleId != null && Object.hasOwnProperty.call(message, "CompatibleId"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.CompatibleId);
                    if (message.Insts != null && message.Insts.length)
                        for (var i = 0; i < message.Insts.length; ++i)
                            $root.Msg.MsgField.ImMsgBody.Inst.encode(message.Insts[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.MsgRptCnt != null && Object.hasOwnProperty.call(message, "MsgRptCnt"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.MsgRptCnt);
                    if (message.SrcInst != null && Object.hasOwnProperty.call(message, "SrcInst"))
                        $root.Msg.MsgField.ImMsgBody.Inst.encode(message.SrcInst, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.Longtitude != null && Object.hasOwnProperty.call(message, "Longtitude"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Longtitude);
                    if (message.Latitude != null && Object.hasOwnProperty.call(message, "Latitude"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.Latitude);
                    if (message.CustomFont != null && Object.hasOwnProperty.call(message, "CustomFont"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.CustomFont);
                    if (message.PcSupportDef != null && Object.hasOwnProperty.call(message, "PcSupportDef"))
                        $root.Msg.MsgField.ImMsgBody.PcSupportDef.encode(message.PcSupportDef, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.CrmFlags != null && Object.hasOwnProperty.call(message, "CrmFlags"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.CrmFlags);
                    return writer;
                };

                /**
                 * Encodes the specified ElemFlags2 message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.ElemFlags2.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElemFlags2} message ElemFlags2 message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ElemFlags2.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ElemFlags2 message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags2} ElemFlags2
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElemFlags2.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.ElemFlags2();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ColorTextId = reader.int32();
                            break;
                        case 2:
                            message.MsgId = reader.int64();
                            break;
                        case 3:
                            message.WhisperSessionId = reader.int32();
                            break;
                        case 4:
                            message.PttChangeBit = reader.int32();
                            break;
                        case 5:
                            message.VipStatus = reader.int32();
                            break;
                        case 6:
                            message.CompatibleId = reader.int32();
                            break;
                        case 7:
                            if (!(message.Insts && message.Insts.length))
                                message.Insts = [];
                            message.Insts.push($root.Msg.MsgField.ImMsgBody.Inst.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.MsgRptCnt = reader.int32();
                            break;
                        case 9:
                            message.SrcInst = $root.Msg.MsgField.ImMsgBody.Inst.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.Longtitude = reader.int32();
                            break;
                        case 11:
                            message.Latitude = reader.int32();
                            break;
                        case 12:
                            message.CustomFont = reader.int32();
                            break;
                        case 13:
                            message.PcSupportDef = $root.Msg.MsgField.ImMsgBody.PcSupportDef.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.CrmFlags = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ElemFlags2 message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags2} ElemFlags2
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ElemFlags2.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ElemFlags2 message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ElemFlags2.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ColorTextId != null && message.hasOwnProperty("ColorTextId"))
                        if (!$util.isInteger(message.ColorTextId))
                            return "ColorTextId: integer expected";
                    if (message.MsgId != null && message.hasOwnProperty("MsgId"))
                        if (!$util.isInteger(message.MsgId) && !(message.MsgId && $util.isInteger(message.MsgId.low) && $util.isInteger(message.MsgId.high)))
                            return "MsgId: integer|Long expected";
                    if (message.WhisperSessionId != null && message.hasOwnProperty("WhisperSessionId"))
                        if (!$util.isInteger(message.WhisperSessionId))
                            return "WhisperSessionId: integer expected";
                    if (message.PttChangeBit != null && message.hasOwnProperty("PttChangeBit"))
                        if (!$util.isInteger(message.PttChangeBit))
                            return "PttChangeBit: integer expected";
                    if (message.VipStatus != null && message.hasOwnProperty("VipStatus"))
                        if (!$util.isInteger(message.VipStatus))
                            return "VipStatus: integer expected";
                    if (message.CompatibleId != null && message.hasOwnProperty("CompatibleId"))
                        if (!$util.isInteger(message.CompatibleId))
                            return "CompatibleId: integer expected";
                    if (message.Insts != null && message.hasOwnProperty("Insts")) {
                        if (!Array.isArray(message.Insts))
                            return "Insts: array expected";
                        for (var i = 0; i < message.Insts.length; ++i) {
                            var error = $root.Msg.MsgField.ImMsgBody.Inst.verify(message.Insts[i]);
                            if (error)
                                return "Insts." + error;
                        }
                    }
                    if (message.MsgRptCnt != null && message.hasOwnProperty("MsgRptCnt"))
                        if (!$util.isInteger(message.MsgRptCnt))
                            return "MsgRptCnt: integer expected";
                    if (message.SrcInst != null && message.hasOwnProperty("SrcInst")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Inst.verify(message.SrcInst);
                        if (error)
                            return "SrcInst." + error;
                    }
                    if (message.Longtitude != null && message.hasOwnProperty("Longtitude"))
                        if (!$util.isInteger(message.Longtitude))
                            return "Longtitude: integer expected";
                    if (message.Latitude != null && message.hasOwnProperty("Latitude"))
                        if (!$util.isInteger(message.Latitude))
                            return "Latitude: integer expected";
                    if (message.CustomFont != null && message.hasOwnProperty("CustomFont"))
                        if (!$util.isInteger(message.CustomFont))
                            return "CustomFont: integer expected";
                    if (message.PcSupportDef != null && message.hasOwnProperty("PcSupportDef")) {
                        var error = $root.Msg.MsgField.ImMsgBody.PcSupportDef.verify(message.PcSupportDef);
                        if (error)
                            return "PcSupportDef." + error;
                    }
                    if (message.CrmFlags != null && message.hasOwnProperty("CrmFlags"))
                        if (!$util.isInteger(message.CrmFlags))
                            return "CrmFlags: integer expected";
                    return null;
                };

                /**
                 * Creates an ElemFlags2 message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.ElemFlags2} ElemFlags2
                 */
                ElemFlags2.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.ElemFlags2)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.ElemFlags2();
                    if (object.ColorTextId != null)
                        message.ColorTextId = object.ColorTextId | 0;
                    if (object.MsgId != null)
                        if ($util.Long)
                            (message.MsgId = $util.Long.fromValue(object.MsgId)).unsigned = false;
                        else if (typeof object.MsgId === "string")
                            message.MsgId = parseInt(object.MsgId, 10);
                        else if (typeof object.MsgId === "number")
                            message.MsgId = object.MsgId;
                        else if (typeof object.MsgId === "object")
                            message.MsgId = new $util.LongBits(object.MsgId.low >>> 0, object.MsgId.high >>> 0).toNumber();
                    if (object.WhisperSessionId != null)
                        message.WhisperSessionId = object.WhisperSessionId | 0;
                    if (object.PttChangeBit != null)
                        message.PttChangeBit = object.PttChangeBit | 0;
                    if (object.VipStatus != null)
                        message.VipStatus = object.VipStatus | 0;
                    if (object.CompatibleId != null)
                        message.CompatibleId = object.CompatibleId | 0;
                    if (object.Insts) {
                        if (!Array.isArray(object.Insts))
                            throw TypeError(".Msg.MsgField.ImMsgBody.ElemFlags2.Insts: array expected");
                        message.Insts = [];
                        for (var i = 0; i < object.Insts.length; ++i) {
                            if (typeof object.Insts[i] !== "object")
                                throw TypeError(".Msg.MsgField.ImMsgBody.ElemFlags2.Insts: object expected");
                            message.Insts[i] = $root.Msg.MsgField.ImMsgBody.Inst.fromObject(object.Insts[i]);
                        }
                    }
                    if (object.MsgRptCnt != null)
                        message.MsgRptCnt = object.MsgRptCnt | 0;
                    if (object.SrcInst != null) {
                        if (typeof object.SrcInst !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.ElemFlags2.SrcInst: object expected");
                        message.SrcInst = $root.Msg.MsgField.ImMsgBody.Inst.fromObject(object.SrcInst);
                    }
                    if (object.Longtitude != null)
                        message.Longtitude = object.Longtitude | 0;
                    if (object.Latitude != null)
                        message.Latitude = object.Latitude | 0;
                    if (object.CustomFont != null)
                        message.CustomFont = object.CustomFont | 0;
                    if (object.PcSupportDef != null) {
                        if (typeof object.PcSupportDef !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.ElemFlags2.PcSupportDef: object expected");
                        message.PcSupportDef = $root.Msg.MsgField.ImMsgBody.PcSupportDef.fromObject(object.PcSupportDef);
                    }
                    if (object.CrmFlags != null)
                        message.CrmFlags = object.CrmFlags | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ElemFlags2 message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ElemFlags2} message ElemFlags2
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ElemFlags2.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.Insts = [];
                    if (options.defaults) {
                        object.ColorTextId = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.MsgId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.MsgId = options.longs === String ? "0" : 0;
                        object.WhisperSessionId = 0;
                        object.PttChangeBit = 0;
                        object.VipStatus = 0;
                        object.CompatibleId = 0;
                        object.MsgRptCnt = 0;
                        object.SrcInst = null;
                        object.Longtitude = 0;
                        object.Latitude = 0;
                        object.CustomFont = 0;
                        object.PcSupportDef = null;
                        object.CrmFlags = 0;
                    }
                    if (message.ColorTextId != null && message.hasOwnProperty("ColorTextId"))
                        object.ColorTextId = message.ColorTextId;
                    if (message.MsgId != null && message.hasOwnProperty("MsgId"))
                        if (typeof message.MsgId === "number")
                            object.MsgId = options.longs === String ? String(message.MsgId) : message.MsgId;
                        else
                            object.MsgId = options.longs === String ? $util.Long.prototype.toString.call(message.MsgId) : options.longs === Number ? new $util.LongBits(message.MsgId.low >>> 0, message.MsgId.high >>> 0).toNumber() : message.MsgId;
                    if (message.WhisperSessionId != null && message.hasOwnProperty("WhisperSessionId"))
                        object.WhisperSessionId = message.WhisperSessionId;
                    if (message.PttChangeBit != null && message.hasOwnProperty("PttChangeBit"))
                        object.PttChangeBit = message.PttChangeBit;
                    if (message.VipStatus != null && message.hasOwnProperty("VipStatus"))
                        object.VipStatus = message.VipStatus;
                    if (message.CompatibleId != null && message.hasOwnProperty("CompatibleId"))
                        object.CompatibleId = message.CompatibleId;
                    if (message.Insts && message.Insts.length) {
                        object.Insts = [];
                        for (var j = 0; j < message.Insts.length; ++j)
                            object.Insts[j] = $root.Msg.MsgField.ImMsgBody.Inst.toObject(message.Insts[j], options);
                    }
                    if (message.MsgRptCnt != null && message.hasOwnProperty("MsgRptCnt"))
                        object.MsgRptCnt = message.MsgRptCnt;
                    if (message.SrcInst != null && message.hasOwnProperty("SrcInst"))
                        object.SrcInst = $root.Msg.MsgField.ImMsgBody.Inst.toObject(message.SrcInst, options);
                    if (message.Longtitude != null && message.hasOwnProperty("Longtitude"))
                        object.Longtitude = message.Longtitude;
                    if (message.Latitude != null && message.hasOwnProperty("Latitude"))
                        object.Latitude = message.Latitude;
                    if (message.CustomFont != null && message.hasOwnProperty("CustomFont"))
                        object.CustomFont = message.CustomFont;
                    if (message.PcSupportDef != null && message.hasOwnProperty("PcSupportDef"))
                        object.PcSupportDef = $root.Msg.MsgField.ImMsgBody.PcSupportDef.toObject(message.PcSupportDef, options);
                    if (message.CrmFlags != null && message.hasOwnProperty("CrmFlags"))
                        object.CrmFlags = message.CrmFlags;
                    return object;
                };

                /**
                 * Converts this ElemFlags2 to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.ElemFlags2
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ElemFlags2.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ElemFlags2;
            })();

            ImMsgBody.Turntable = (function() {

                /**
                 * Properties of a Turntable.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ITurntable
                 * @property {Array.<number|Long>|null} [Uint64UinList] Turntable Uint64UinList
                 * @property {number|Long|null} [HitUin] Turntable HitUin
                 * @property {string|null} [HitUinNick] Turntable HitUinNick
                 */

                /**
                 * Constructs a new Turntable.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a Turntable.
                 * @implements ITurntable
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ITurntable=} [properties] Properties to set
                 */
                function Turntable(properties) {
                    this.Uint64UinList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Turntable Uint64UinList.
                 * @member {Array.<number|Long>} Uint64UinList
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @instance
                 */
                Turntable.prototype.Uint64UinList = $util.emptyArray;

                /**
                 * Turntable HitUin.
                 * @member {number|Long} HitUin
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @instance
                 */
                Turntable.prototype.HitUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Turntable HitUinNick.
                 * @member {string} HitUinNick
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @instance
                 */
                Turntable.prototype.HitUinNick = "";

                /**
                 * Creates a new Turntable instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITurntable=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Turntable} Turntable instance
                 */
                Turntable.create = function create(properties) {
                    return new Turntable(properties);
                };

                /**
                 * Encodes the specified Turntable message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Turntable.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITurntable} message Turntable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Turntable.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Uint64UinList != null && message.Uint64UinList.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.Uint64UinList.length; ++i)
                            writer.int64(message.Uint64UinList[i]);
                        writer.ldelim();
                    }
                    if (message.HitUin != null && Object.hasOwnProperty.call(message, "HitUin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.HitUin);
                    if (message.HitUinNick != null && Object.hasOwnProperty.call(message, "HitUinNick"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.HitUinNick);
                    return writer;
                };

                /**
                 * Encodes the specified Turntable message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Turntable.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITurntable} message Turntable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Turntable.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Turntable message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Turntable} Turntable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Turntable.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Turntable();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.Uint64UinList && message.Uint64UinList.length))
                                message.Uint64UinList = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.Uint64UinList.push(reader.int64());
                            } else
                                message.Uint64UinList.push(reader.int64());
                            break;
                        case 2:
                            message.HitUin = reader.int64();
                            break;
                        case 3:
                            message.HitUinNick = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Turntable message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Turntable} Turntable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Turntable.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Turntable message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Turntable.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Uint64UinList != null && message.hasOwnProperty("Uint64UinList")) {
                        if (!Array.isArray(message.Uint64UinList))
                            return "Uint64UinList: array expected";
                        for (var i = 0; i < message.Uint64UinList.length; ++i)
                            if (!$util.isInteger(message.Uint64UinList[i]) && !(message.Uint64UinList[i] && $util.isInteger(message.Uint64UinList[i].low) && $util.isInteger(message.Uint64UinList[i].high)))
                                return "Uint64UinList: integer|Long[] expected";
                    }
                    if (message.HitUin != null && message.hasOwnProperty("HitUin"))
                        if (!$util.isInteger(message.HitUin) && !(message.HitUin && $util.isInteger(message.HitUin.low) && $util.isInteger(message.HitUin.high)))
                            return "HitUin: integer|Long expected";
                    if (message.HitUinNick != null && message.hasOwnProperty("HitUinNick"))
                        if (!$util.isString(message.HitUinNick))
                            return "HitUinNick: string expected";
                    return null;
                };

                /**
                 * Creates a Turntable message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Turntable} Turntable
                 */
                Turntable.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Turntable)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Turntable();
                    if (object.Uint64UinList) {
                        if (!Array.isArray(object.Uint64UinList))
                            throw TypeError(".Msg.MsgField.ImMsgBody.Turntable.Uint64UinList: array expected");
                        message.Uint64UinList = [];
                        for (var i = 0; i < object.Uint64UinList.length; ++i)
                            if ($util.Long)
                                (message.Uint64UinList[i] = $util.Long.fromValue(object.Uint64UinList[i])).unsigned = false;
                            else if (typeof object.Uint64UinList[i] === "string")
                                message.Uint64UinList[i] = parseInt(object.Uint64UinList[i], 10);
                            else if (typeof object.Uint64UinList[i] === "number")
                                message.Uint64UinList[i] = object.Uint64UinList[i];
                            else if (typeof object.Uint64UinList[i] === "object")
                                message.Uint64UinList[i] = new $util.LongBits(object.Uint64UinList[i].low >>> 0, object.Uint64UinList[i].high >>> 0).toNumber();
                    }
                    if (object.HitUin != null)
                        if ($util.Long)
                            (message.HitUin = $util.Long.fromValue(object.HitUin)).unsigned = false;
                        else if (typeof object.HitUin === "string")
                            message.HitUin = parseInt(object.HitUin, 10);
                        else if (typeof object.HitUin === "number")
                            message.HitUin = object.HitUin;
                        else if (typeof object.HitUin === "object")
                            message.HitUin = new $util.LongBits(object.HitUin.low >>> 0, object.HitUin.high >>> 0).toNumber();
                    if (object.HitUinNick != null)
                        message.HitUinNick = String(object.HitUinNick);
                    return message;
                };

                /**
                 * Creates a plain object from a Turntable message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Turntable} message Turntable
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Turntable.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.Uint64UinList = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.HitUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.HitUin = options.longs === String ? "0" : 0;
                        object.HitUinNick = "";
                    }
                    if (message.Uint64UinList && message.Uint64UinList.length) {
                        object.Uint64UinList = [];
                        for (var j = 0; j < message.Uint64UinList.length; ++j)
                            if (typeof message.Uint64UinList[j] === "number")
                                object.Uint64UinList[j] = options.longs === String ? String(message.Uint64UinList[j]) : message.Uint64UinList[j];
                            else
                                object.Uint64UinList[j] = options.longs === String ? $util.Long.prototype.toString.call(message.Uint64UinList[j]) : options.longs === Number ? new $util.LongBits(message.Uint64UinList[j].low >>> 0, message.Uint64UinList[j].high >>> 0).toNumber() : message.Uint64UinList[j];
                    }
                    if (message.HitUin != null && message.hasOwnProperty("HitUin"))
                        if (typeof message.HitUin === "number")
                            object.HitUin = options.longs === String ? String(message.HitUin) : message.HitUin;
                        else
                            object.HitUin = options.longs === String ? $util.Long.prototype.toString.call(message.HitUin) : options.longs === Number ? new $util.LongBits(message.HitUin.low >>> 0, message.HitUin.high >>> 0).toNumber() : message.HitUin;
                    if (message.HitUinNick != null && message.hasOwnProperty("HitUinNick"))
                        object.HitUinNick = message.HitUinNick;
                    return object;
                };

                /**
                 * Converts this Turntable to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Turntable
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Turntable.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Turntable;
            })();

            ImMsgBody.Bomb = (function() {

                /**
                 * Properties of a Bomb.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IBomb
                 * @property {boolean|null} [BoolBurst] Bomb BoolBurst
                 */

                /**
                 * Constructs a new Bomb.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a Bomb.
                 * @implements IBomb
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IBomb=} [properties] Properties to set
                 */
                function Bomb(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Bomb BoolBurst.
                 * @member {boolean} BoolBurst
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @instance
                 */
                Bomb.prototype.BoolBurst = false;

                /**
                 * Creates a new Bomb instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBomb=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Bomb} Bomb instance
                 */
                Bomb.create = function create(properties) {
                    return new Bomb(properties);
                };

                /**
                 * Encodes the specified Bomb message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Bomb.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBomb} message Bomb message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bomb.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.BoolBurst != null && Object.hasOwnProperty.call(message, "BoolBurst"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.BoolBurst);
                    return writer;
                };

                /**
                 * Encodes the specified Bomb message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Bomb.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBomb} message Bomb message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bomb.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Bomb message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Bomb} Bomb
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bomb.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Bomb();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.BoolBurst = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Bomb message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Bomb} Bomb
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bomb.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Bomb message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Bomb.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.BoolBurst != null && message.hasOwnProperty("BoolBurst"))
                        if (typeof message.BoolBurst !== "boolean")
                            return "BoolBurst: boolean expected";
                    return null;
                };

                /**
                 * Creates a Bomb message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Bomb} Bomb
                 */
                Bomb.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Bomb)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Bomb();
                    if (object.BoolBurst != null)
                        message.BoolBurst = Boolean(object.BoolBurst);
                    return message;
                };

                /**
                 * Creates a plain object from a Bomb message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Bomb} message Bomb
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Bomb.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.BoolBurst = false;
                    if (message.BoolBurst != null && message.hasOwnProperty("BoolBurst"))
                        object.BoolBurst = message.BoolBurst;
                    return object;
                };

                /**
                 * Converts this Bomb to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Bomb
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Bomb.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Bomb;
            })();

            ImMsgBody.FunFace = (function() {

                /**
                 * Properties of a FunFace.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IFunFace
                 * @property {Msg.MsgField.ImMsgBody.ITurntable|null} [MsgTurntable] FunFace MsgTurntable
                 * @property {Msg.MsgField.ImMsgBody.IBomb|null} [MsgBomb] FunFace MsgBomb
                 */

                /**
                 * Constructs a new FunFace.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a FunFace.
                 * @implements IFunFace
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IFunFace=} [properties] Properties to set
                 */
                function FunFace(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FunFace MsgTurntable.
                 * @member {Msg.MsgField.ImMsgBody.ITurntable|null|undefined} MsgTurntable
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @instance
                 */
                FunFace.prototype.MsgTurntable = null;

                /**
                 * FunFace MsgBomb.
                 * @member {Msg.MsgField.ImMsgBody.IBomb|null|undefined} MsgBomb
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @instance
                 */
                FunFace.prototype.MsgBomb = null;

                /**
                 * Creates a new FunFace instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFunFace=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.FunFace} FunFace instance
                 */
                FunFace.create = function create(properties) {
                    return new FunFace(properties);
                };

                /**
                 * Encodes the specified FunFace message. Does not implicitly {@link Msg.MsgField.ImMsgBody.FunFace.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFunFace} message FunFace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FunFace.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MsgTurntable != null && Object.hasOwnProperty.call(message, "MsgTurntable"))
                        $root.Msg.MsgField.ImMsgBody.Turntable.encode(message.MsgTurntable, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.MsgBomb != null && Object.hasOwnProperty.call(message, "MsgBomb"))
                        $root.Msg.MsgField.ImMsgBody.Bomb.encode(message.MsgBomb, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified FunFace message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.FunFace.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFunFace} message FunFace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FunFace.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FunFace message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.FunFace} FunFace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FunFace.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.FunFace();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.MsgTurntable = $root.Msg.MsgField.ImMsgBody.Turntable.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.MsgBomb = $root.Msg.MsgField.ImMsgBody.Bomb.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FunFace message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.FunFace} FunFace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FunFace.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FunFace message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FunFace.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MsgTurntable != null && message.hasOwnProperty("MsgTurntable")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Turntable.verify(message.MsgTurntable);
                        if (error)
                            return "MsgTurntable." + error;
                    }
                    if (message.MsgBomb != null && message.hasOwnProperty("MsgBomb")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Bomb.verify(message.MsgBomb);
                        if (error)
                            return "MsgBomb." + error;
                    }
                    return null;
                };

                /**
                 * Creates a FunFace message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.FunFace} FunFace
                 */
                FunFace.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.FunFace)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.FunFace();
                    if (object.MsgTurntable != null) {
                        if (typeof object.MsgTurntable !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.FunFace.MsgTurntable: object expected");
                        message.MsgTurntable = $root.Msg.MsgField.ImMsgBody.Turntable.fromObject(object.MsgTurntable);
                    }
                    if (object.MsgBomb != null) {
                        if (typeof object.MsgBomb !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.FunFace.MsgBomb: object expected");
                        message.MsgBomb = $root.Msg.MsgField.ImMsgBody.Bomb.fromObject(object.MsgBomb);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FunFace message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.FunFace} message FunFace
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FunFace.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.MsgTurntable = null;
                        object.MsgBomb = null;
                    }
                    if (message.MsgTurntable != null && message.hasOwnProperty("MsgTurntable"))
                        object.MsgTurntable = $root.Msg.MsgField.ImMsgBody.Turntable.toObject(message.MsgTurntable, options);
                    if (message.MsgBomb != null && message.hasOwnProperty("MsgBomb"))
                        object.MsgBomb = $root.Msg.MsgField.ImMsgBody.Bomb.toObject(message.MsgBomb, options);
                    return object;
                };

                /**
                 * Converts this FunFace to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.FunFace
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FunFace.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FunFace;
            })();

            ImMsgBody.SecretFileMsg = (function() {

                /**
                 * Properties of a SecretFileMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ISecretFileMsg
                 * @property {boolean|null} [FileKey] SecretFileMsg FileKey
                 * @property {number|Long|null} [FromUin] SecretFileMsg FromUin
                 * @property {number|Long|null} [ToUin] SecretFileMsg ToUin
                 * @property {number|null} [Status] SecretFileMsg Status
                 * @property {number|null} [Ttl] SecretFileMsg Ttl
                 * @property {number|null} [Type] SecretFileMsg Type
                 * @property {number|null} [EncryptPreheadLength] SecretFileMsg EncryptPreheadLength
                 * @property {number|null} [EncryptType] SecretFileMsg EncryptType
                 * @property {Uint8Array|null} [EncryptKey] SecretFileMsg EncryptKey
                 * @property {number|null} [ReadTimes] SecretFileMsg ReadTimes
                 * @property {number|null} [LeftTime] SecretFileMsg LeftTime
                 * @property {Msg.MsgField.ImMsgBody.INotOnlineImage|null} [NotOnlineImage] SecretFileMsg NotOnlineImage
                 * @property {Msg.MsgField.ImMsgBody.IElemFlags2|null} [ElemFlags2] SecretFileMsg ElemFlags2
                 * @property {number|null} [Opertype] SecretFileMsg Opertype
                 * @property {string|null} [Fromphonenum] SecretFileMsg Fromphonenum
                 */

                /**
                 * Constructs a new SecretFileMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a SecretFileMsg.
                 * @implements ISecretFileMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ISecretFileMsg=} [properties] Properties to set
                 */
                function SecretFileMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SecretFileMsg FileKey.
                 * @member {boolean} FileKey
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.FileKey = false;

                /**
                 * SecretFileMsg FromUin.
                 * @member {number|Long} FromUin
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.FromUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SecretFileMsg ToUin.
                 * @member {number|Long} ToUin
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SecretFileMsg Status.
                 * @member {number} Status
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.Status = 0;

                /**
                 * SecretFileMsg Ttl.
                 * @member {number} Ttl
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.Ttl = 0;

                /**
                 * SecretFileMsg Type.
                 * @member {number} Type
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.Type = 0;

                /**
                 * SecretFileMsg EncryptPreheadLength.
                 * @member {number} EncryptPreheadLength
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.EncryptPreheadLength = 0;

                /**
                 * SecretFileMsg EncryptType.
                 * @member {number} EncryptType
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.EncryptType = 0;

                /**
                 * SecretFileMsg EncryptKey.
                 * @member {Uint8Array} EncryptKey
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.EncryptKey = $util.newBuffer([]);

                /**
                 * SecretFileMsg ReadTimes.
                 * @member {number} ReadTimes
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.ReadTimes = 0;

                /**
                 * SecretFileMsg LeftTime.
                 * @member {number} LeftTime
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.LeftTime = 0;

                /**
                 * SecretFileMsg NotOnlineImage.
                 * @member {Msg.MsgField.ImMsgBody.INotOnlineImage|null|undefined} NotOnlineImage
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.NotOnlineImage = null;

                /**
                 * SecretFileMsg ElemFlags2.
                 * @member {Msg.MsgField.ImMsgBody.IElemFlags2|null|undefined} ElemFlags2
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.ElemFlags2 = null;

                /**
                 * SecretFileMsg Opertype.
                 * @member {number} Opertype
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.Opertype = 0;

                /**
                 * SecretFileMsg Fromphonenum.
                 * @member {string} Fromphonenum
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 */
                SecretFileMsg.prototype.Fromphonenum = "";

                /**
                 * Creates a new SecretFileMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISecretFileMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.SecretFileMsg} SecretFileMsg instance
                 */
                SecretFileMsg.create = function create(properties) {
                    return new SecretFileMsg(properties);
                };

                /**
                 * Encodes the specified SecretFileMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.SecretFileMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISecretFileMsg} message SecretFileMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SecretFileMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FileKey != null && Object.hasOwnProperty.call(message, "FileKey"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.FileKey);
                    if (message.FromUin != null && Object.hasOwnProperty.call(message, "FromUin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.FromUin);
                    if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ToUin);
                    if (message.Status != null && Object.hasOwnProperty.call(message, "Status"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Status);
                    if (message.Ttl != null && Object.hasOwnProperty.call(message, "Ttl"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Ttl);
                    if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Type);
                    if (message.EncryptPreheadLength != null && Object.hasOwnProperty.call(message, "EncryptPreheadLength"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.EncryptPreheadLength);
                    if (message.EncryptType != null && Object.hasOwnProperty.call(message, "EncryptType"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.EncryptType);
                    if (message.EncryptKey != null && Object.hasOwnProperty.call(message, "EncryptKey"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.EncryptKey);
                    if (message.ReadTimes != null && Object.hasOwnProperty.call(message, "ReadTimes"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.ReadTimes);
                    if (message.LeftTime != null && Object.hasOwnProperty.call(message, "LeftTime"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.LeftTime);
                    if (message.NotOnlineImage != null && Object.hasOwnProperty.call(message, "NotOnlineImage"))
                        $root.Msg.MsgField.ImMsgBody.NotOnlineImage.encode(message.NotOnlineImage, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.ElemFlags2 != null && Object.hasOwnProperty.call(message, "ElemFlags2"))
                        $root.Msg.MsgField.ImMsgBody.ElemFlags2.encode(message.ElemFlags2, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.Opertype != null && Object.hasOwnProperty.call(message, "Opertype"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.Opertype);
                    if (message.Fromphonenum != null && Object.hasOwnProperty.call(message, "Fromphonenum"))
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.Fromphonenum);
                    return writer;
                };

                /**
                 * Encodes the specified SecretFileMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.SecretFileMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISecretFileMsg} message SecretFileMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SecretFileMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SecretFileMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.SecretFileMsg} SecretFileMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SecretFileMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.SecretFileMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.FileKey = reader.bool();
                            break;
                        case 2:
                            message.FromUin = reader.int64();
                            break;
                        case 3:
                            message.ToUin = reader.int64();
                            break;
                        case 4:
                            message.Status = reader.int32();
                            break;
                        case 5:
                            message.Ttl = reader.int32();
                            break;
                        case 6:
                            message.Type = reader.int32();
                            break;
                        case 7:
                            message.EncryptPreheadLength = reader.int32();
                            break;
                        case 8:
                            message.EncryptType = reader.int32();
                            break;
                        case 9:
                            message.EncryptKey = reader.bytes();
                            break;
                        case 10:
                            message.ReadTimes = reader.int32();
                            break;
                        case 11:
                            message.LeftTime = reader.int32();
                            break;
                        case 12:
                            message.NotOnlineImage = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.ElemFlags2 = $root.Msg.MsgField.ImMsgBody.ElemFlags2.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.Opertype = reader.int32();
                            break;
                        case 15:
                            message.Fromphonenum = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SecretFileMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.SecretFileMsg} SecretFileMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SecretFileMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SecretFileMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SecretFileMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FileKey != null && message.hasOwnProperty("FileKey"))
                        if (typeof message.FileKey !== "boolean")
                            return "FileKey: boolean expected";
                    if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                        if (!$util.isInteger(message.FromUin) && !(message.FromUin && $util.isInteger(message.FromUin.low) && $util.isInteger(message.FromUin.high)))
                            return "FromUin: integer|Long expected";
                    if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                        if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                            return "ToUin: integer|Long expected";
                    if (message.Status != null && message.hasOwnProperty("Status"))
                        if (!$util.isInteger(message.Status))
                            return "Status: integer expected";
                    if (message.Ttl != null && message.hasOwnProperty("Ttl"))
                        if (!$util.isInteger(message.Ttl))
                            return "Ttl: integer expected";
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        if (!$util.isInteger(message.Type))
                            return "Type: integer expected";
                    if (message.EncryptPreheadLength != null && message.hasOwnProperty("EncryptPreheadLength"))
                        if (!$util.isInteger(message.EncryptPreheadLength))
                            return "EncryptPreheadLength: integer expected";
                    if (message.EncryptType != null && message.hasOwnProperty("EncryptType"))
                        if (!$util.isInteger(message.EncryptType))
                            return "EncryptType: integer expected";
                    if (message.EncryptKey != null && message.hasOwnProperty("EncryptKey"))
                        if (!(message.EncryptKey && typeof message.EncryptKey.length === "number" || $util.isString(message.EncryptKey)))
                            return "EncryptKey: buffer expected";
                    if (message.ReadTimes != null && message.hasOwnProperty("ReadTimes"))
                        if (!$util.isInteger(message.ReadTimes))
                            return "ReadTimes: integer expected";
                    if (message.LeftTime != null && message.hasOwnProperty("LeftTime"))
                        if (!$util.isInteger(message.LeftTime))
                            return "LeftTime: integer expected";
                    if (message.NotOnlineImage != null && message.hasOwnProperty("NotOnlineImage")) {
                        var error = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.verify(message.NotOnlineImage);
                        if (error)
                            return "NotOnlineImage." + error;
                    }
                    if (message.ElemFlags2 != null && message.hasOwnProperty("ElemFlags2")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ElemFlags2.verify(message.ElemFlags2);
                        if (error)
                            return "ElemFlags2." + error;
                    }
                    if (message.Opertype != null && message.hasOwnProperty("Opertype"))
                        if (!$util.isInteger(message.Opertype))
                            return "Opertype: integer expected";
                    if (message.Fromphonenum != null && message.hasOwnProperty("Fromphonenum"))
                        if (!$util.isString(message.Fromphonenum))
                            return "Fromphonenum: string expected";
                    return null;
                };

                /**
                 * Creates a SecretFileMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.SecretFileMsg} SecretFileMsg
                 */
                SecretFileMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.SecretFileMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.SecretFileMsg();
                    if (object.FileKey != null)
                        message.FileKey = Boolean(object.FileKey);
                    if (object.FromUin != null)
                        if ($util.Long)
                            (message.FromUin = $util.Long.fromValue(object.FromUin)).unsigned = false;
                        else if (typeof object.FromUin === "string")
                            message.FromUin = parseInt(object.FromUin, 10);
                        else if (typeof object.FromUin === "number")
                            message.FromUin = object.FromUin;
                        else if (typeof object.FromUin === "object")
                            message.FromUin = new $util.LongBits(object.FromUin.low >>> 0, object.FromUin.high >>> 0).toNumber();
                    if (object.ToUin != null)
                        if ($util.Long)
                            (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                        else if (typeof object.ToUin === "string")
                            message.ToUin = parseInt(object.ToUin, 10);
                        else if (typeof object.ToUin === "number")
                            message.ToUin = object.ToUin;
                        else if (typeof object.ToUin === "object")
                            message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                    if (object.Status != null)
                        message.Status = object.Status | 0;
                    if (object.Ttl != null)
                        message.Ttl = object.Ttl | 0;
                    if (object.Type != null)
                        message.Type = object.Type | 0;
                    if (object.EncryptPreheadLength != null)
                        message.EncryptPreheadLength = object.EncryptPreheadLength | 0;
                    if (object.EncryptType != null)
                        message.EncryptType = object.EncryptType | 0;
                    if (object.EncryptKey != null)
                        if (typeof object.EncryptKey === "string")
                            $util.base64.decode(object.EncryptKey, message.EncryptKey = $util.newBuffer($util.base64.length(object.EncryptKey)), 0);
                        else if (object.EncryptKey.length)
                            message.EncryptKey = object.EncryptKey;
                    if (object.ReadTimes != null)
                        message.ReadTimes = object.ReadTimes | 0;
                    if (object.LeftTime != null)
                        message.LeftTime = object.LeftTime | 0;
                    if (object.NotOnlineImage != null) {
                        if (typeof object.NotOnlineImage !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.SecretFileMsg.NotOnlineImage: object expected");
                        message.NotOnlineImage = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.fromObject(object.NotOnlineImage);
                    }
                    if (object.ElemFlags2 != null) {
                        if (typeof object.ElemFlags2 !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.SecretFileMsg.ElemFlags2: object expected");
                        message.ElemFlags2 = $root.Msg.MsgField.ImMsgBody.ElemFlags2.fromObject(object.ElemFlags2);
                    }
                    if (object.Opertype != null)
                        message.Opertype = object.Opertype | 0;
                    if (object.Fromphonenum != null)
                        message.Fromphonenum = String(object.Fromphonenum);
                    return message;
                };

                /**
                 * Creates a plain object from a SecretFileMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.SecretFileMsg} message SecretFileMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SecretFileMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.FileKey = false;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.FromUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.FromUin = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.ToUin = options.longs === String ? "0" : 0;
                        object.Status = 0;
                        object.Ttl = 0;
                        object.Type = 0;
                        object.EncryptPreheadLength = 0;
                        object.EncryptType = 0;
                        if (options.bytes === String)
                            object.EncryptKey = "";
                        else {
                            object.EncryptKey = [];
                            if (options.bytes !== Array)
                                object.EncryptKey = $util.newBuffer(object.EncryptKey);
                        }
                        object.ReadTimes = 0;
                        object.LeftTime = 0;
                        object.NotOnlineImage = null;
                        object.ElemFlags2 = null;
                        object.Opertype = 0;
                        object.Fromphonenum = "";
                    }
                    if (message.FileKey != null && message.hasOwnProperty("FileKey"))
                        object.FileKey = message.FileKey;
                    if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                        if (typeof message.FromUin === "number")
                            object.FromUin = options.longs === String ? String(message.FromUin) : message.FromUin;
                        else
                            object.FromUin = options.longs === String ? $util.Long.prototype.toString.call(message.FromUin) : options.longs === Number ? new $util.LongBits(message.FromUin.low >>> 0, message.FromUin.high >>> 0).toNumber() : message.FromUin;
                    if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                        if (typeof message.ToUin === "number")
                            object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                        else
                            object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                    if (message.Status != null && message.hasOwnProperty("Status"))
                        object.Status = message.Status;
                    if (message.Ttl != null && message.hasOwnProperty("Ttl"))
                        object.Ttl = message.Ttl;
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    if (message.EncryptPreheadLength != null && message.hasOwnProperty("EncryptPreheadLength"))
                        object.EncryptPreheadLength = message.EncryptPreheadLength;
                    if (message.EncryptType != null && message.hasOwnProperty("EncryptType"))
                        object.EncryptType = message.EncryptType;
                    if (message.EncryptKey != null && message.hasOwnProperty("EncryptKey"))
                        object.EncryptKey = options.bytes === String ? $util.base64.encode(message.EncryptKey, 0, message.EncryptKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.EncryptKey) : message.EncryptKey;
                    if (message.ReadTimes != null && message.hasOwnProperty("ReadTimes"))
                        object.ReadTimes = message.ReadTimes;
                    if (message.LeftTime != null && message.hasOwnProperty("LeftTime"))
                        object.LeftTime = message.LeftTime;
                    if (message.NotOnlineImage != null && message.hasOwnProperty("NotOnlineImage"))
                        object.NotOnlineImage = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.toObject(message.NotOnlineImage, options);
                    if (message.ElemFlags2 != null && message.hasOwnProperty("ElemFlags2"))
                        object.ElemFlags2 = $root.Msg.MsgField.ImMsgBody.ElemFlags2.toObject(message.ElemFlags2, options);
                    if (message.Opertype != null && message.hasOwnProperty("Opertype"))
                        object.Opertype = message.Opertype;
                    if (message.Fromphonenum != null && message.hasOwnProperty("Fromphonenum"))
                        object.Fromphonenum = message.Fromphonenum;
                    return object;
                };

                /**
                 * Converts this SecretFileMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.SecretFileMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SecretFileMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SecretFileMsg;
            })();

            ImMsgBody.RichMsg = (function() {

                /**
                 * Properties of a RichMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IRichMsg
                 * @property {Uint8Array|null} [Template] RichMsg Template
                 * @property {number|null} [ServiceId] RichMsg ServiceId
                 * @property {Uint8Array|null} [MsgResid] RichMsg MsgResid
                 * @property {number|null} [Rand] RichMsg Rand
                 * @property {number|null} [Seq] RichMsg Seq
                 * @property {number|null} [Flags] RichMsg Flags
                 */

                /**
                 * Constructs a new RichMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a RichMsg.
                 * @implements IRichMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IRichMsg=} [properties] Properties to set
                 */
                function RichMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RichMsg Template.
                 * @member {Uint8Array} Template
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @instance
                 */
                RichMsg.prototype.Template = $util.newBuffer([]);

                /**
                 * RichMsg ServiceId.
                 * @member {number} ServiceId
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @instance
                 */
                RichMsg.prototype.ServiceId = 0;

                /**
                 * RichMsg MsgResid.
                 * @member {Uint8Array} MsgResid
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @instance
                 */
                RichMsg.prototype.MsgResid = $util.newBuffer([]);

                /**
                 * RichMsg Rand.
                 * @member {number} Rand
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @instance
                 */
                RichMsg.prototype.Rand = 0;

                /**
                 * RichMsg Seq.
                 * @member {number} Seq
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @instance
                 */
                RichMsg.prototype.Seq = 0;

                /**
                 * RichMsg Flags.
                 * @member {number} Flags
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @instance
                 */
                RichMsg.prototype.Flags = 0;

                /**
                 * Creates a new RichMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRichMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.RichMsg} RichMsg instance
                 */
                RichMsg.create = function create(properties) {
                    return new RichMsg(properties);
                };

                /**
                 * Encodes the specified RichMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.RichMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRichMsg} message RichMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Template != null && Object.hasOwnProperty.call(message, "Template"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Template);
                    if (message.ServiceId != null && Object.hasOwnProperty.call(message, "ServiceId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ServiceId);
                    if (message.MsgResid != null && Object.hasOwnProperty.call(message, "MsgResid"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.MsgResid);
                    if (message.Rand != null && Object.hasOwnProperty.call(message, "Rand"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Rand);
                    if (message.Seq != null && Object.hasOwnProperty.call(message, "Seq"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Seq);
                    if (message.Flags != null && Object.hasOwnProperty.call(message, "Flags"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Flags);
                    return writer;
                };

                /**
                 * Encodes the specified RichMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.RichMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRichMsg} message RichMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RichMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.RichMsg} RichMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.RichMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Template = reader.bytes();
                            break;
                        case 2:
                            message.ServiceId = reader.int32();
                            break;
                        case 3:
                            message.MsgResid = reader.bytes();
                            break;
                        case 4:
                            message.Rand = reader.int32();
                            break;
                        case 5:
                            message.Seq = reader.int32();
                            break;
                        case 6:
                            message.Flags = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RichMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.RichMsg} RichMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RichMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RichMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Template != null && message.hasOwnProperty("Template"))
                        if (!(message.Template && typeof message.Template.length === "number" || $util.isString(message.Template)))
                            return "Template: buffer expected";
                    if (message.ServiceId != null && message.hasOwnProperty("ServiceId"))
                        if (!$util.isInteger(message.ServiceId))
                            return "ServiceId: integer expected";
                    if (message.MsgResid != null && message.hasOwnProperty("MsgResid"))
                        if (!(message.MsgResid && typeof message.MsgResid.length === "number" || $util.isString(message.MsgResid)))
                            return "MsgResid: buffer expected";
                    if (message.Rand != null && message.hasOwnProperty("Rand"))
                        if (!$util.isInteger(message.Rand))
                            return "Rand: integer expected";
                    if (message.Seq != null && message.hasOwnProperty("Seq"))
                        if (!$util.isInteger(message.Seq))
                            return "Seq: integer expected";
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        if (!$util.isInteger(message.Flags))
                            return "Flags: integer expected";
                    return null;
                };

                /**
                 * Creates a RichMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.RichMsg} RichMsg
                 */
                RichMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.RichMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.RichMsg();
                    if (object.Template != null)
                        if (typeof object.Template === "string")
                            $util.base64.decode(object.Template, message.Template = $util.newBuffer($util.base64.length(object.Template)), 0);
                        else if (object.Template.length)
                            message.Template = object.Template;
                    if (object.ServiceId != null)
                        message.ServiceId = object.ServiceId | 0;
                    if (object.MsgResid != null)
                        if (typeof object.MsgResid === "string")
                            $util.base64.decode(object.MsgResid, message.MsgResid = $util.newBuffer($util.base64.length(object.MsgResid)), 0);
                        else if (object.MsgResid.length)
                            message.MsgResid = object.MsgResid;
                    if (object.Rand != null)
                        message.Rand = object.Rand | 0;
                    if (object.Seq != null)
                        message.Seq = object.Seq | 0;
                    if (object.Flags != null)
                        message.Flags = object.Flags | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a RichMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.RichMsg} message RichMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RichMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Template = "";
                        else {
                            object.Template = [];
                            if (options.bytes !== Array)
                                object.Template = $util.newBuffer(object.Template);
                        }
                        object.ServiceId = 0;
                        if (options.bytes === String)
                            object.MsgResid = "";
                        else {
                            object.MsgResid = [];
                            if (options.bytes !== Array)
                                object.MsgResid = $util.newBuffer(object.MsgResid);
                        }
                        object.Rand = 0;
                        object.Seq = 0;
                        object.Flags = 0;
                    }
                    if (message.Template != null && message.hasOwnProperty("Template"))
                        object.Template = options.bytes === String ? $util.base64.encode(message.Template, 0, message.Template.length) : options.bytes === Array ? Array.prototype.slice.call(message.Template) : message.Template;
                    if (message.ServiceId != null && message.hasOwnProperty("ServiceId"))
                        object.ServiceId = message.ServiceId;
                    if (message.MsgResid != null && message.hasOwnProperty("MsgResid"))
                        object.MsgResid = options.bytes === String ? $util.base64.encode(message.MsgResid, 0, message.MsgResid.length) : options.bytes === Array ? Array.prototype.slice.call(message.MsgResid) : message.MsgResid;
                    if (message.Rand != null && message.hasOwnProperty("Rand"))
                        object.Rand = message.Rand;
                    if (message.Seq != null && message.hasOwnProperty("Seq"))
                        object.Seq = message.Seq;
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        object.Flags = message.Flags;
                    return object;
                };

                /**
                 * Converts this RichMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.RichMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RichMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RichMsg;
            })();

            ImMsgBody.GroupFile = (function() {

                /**
                 * Properties of a GroupFile.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IGroupFile
                 * @property {Uint8Array|null} [Filename] GroupFile Filename
                 * @property {number|Long|null} [FileSize] GroupFile FileSize
                 * @property {Uint8Array|null} [FileId] GroupFile FileId
                 * @property {Uint8Array|null} [BatchId] GroupFile BatchId
                 * @property {Uint8Array|null} [FileKey] GroupFile FileKey
                 * @property {Uint8Array|null} [Mark] GroupFile Mark
                 * @property {number|Long|null} [Sequence] GroupFile Sequence
                 * @property {Uint8Array|null} [BatchItemId] GroupFile BatchItemId
                 * @property {number|null} [FeedMsgTime] GroupFile FeedMsgTime
                 * @property {Uint8Array|null} [PbReserve] GroupFile PbReserve
                 */

                /**
                 * Constructs a new GroupFile.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a GroupFile.
                 * @implements IGroupFile
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IGroupFile=} [properties] Properties to set
                 */
                function GroupFile(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GroupFile Filename.
                 * @member {Uint8Array} Filename
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.Filename = $util.newBuffer([]);

                /**
                 * GroupFile FileSize.
                 * @member {number|Long} FileSize
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.FileSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * GroupFile FileId.
                 * @member {Uint8Array} FileId
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.FileId = $util.newBuffer([]);

                /**
                 * GroupFile BatchId.
                 * @member {Uint8Array} BatchId
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.BatchId = $util.newBuffer([]);

                /**
                 * GroupFile FileKey.
                 * @member {Uint8Array} FileKey
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.FileKey = $util.newBuffer([]);

                /**
                 * GroupFile Mark.
                 * @member {Uint8Array} Mark
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.Mark = $util.newBuffer([]);

                /**
                 * GroupFile Sequence.
                 * @member {number|Long} Sequence
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.Sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * GroupFile BatchItemId.
                 * @member {Uint8Array} BatchItemId
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.BatchItemId = $util.newBuffer([]);

                /**
                 * GroupFile FeedMsgTime.
                 * @member {number} FeedMsgTime
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.FeedMsgTime = 0;

                /**
                 * GroupFile PbReserve.
                 * @member {Uint8Array} PbReserve
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 */
                GroupFile.prototype.PbReserve = $util.newBuffer([]);

                /**
                 * Creates a new GroupFile instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupFile=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.GroupFile} GroupFile instance
                 */
                GroupFile.create = function create(properties) {
                    return new GroupFile(properties);
                };

                /**
                 * Encodes the specified GroupFile message. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupFile.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupFile} message GroupFile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupFile.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Filename != null && Object.hasOwnProperty.call(message, "Filename"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Filename);
                    if (message.FileSize != null && Object.hasOwnProperty.call(message, "FileSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.FileSize);
                    if (message.FileId != null && Object.hasOwnProperty.call(message, "FileId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.FileId);
                    if (message.BatchId != null && Object.hasOwnProperty.call(message, "BatchId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.BatchId);
                    if (message.FileKey != null && Object.hasOwnProperty.call(message, "FileKey"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.FileKey);
                    if (message.Mark != null && Object.hasOwnProperty.call(message, "Mark"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.Mark);
                    if (message.Sequence != null && Object.hasOwnProperty.call(message, "Sequence"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int64(message.Sequence);
                    if (message.BatchItemId != null && Object.hasOwnProperty.call(message, "BatchItemId"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.BatchItemId);
                    if (message.FeedMsgTime != null && Object.hasOwnProperty.call(message, "FeedMsgTime"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.FeedMsgTime);
                    if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.PbReserve);
                    return writer;
                };

                /**
                 * Encodes the specified GroupFile message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupFile.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupFile} message GroupFile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupFile.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GroupFile message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.GroupFile} GroupFile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupFile.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.GroupFile();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Filename = reader.bytes();
                            break;
                        case 2:
                            message.FileSize = reader.int64();
                            break;
                        case 3:
                            message.FileId = reader.bytes();
                            break;
                        case 4:
                            message.BatchId = reader.bytes();
                            break;
                        case 5:
                            message.FileKey = reader.bytes();
                            break;
                        case 6:
                            message.Mark = reader.bytes();
                            break;
                        case 7:
                            message.Sequence = reader.int64();
                            break;
                        case 8:
                            message.BatchItemId = reader.bytes();
                            break;
                        case 9:
                            message.FeedMsgTime = reader.int32();
                            break;
                        case 10:
                            message.PbReserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GroupFile message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.GroupFile} GroupFile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupFile.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GroupFile message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GroupFile.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Filename != null && message.hasOwnProperty("Filename"))
                        if (!(message.Filename && typeof message.Filename.length === "number" || $util.isString(message.Filename)))
                            return "Filename: buffer expected";
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        if (!$util.isInteger(message.FileSize) && !(message.FileSize && $util.isInteger(message.FileSize.low) && $util.isInteger(message.FileSize.high)))
                            return "FileSize: integer|Long expected";
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        if (!(message.FileId && typeof message.FileId.length === "number" || $util.isString(message.FileId)))
                            return "FileId: buffer expected";
                    if (message.BatchId != null && message.hasOwnProperty("BatchId"))
                        if (!(message.BatchId && typeof message.BatchId.length === "number" || $util.isString(message.BatchId)))
                            return "BatchId: buffer expected";
                    if (message.FileKey != null && message.hasOwnProperty("FileKey"))
                        if (!(message.FileKey && typeof message.FileKey.length === "number" || $util.isString(message.FileKey)))
                            return "FileKey: buffer expected";
                    if (message.Mark != null && message.hasOwnProperty("Mark"))
                        if (!(message.Mark && typeof message.Mark.length === "number" || $util.isString(message.Mark)))
                            return "Mark: buffer expected";
                    if (message.Sequence != null && message.hasOwnProperty("Sequence"))
                        if (!$util.isInteger(message.Sequence) && !(message.Sequence && $util.isInteger(message.Sequence.low) && $util.isInteger(message.Sequence.high)))
                            return "Sequence: integer|Long expected";
                    if (message.BatchItemId != null && message.hasOwnProperty("BatchItemId"))
                        if (!(message.BatchItemId && typeof message.BatchItemId.length === "number" || $util.isString(message.BatchItemId)))
                            return "BatchItemId: buffer expected";
                    if (message.FeedMsgTime != null && message.hasOwnProperty("FeedMsgTime"))
                        if (!$util.isInteger(message.FeedMsgTime))
                            return "FeedMsgTime: integer expected";
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                            return "PbReserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a GroupFile message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.GroupFile} GroupFile
                 */
                GroupFile.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.GroupFile)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.GroupFile();
                    if (object.Filename != null)
                        if (typeof object.Filename === "string")
                            $util.base64.decode(object.Filename, message.Filename = $util.newBuffer($util.base64.length(object.Filename)), 0);
                        else if (object.Filename.length)
                            message.Filename = object.Filename;
                    if (object.FileSize != null)
                        if ($util.Long)
                            (message.FileSize = $util.Long.fromValue(object.FileSize)).unsigned = false;
                        else if (typeof object.FileSize === "string")
                            message.FileSize = parseInt(object.FileSize, 10);
                        else if (typeof object.FileSize === "number")
                            message.FileSize = object.FileSize;
                        else if (typeof object.FileSize === "object")
                            message.FileSize = new $util.LongBits(object.FileSize.low >>> 0, object.FileSize.high >>> 0).toNumber();
                    if (object.FileId != null)
                        if (typeof object.FileId === "string")
                            $util.base64.decode(object.FileId, message.FileId = $util.newBuffer($util.base64.length(object.FileId)), 0);
                        else if (object.FileId.length)
                            message.FileId = object.FileId;
                    if (object.BatchId != null)
                        if (typeof object.BatchId === "string")
                            $util.base64.decode(object.BatchId, message.BatchId = $util.newBuffer($util.base64.length(object.BatchId)), 0);
                        else if (object.BatchId.length)
                            message.BatchId = object.BatchId;
                    if (object.FileKey != null)
                        if (typeof object.FileKey === "string")
                            $util.base64.decode(object.FileKey, message.FileKey = $util.newBuffer($util.base64.length(object.FileKey)), 0);
                        else if (object.FileKey.length)
                            message.FileKey = object.FileKey;
                    if (object.Mark != null)
                        if (typeof object.Mark === "string")
                            $util.base64.decode(object.Mark, message.Mark = $util.newBuffer($util.base64.length(object.Mark)), 0);
                        else if (object.Mark.length)
                            message.Mark = object.Mark;
                    if (object.Sequence != null)
                        if ($util.Long)
                            (message.Sequence = $util.Long.fromValue(object.Sequence)).unsigned = false;
                        else if (typeof object.Sequence === "string")
                            message.Sequence = parseInt(object.Sequence, 10);
                        else if (typeof object.Sequence === "number")
                            message.Sequence = object.Sequence;
                        else if (typeof object.Sequence === "object")
                            message.Sequence = new $util.LongBits(object.Sequence.low >>> 0, object.Sequence.high >>> 0).toNumber();
                    if (object.BatchItemId != null)
                        if (typeof object.BatchItemId === "string")
                            $util.base64.decode(object.BatchItemId, message.BatchItemId = $util.newBuffer($util.base64.length(object.BatchItemId)), 0);
                        else if (object.BatchItemId.length)
                            message.BatchItemId = object.BatchItemId;
                    if (object.FeedMsgTime != null)
                        message.FeedMsgTime = object.FeedMsgTime | 0;
                    if (object.PbReserve != null)
                        if (typeof object.PbReserve === "string")
                            $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                        else if (object.PbReserve.length)
                            message.PbReserve = object.PbReserve;
                    return message;
                };

                /**
                 * Creates a plain object from a GroupFile message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.GroupFile} message GroupFile
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GroupFile.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Filename = "";
                        else {
                            object.Filename = [];
                            if (options.bytes !== Array)
                                object.Filename = $util.newBuffer(object.Filename);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.FileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.FileSize = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.FileId = "";
                        else {
                            object.FileId = [];
                            if (options.bytes !== Array)
                                object.FileId = $util.newBuffer(object.FileId);
                        }
                        if (options.bytes === String)
                            object.BatchId = "";
                        else {
                            object.BatchId = [];
                            if (options.bytes !== Array)
                                object.BatchId = $util.newBuffer(object.BatchId);
                        }
                        if (options.bytes === String)
                            object.FileKey = "";
                        else {
                            object.FileKey = [];
                            if (options.bytes !== Array)
                                object.FileKey = $util.newBuffer(object.FileKey);
                        }
                        if (options.bytes === String)
                            object.Mark = "";
                        else {
                            object.Mark = [];
                            if (options.bytes !== Array)
                                object.Mark = $util.newBuffer(object.Mark);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Sequence = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.BatchItemId = "";
                        else {
                            object.BatchItemId = [];
                            if (options.bytes !== Array)
                                object.BatchItemId = $util.newBuffer(object.BatchItemId);
                        }
                        object.FeedMsgTime = 0;
                        if (options.bytes === String)
                            object.PbReserve = "";
                        else {
                            object.PbReserve = [];
                            if (options.bytes !== Array)
                                object.PbReserve = $util.newBuffer(object.PbReserve);
                        }
                    }
                    if (message.Filename != null && message.hasOwnProperty("Filename"))
                        object.Filename = options.bytes === String ? $util.base64.encode(message.Filename, 0, message.Filename.length) : options.bytes === Array ? Array.prototype.slice.call(message.Filename) : message.Filename;
                    if (message.FileSize != null && message.hasOwnProperty("FileSize"))
                        if (typeof message.FileSize === "number")
                            object.FileSize = options.longs === String ? String(message.FileSize) : message.FileSize;
                        else
                            object.FileSize = options.longs === String ? $util.Long.prototype.toString.call(message.FileSize) : options.longs === Number ? new $util.LongBits(message.FileSize.low >>> 0, message.FileSize.high >>> 0).toNumber() : message.FileSize;
                    if (message.FileId != null && message.hasOwnProperty("FileId"))
                        object.FileId = options.bytes === String ? $util.base64.encode(message.FileId, 0, message.FileId.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileId) : message.FileId;
                    if (message.BatchId != null && message.hasOwnProperty("BatchId"))
                        object.BatchId = options.bytes === String ? $util.base64.encode(message.BatchId, 0, message.BatchId.length) : options.bytes === Array ? Array.prototype.slice.call(message.BatchId) : message.BatchId;
                    if (message.FileKey != null && message.hasOwnProperty("FileKey"))
                        object.FileKey = options.bytes === String ? $util.base64.encode(message.FileKey, 0, message.FileKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.FileKey) : message.FileKey;
                    if (message.Mark != null && message.hasOwnProperty("Mark"))
                        object.Mark = options.bytes === String ? $util.base64.encode(message.Mark, 0, message.Mark.length) : options.bytes === Array ? Array.prototype.slice.call(message.Mark) : message.Mark;
                    if (message.Sequence != null && message.hasOwnProperty("Sequence"))
                        if (typeof message.Sequence === "number")
                            object.Sequence = options.longs === String ? String(message.Sequence) : message.Sequence;
                        else
                            object.Sequence = options.longs === String ? $util.Long.prototype.toString.call(message.Sequence) : options.longs === Number ? new $util.LongBits(message.Sequence.low >>> 0, message.Sequence.high >>> 0).toNumber() : message.Sequence;
                    if (message.BatchItemId != null && message.hasOwnProperty("BatchItemId"))
                        object.BatchItemId = options.bytes === String ? $util.base64.encode(message.BatchItemId, 0, message.BatchItemId.length) : options.bytes === Array ? Array.prototype.slice.call(message.BatchItemId) : message.BatchItemId;
                    if (message.FeedMsgTime != null && message.hasOwnProperty("FeedMsgTime"))
                        object.FeedMsgTime = message.FeedMsgTime;
                    if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                        object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                    return object;
                };

                /**
                 * Converts this GroupFile to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.GroupFile
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GroupFile.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GroupFile;
            })();

            ImMsgBody.PubGroup = (function() {

                /**
                 * Properties of a PubGroup.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IPubGroup
                 * @property {Uint8Array|null} [NickName] PubGroup NickName
                 * @property {number|null} [Gender] PubGroup Gender
                 * @property {number|null} [Age] PubGroup Age
                 * @property {number|null} [Distance] PubGroup Distance
                 */

                /**
                 * Constructs a new PubGroup.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a PubGroup.
                 * @implements IPubGroup
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IPubGroup=} [properties] Properties to set
                 */
                function PubGroup(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PubGroup NickName.
                 * @member {Uint8Array} NickName
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @instance
                 */
                PubGroup.prototype.NickName = $util.newBuffer([]);

                /**
                 * PubGroup Gender.
                 * @member {number} Gender
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @instance
                 */
                PubGroup.prototype.Gender = 0;

                /**
                 * PubGroup Age.
                 * @member {number} Age
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @instance
                 */
                PubGroup.prototype.Age = 0;

                /**
                 * PubGroup Distance.
                 * @member {number} Distance
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @instance
                 */
                PubGroup.prototype.Distance = 0;

                /**
                 * Creates a new PubGroup instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubGroup=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.PubGroup} PubGroup instance
                 */
                PubGroup.create = function create(properties) {
                    return new PubGroup(properties);
                };

                /**
                 * Encodes the specified PubGroup message. Does not implicitly {@link Msg.MsgField.ImMsgBody.PubGroup.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubGroup} message PubGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PubGroup.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.NickName != null && Object.hasOwnProperty.call(message, "NickName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.NickName);
                    if (message.Gender != null && Object.hasOwnProperty.call(message, "Gender"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gender);
                    if (message.Age != null && Object.hasOwnProperty.call(message, "Age"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Age);
                    if (message.Distance != null && Object.hasOwnProperty.call(message, "Distance"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Distance);
                    return writer;
                };

                /**
                 * Encodes the specified PubGroup message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.PubGroup.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubGroup} message PubGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PubGroup.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PubGroup message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.PubGroup} PubGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PubGroup.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.PubGroup();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.NickName = reader.bytes();
                            break;
                        case 2:
                            message.Gender = reader.int32();
                            break;
                        case 3:
                            message.Age = reader.int32();
                            break;
                        case 4:
                            message.Distance = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PubGroup message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.PubGroup} PubGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PubGroup.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PubGroup message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PubGroup.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.NickName != null && message.hasOwnProperty("NickName"))
                        if (!(message.NickName && typeof message.NickName.length === "number" || $util.isString(message.NickName)))
                            return "NickName: buffer expected";
                    if (message.Gender != null && message.hasOwnProperty("Gender"))
                        if (!$util.isInteger(message.Gender))
                            return "Gender: integer expected";
                    if (message.Age != null && message.hasOwnProperty("Age"))
                        if (!$util.isInteger(message.Age))
                            return "Age: integer expected";
                    if (message.Distance != null && message.hasOwnProperty("Distance"))
                        if (!$util.isInteger(message.Distance))
                            return "Distance: integer expected";
                    return null;
                };

                /**
                 * Creates a PubGroup message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.PubGroup} PubGroup
                 */
                PubGroup.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.PubGroup)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.PubGroup();
                    if (object.NickName != null)
                        if (typeof object.NickName === "string")
                            $util.base64.decode(object.NickName, message.NickName = $util.newBuffer($util.base64.length(object.NickName)), 0);
                        else if (object.NickName.length)
                            message.NickName = object.NickName;
                    if (object.Gender != null)
                        message.Gender = object.Gender | 0;
                    if (object.Age != null)
                        message.Age = object.Age | 0;
                    if (object.Distance != null)
                        message.Distance = object.Distance | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a PubGroup message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.PubGroup} message PubGroup
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PubGroup.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.NickName = "";
                        else {
                            object.NickName = [];
                            if (options.bytes !== Array)
                                object.NickName = $util.newBuffer(object.NickName);
                        }
                        object.Gender = 0;
                        object.Age = 0;
                        object.Distance = 0;
                    }
                    if (message.NickName != null && message.hasOwnProperty("NickName"))
                        object.NickName = options.bytes === String ? $util.base64.encode(message.NickName, 0, message.NickName.length) : options.bytes === Array ? Array.prototype.slice.call(message.NickName) : message.NickName;
                    if (message.Gender != null && message.hasOwnProperty("Gender"))
                        object.Gender = message.Gender;
                    if (message.Age != null && message.hasOwnProperty("Age"))
                        object.Age = message.Age;
                    if (message.Distance != null && message.hasOwnProperty("Distance"))
                        object.Distance = message.Distance;
                    return object;
                };

                /**
                 * Converts this PubGroup to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.PubGroup
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PubGroup.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PubGroup;
            })();

            ImMsgBody.MarketTrans = (function() {

                /**
                 * Properties of a MarketTrans.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IMarketTrans
                 * @property {number|null} [Flag] MarketTrans Flag
                 * @property {Uint8Array|null} [Xml] MarketTrans Xml
                 * @property {Uint8Array|null} [MsgResId] MarketTrans MsgResId
                 * @property {number|null} [Ability] MarketTrans Ability
                 * @property {number|null} [MinAbility] MarketTrans MinAbility
                 */

                /**
                 * Constructs a new MarketTrans.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a MarketTrans.
                 * @implements IMarketTrans
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IMarketTrans=} [properties] Properties to set
                 */
                function MarketTrans(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MarketTrans Flag.
                 * @member {number} Flag
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @instance
                 */
                MarketTrans.prototype.Flag = 0;

                /**
                 * MarketTrans Xml.
                 * @member {Uint8Array} Xml
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @instance
                 */
                MarketTrans.prototype.Xml = $util.newBuffer([]);

                /**
                 * MarketTrans MsgResId.
                 * @member {Uint8Array} MsgResId
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @instance
                 */
                MarketTrans.prototype.MsgResId = $util.newBuffer([]);

                /**
                 * MarketTrans Ability.
                 * @member {number} Ability
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @instance
                 */
                MarketTrans.prototype.Ability = 0;

                /**
                 * MarketTrans MinAbility.
                 * @member {number} MinAbility
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @instance
                 */
                MarketTrans.prototype.MinAbility = 0;

                /**
                 * Creates a new MarketTrans instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMarketTrans=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.MarketTrans} MarketTrans instance
                 */
                MarketTrans.create = function create(properties) {
                    return new MarketTrans(properties);
                };

                /**
                 * Encodes the specified MarketTrans message. Does not implicitly {@link Msg.MsgField.ImMsgBody.MarketTrans.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMarketTrans} message MarketTrans message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarketTrans.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Flag);
                    if (message.Xml != null && Object.hasOwnProperty.call(message, "Xml"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Xml);
                    if (message.MsgResId != null && Object.hasOwnProperty.call(message, "MsgResId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.MsgResId);
                    if (message.Ability != null && Object.hasOwnProperty.call(message, "Ability"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Ability);
                    if (message.MinAbility != null && Object.hasOwnProperty.call(message, "MinAbility"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.MinAbility);
                    return writer;
                };

                /**
                 * Encodes the specified MarketTrans message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.MarketTrans.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMarketTrans} message MarketTrans message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarketTrans.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MarketTrans message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.MarketTrans} MarketTrans
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarketTrans.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.MarketTrans();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Flag = reader.int32();
                            break;
                        case 2:
                            message.Xml = reader.bytes();
                            break;
                        case 3:
                            message.MsgResId = reader.bytes();
                            break;
                        case 4:
                            message.Ability = reader.int32();
                            break;
                        case 5:
                            message.MinAbility = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MarketTrans message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.MarketTrans} MarketTrans
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarketTrans.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MarketTrans message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MarketTrans.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!$util.isInteger(message.Flag))
                            return "Flag: integer expected";
                    if (message.Xml != null && message.hasOwnProperty("Xml"))
                        if (!(message.Xml && typeof message.Xml.length === "number" || $util.isString(message.Xml)))
                            return "Xml: buffer expected";
                    if (message.MsgResId != null && message.hasOwnProperty("MsgResId"))
                        if (!(message.MsgResId && typeof message.MsgResId.length === "number" || $util.isString(message.MsgResId)))
                            return "MsgResId: buffer expected";
                    if (message.Ability != null && message.hasOwnProperty("Ability"))
                        if (!$util.isInteger(message.Ability))
                            return "Ability: integer expected";
                    if (message.MinAbility != null && message.hasOwnProperty("MinAbility"))
                        if (!$util.isInteger(message.MinAbility))
                            return "MinAbility: integer expected";
                    return null;
                };

                /**
                 * Creates a MarketTrans message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.MarketTrans} MarketTrans
                 */
                MarketTrans.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.MarketTrans)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.MarketTrans();
                    if (object.Flag != null)
                        message.Flag = object.Flag | 0;
                    if (object.Xml != null)
                        if (typeof object.Xml === "string")
                            $util.base64.decode(object.Xml, message.Xml = $util.newBuffer($util.base64.length(object.Xml)), 0);
                        else if (object.Xml.length)
                            message.Xml = object.Xml;
                    if (object.MsgResId != null)
                        if (typeof object.MsgResId === "string")
                            $util.base64.decode(object.MsgResId, message.MsgResId = $util.newBuffer($util.base64.length(object.MsgResId)), 0);
                        else if (object.MsgResId.length)
                            message.MsgResId = object.MsgResId;
                    if (object.Ability != null)
                        message.Ability = object.Ability | 0;
                    if (object.MinAbility != null)
                        message.MinAbility = object.MinAbility | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MarketTrans message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.MarketTrans} message MarketTrans
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MarketTrans.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Flag = 0;
                        if (options.bytes === String)
                            object.Xml = "";
                        else {
                            object.Xml = [];
                            if (options.bytes !== Array)
                                object.Xml = $util.newBuffer(object.Xml);
                        }
                        if (options.bytes === String)
                            object.MsgResId = "";
                        else {
                            object.MsgResId = [];
                            if (options.bytes !== Array)
                                object.MsgResId = $util.newBuffer(object.MsgResId);
                        }
                        object.Ability = 0;
                        object.MinAbility = 0;
                    }
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = message.Flag;
                    if (message.Xml != null && message.hasOwnProperty("Xml"))
                        object.Xml = options.bytes === String ? $util.base64.encode(message.Xml, 0, message.Xml.length) : options.bytes === Array ? Array.prototype.slice.call(message.Xml) : message.Xml;
                    if (message.MsgResId != null && message.hasOwnProperty("MsgResId"))
                        object.MsgResId = options.bytes === String ? $util.base64.encode(message.MsgResId, 0, message.MsgResId.length) : options.bytes === Array ? Array.prototype.slice.call(message.MsgResId) : message.MsgResId;
                    if (message.Ability != null && message.hasOwnProperty("Ability"))
                        object.Ability = message.Ability;
                    if (message.MinAbility != null && message.hasOwnProperty("MinAbility"))
                        object.MinAbility = message.MinAbility;
                    return object;
                };

                /**
                 * Converts this MarketTrans to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.MarketTrans
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MarketTrans.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MarketTrans;
            })();

            ImMsgBody.ExtraInfo = (function() {

                /**
                 * Properties of an ExtraInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IExtraInfo
                 * @property {Uint8Array|null} [Nick] ExtraInfo Nick
                 * @property {string|null} [GroupCard] ExtraInfo GroupCard
                 * @property {number|null} [Level] ExtraInfo Level
                 * @property {number|null} [Flags] ExtraInfo Flags
                 * @property {number|null} [GroupMask] ExtraInfo GroupMask
                 * @property {number|null} [MsgTailid] ExtraInfo MsgTailid
                 * @property {Uint8Array|null} [Sendertitle] ExtraInfo Sendertitle
                 * @property {Uint8Array|null} [ApnsTips] ExtraInfo ApnsTips
                 * @property {number|Long|null} [Uin] ExtraInfo Uin
                 * @property {number|null} [MsgStateFlag] ExtraInfo MsgStateFlag
                 * @property {number|null} [ApnsSoundType] ExtraInfo ApnsSoundType
                 * @property {number|null} [Newgroupflag] ExtraInfo Newgroupflag
                 */

                /**
                 * Constructs a new ExtraInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an ExtraInfo.
                 * @implements IExtraInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IExtraInfo=} [properties] Properties to set
                 */
                function ExtraInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtraInfo Nick.
                 * @member {Uint8Array} Nick
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.Nick = $util.newBuffer([]);

                /**
                 * ExtraInfo GroupCard.
                 * @member {string} GroupCard
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.GroupCard = "";

                /**
                 * ExtraInfo Level.
                 * @member {number} Level
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.Level = 0;

                /**
                 * ExtraInfo Flags.
                 * @member {number} Flags
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.Flags = 0;

                /**
                 * ExtraInfo GroupMask.
                 * @member {number} GroupMask
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.GroupMask = 0;

                /**
                 * ExtraInfo MsgTailid.
                 * @member {number} MsgTailid
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.MsgTailid = 0;

                /**
                 * ExtraInfo Sendertitle.
                 * @member {Uint8Array} Sendertitle
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.Sendertitle = $util.newBuffer([]);

                /**
                 * ExtraInfo ApnsTips.
                 * @member {Uint8Array} ApnsTips
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.ApnsTips = $util.newBuffer([]);

                /**
                 * ExtraInfo Uin.
                 * @member {number|Long} Uin
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.Uin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ExtraInfo MsgStateFlag.
                 * @member {number} MsgStateFlag
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.MsgStateFlag = 0;

                /**
                 * ExtraInfo ApnsSoundType.
                 * @member {number} ApnsSoundType
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.ApnsSoundType = 0;

                /**
                 * ExtraInfo Newgroupflag.
                 * @member {number} Newgroupflag
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 */
                ExtraInfo.prototype.Newgroupflag = 0;

                /**
                 * Creates a new ExtraInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IExtraInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.ExtraInfo} ExtraInfo instance
                 */
                ExtraInfo.create = function create(properties) {
                    return new ExtraInfo(properties);
                };

                /**
                 * Encodes the specified ExtraInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.ExtraInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IExtraInfo} message ExtraInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtraInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Nick != null && Object.hasOwnProperty.call(message, "Nick"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Nick);
                    if (message.GroupCard != null && Object.hasOwnProperty.call(message, "GroupCard"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.GroupCard);
                    if (message.Level != null && Object.hasOwnProperty.call(message, "Level"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Level);
                    if (message.Flags != null && Object.hasOwnProperty.call(message, "Flags"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Flags);
                    if (message.GroupMask != null && Object.hasOwnProperty.call(message, "GroupMask"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.GroupMask);
                    if (message.MsgTailid != null && Object.hasOwnProperty.call(message, "MsgTailid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.MsgTailid);
                    if (message.Sendertitle != null && Object.hasOwnProperty.call(message, "Sendertitle"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Sendertitle);
                    if (message.ApnsTips != null && Object.hasOwnProperty.call(message, "ApnsTips"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.ApnsTips);
                    if (message.Uin != null && Object.hasOwnProperty.call(message, "Uin"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int64(message.Uin);
                    if (message.MsgStateFlag != null && Object.hasOwnProperty.call(message, "MsgStateFlag"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.MsgStateFlag);
                    if (message.ApnsSoundType != null && Object.hasOwnProperty.call(message, "ApnsSoundType"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.ApnsSoundType);
                    if (message.Newgroupflag != null && Object.hasOwnProperty.call(message, "Newgroupflag"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.Newgroupflag);
                    return writer;
                };

                /**
                 * Encodes the specified ExtraInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.ExtraInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IExtraInfo} message ExtraInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtraInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtraInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.ExtraInfo} ExtraInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtraInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.ExtraInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Nick = reader.bytes();
                            break;
                        case 2:
                            message.GroupCard = reader.string();
                            break;
                        case 3:
                            message.Level = reader.int32();
                            break;
                        case 4:
                            message.Flags = reader.int32();
                            break;
                        case 5:
                            message.GroupMask = reader.int32();
                            break;
                        case 6:
                            message.MsgTailid = reader.int32();
                            break;
                        case 7:
                            message.Sendertitle = reader.bytes();
                            break;
                        case 8:
                            message.ApnsTips = reader.bytes();
                            break;
                        case 9:
                            message.Uin = reader.int64();
                            break;
                        case 10:
                            message.MsgStateFlag = reader.int32();
                            break;
                        case 11:
                            message.ApnsSoundType = reader.int32();
                            break;
                        case 12:
                            message.Newgroupflag = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtraInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.ExtraInfo} ExtraInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtraInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtraInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtraInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Nick != null && message.hasOwnProperty("Nick"))
                        if (!(message.Nick && typeof message.Nick.length === "number" || $util.isString(message.Nick)))
                            return "Nick: buffer expected";
                    if (message.GroupCard != null && message.hasOwnProperty("GroupCard"))
                        if (!$util.isString(message.GroupCard))
                            return "GroupCard: string expected";
                    if (message.Level != null && message.hasOwnProperty("Level"))
                        if (!$util.isInteger(message.Level))
                            return "Level: integer expected";
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        if (!$util.isInteger(message.Flags))
                            return "Flags: integer expected";
                    if (message.GroupMask != null && message.hasOwnProperty("GroupMask"))
                        if (!$util.isInteger(message.GroupMask))
                            return "GroupMask: integer expected";
                    if (message.MsgTailid != null && message.hasOwnProperty("MsgTailid"))
                        if (!$util.isInteger(message.MsgTailid))
                            return "MsgTailid: integer expected";
                    if (message.Sendertitle != null && message.hasOwnProperty("Sendertitle"))
                        if (!(message.Sendertitle && typeof message.Sendertitle.length === "number" || $util.isString(message.Sendertitle)))
                            return "Sendertitle: buffer expected";
                    if (message.ApnsTips != null && message.hasOwnProperty("ApnsTips"))
                        if (!(message.ApnsTips && typeof message.ApnsTips.length === "number" || $util.isString(message.ApnsTips)))
                            return "ApnsTips: buffer expected";
                    if (message.Uin != null && message.hasOwnProperty("Uin"))
                        if (!$util.isInteger(message.Uin) && !(message.Uin && $util.isInteger(message.Uin.low) && $util.isInteger(message.Uin.high)))
                            return "Uin: integer|Long expected";
                    if (message.MsgStateFlag != null && message.hasOwnProperty("MsgStateFlag"))
                        if (!$util.isInteger(message.MsgStateFlag))
                            return "MsgStateFlag: integer expected";
                    if (message.ApnsSoundType != null && message.hasOwnProperty("ApnsSoundType"))
                        if (!$util.isInteger(message.ApnsSoundType))
                            return "ApnsSoundType: integer expected";
                    if (message.Newgroupflag != null && message.hasOwnProperty("Newgroupflag"))
                        if (!$util.isInteger(message.Newgroupflag))
                            return "Newgroupflag: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtraInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.ExtraInfo} ExtraInfo
                 */
                ExtraInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.ExtraInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.ExtraInfo();
                    if (object.Nick != null)
                        if (typeof object.Nick === "string")
                            $util.base64.decode(object.Nick, message.Nick = $util.newBuffer($util.base64.length(object.Nick)), 0);
                        else if (object.Nick.length)
                            message.Nick = object.Nick;
                    if (object.GroupCard != null)
                        message.GroupCard = String(object.GroupCard);
                    if (object.Level != null)
                        message.Level = object.Level | 0;
                    if (object.Flags != null)
                        message.Flags = object.Flags | 0;
                    if (object.GroupMask != null)
                        message.GroupMask = object.GroupMask | 0;
                    if (object.MsgTailid != null)
                        message.MsgTailid = object.MsgTailid | 0;
                    if (object.Sendertitle != null)
                        if (typeof object.Sendertitle === "string")
                            $util.base64.decode(object.Sendertitle, message.Sendertitle = $util.newBuffer($util.base64.length(object.Sendertitle)), 0);
                        else if (object.Sendertitle.length)
                            message.Sendertitle = object.Sendertitle;
                    if (object.ApnsTips != null)
                        if (typeof object.ApnsTips === "string")
                            $util.base64.decode(object.ApnsTips, message.ApnsTips = $util.newBuffer($util.base64.length(object.ApnsTips)), 0);
                        else if (object.ApnsTips.length)
                            message.ApnsTips = object.ApnsTips;
                    if (object.Uin != null)
                        if ($util.Long)
                            (message.Uin = $util.Long.fromValue(object.Uin)).unsigned = false;
                        else if (typeof object.Uin === "string")
                            message.Uin = parseInt(object.Uin, 10);
                        else if (typeof object.Uin === "number")
                            message.Uin = object.Uin;
                        else if (typeof object.Uin === "object")
                            message.Uin = new $util.LongBits(object.Uin.low >>> 0, object.Uin.high >>> 0).toNumber();
                    if (object.MsgStateFlag != null)
                        message.MsgStateFlag = object.MsgStateFlag | 0;
                    if (object.ApnsSoundType != null)
                        message.ApnsSoundType = object.ApnsSoundType | 0;
                    if (object.Newgroupflag != null)
                        message.Newgroupflag = object.Newgroupflag | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtraInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ExtraInfo} message ExtraInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtraInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Nick = "";
                        else {
                            object.Nick = [];
                            if (options.bytes !== Array)
                                object.Nick = $util.newBuffer(object.Nick);
                        }
                        object.GroupCard = "";
                        object.Level = 0;
                        object.Flags = 0;
                        object.GroupMask = 0;
                        object.MsgTailid = 0;
                        if (options.bytes === String)
                            object.Sendertitle = "";
                        else {
                            object.Sendertitle = [];
                            if (options.bytes !== Array)
                                object.Sendertitle = $util.newBuffer(object.Sendertitle);
                        }
                        if (options.bytes === String)
                            object.ApnsTips = "";
                        else {
                            object.ApnsTips = [];
                            if (options.bytes !== Array)
                                object.ApnsTips = $util.newBuffer(object.ApnsTips);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Uin = options.longs === String ? "0" : 0;
                        object.MsgStateFlag = 0;
                        object.ApnsSoundType = 0;
                        object.Newgroupflag = 0;
                    }
                    if (message.Nick != null && message.hasOwnProperty("Nick"))
                        object.Nick = options.bytes === String ? $util.base64.encode(message.Nick, 0, message.Nick.length) : options.bytes === Array ? Array.prototype.slice.call(message.Nick) : message.Nick;
                    if (message.GroupCard != null && message.hasOwnProperty("GroupCard"))
                        object.GroupCard = message.GroupCard;
                    if (message.Level != null && message.hasOwnProperty("Level"))
                        object.Level = message.Level;
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        object.Flags = message.Flags;
                    if (message.GroupMask != null && message.hasOwnProperty("GroupMask"))
                        object.GroupMask = message.GroupMask;
                    if (message.MsgTailid != null && message.hasOwnProperty("MsgTailid"))
                        object.MsgTailid = message.MsgTailid;
                    if (message.Sendertitle != null && message.hasOwnProperty("Sendertitle"))
                        object.Sendertitle = options.bytes === String ? $util.base64.encode(message.Sendertitle, 0, message.Sendertitle.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sendertitle) : message.Sendertitle;
                    if (message.ApnsTips != null && message.hasOwnProperty("ApnsTips"))
                        object.ApnsTips = options.bytes === String ? $util.base64.encode(message.ApnsTips, 0, message.ApnsTips.length) : options.bytes === Array ? Array.prototype.slice.call(message.ApnsTips) : message.ApnsTips;
                    if (message.Uin != null && message.hasOwnProperty("Uin"))
                        if (typeof message.Uin === "number")
                            object.Uin = options.longs === String ? String(message.Uin) : message.Uin;
                        else
                            object.Uin = options.longs === String ? $util.Long.prototype.toString.call(message.Uin) : options.longs === Number ? new $util.LongBits(message.Uin.low >>> 0, message.Uin.high >>> 0).toNumber() : message.Uin;
                    if (message.MsgStateFlag != null && message.hasOwnProperty("MsgStateFlag"))
                        object.MsgStateFlag = message.MsgStateFlag;
                    if (message.ApnsSoundType != null && message.hasOwnProperty("ApnsSoundType"))
                        object.ApnsSoundType = message.ApnsSoundType;
                    if (message.Newgroupflag != null && message.hasOwnProperty("Newgroupflag"))
                        object.Newgroupflag = message.Newgroupflag;
                    return object;
                };

                /**
                 * Converts this ExtraInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.ExtraInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtraInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtraInfo;
            })();

            ImMsgBody.ShakeWindow = (function() {

                /**
                 * Properties of a ShakeWindow.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IShakeWindow
                 * @property {number|null} [Type] ShakeWindow Type
                 * @property {number|null} [Reserve] ShakeWindow Reserve
                 * @property {number|Long|null} [Uin] ShakeWindow Uin
                 */

                /**
                 * Constructs a new ShakeWindow.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a ShakeWindow.
                 * @implements IShakeWindow
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IShakeWindow=} [properties] Properties to set
                 */
                function ShakeWindow(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ShakeWindow Type.
                 * @member {number} Type
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @instance
                 */
                ShakeWindow.prototype.Type = 0;

                /**
                 * ShakeWindow Reserve.
                 * @member {number} Reserve
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @instance
                 */
                ShakeWindow.prototype.Reserve = 0;

                /**
                 * ShakeWindow Uin.
                 * @member {number|Long} Uin
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @instance
                 */
                ShakeWindow.prototype.Uin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ShakeWindow instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IShakeWindow=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.ShakeWindow} ShakeWindow instance
                 */
                ShakeWindow.create = function create(properties) {
                    return new ShakeWindow(properties);
                };

                /**
                 * Encodes the specified ShakeWindow message. Does not implicitly {@link Msg.MsgField.ImMsgBody.ShakeWindow.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IShakeWindow} message ShakeWindow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ShakeWindow.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
                    if (message.Reserve != null && Object.hasOwnProperty.call(message, "Reserve"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Reserve);
                    if (message.Uin != null && Object.hasOwnProperty.call(message, "Uin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.Uin);
                    return writer;
                };

                /**
                 * Encodes the specified ShakeWindow message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.ShakeWindow.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IShakeWindow} message ShakeWindow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ShakeWindow.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ShakeWindow message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.ShakeWindow} ShakeWindow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ShakeWindow.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.ShakeWindow();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Type = reader.int32();
                            break;
                        case 2:
                            message.Reserve = reader.int32();
                            break;
                        case 3:
                            message.Uin = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ShakeWindow message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.ShakeWindow} ShakeWindow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ShakeWindow.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ShakeWindow message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ShakeWindow.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        if (!$util.isInteger(message.Type))
                            return "Type: integer expected";
                    if (message.Reserve != null && message.hasOwnProperty("Reserve"))
                        if (!$util.isInteger(message.Reserve))
                            return "Reserve: integer expected";
                    if (message.Uin != null && message.hasOwnProperty("Uin"))
                        if (!$util.isInteger(message.Uin) && !(message.Uin && $util.isInteger(message.Uin.low) && $util.isInteger(message.Uin.high)))
                            return "Uin: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ShakeWindow message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.ShakeWindow} ShakeWindow
                 */
                ShakeWindow.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.ShakeWindow)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.ShakeWindow();
                    if (object.Type != null)
                        message.Type = object.Type | 0;
                    if (object.Reserve != null)
                        message.Reserve = object.Reserve | 0;
                    if (object.Uin != null)
                        if ($util.Long)
                            (message.Uin = $util.Long.fromValue(object.Uin)).unsigned = false;
                        else if (typeof object.Uin === "string")
                            message.Uin = parseInt(object.Uin, 10);
                        else if (typeof object.Uin === "number")
                            message.Uin = object.Uin;
                        else if (typeof object.Uin === "object")
                            message.Uin = new $util.LongBits(object.Uin.low >>> 0, object.Uin.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a ShakeWindow message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ShakeWindow} message ShakeWindow
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ShakeWindow.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Type = 0;
                        object.Reserve = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Uin = options.longs === String ? "0" : 0;
                    }
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    if (message.Reserve != null && message.hasOwnProperty("Reserve"))
                        object.Reserve = message.Reserve;
                    if (message.Uin != null && message.hasOwnProperty("Uin"))
                        if (typeof message.Uin === "number")
                            object.Uin = options.longs === String ? String(message.Uin) : message.Uin;
                        else
                            object.Uin = options.longs === String ? $util.Long.prototype.toString.call(message.Uin) : options.longs === Number ? new $util.LongBits(message.Uin.low >>> 0, message.Uin.high >>> 0).toNumber() : message.Uin;
                    return object;
                };

                /**
                 * Converts this ShakeWindow to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.ShakeWindow
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ShakeWindow.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ShakeWindow;
            })();

            ImMsgBody.PubAccount = (function() {

                /**
                 * Properties of a PubAccount.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IPubAccount
                 * @property {Uint8Array|null} [Buf] PubAccount Buf
                 * @property {number|Long|null} [Pubaccountuin] PubAccount Pubaccountuin
                 */

                /**
                 * Constructs a new PubAccount.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a PubAccount.
                 * @implements IPubAccount
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IPubAccount=} [properties] Properties to set
                 */
                function PubAccount(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PubAccount Buf.
                 * @member {Uint8Array} Buf
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @instance
                 */
                PubAccount.prototype.Buf = $util.newBuffer([]);

                /**
                 * PubAccount Pubaccountuin.
                 * @member {number|Long} Pubaccountuin
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @instance
                 */
                PubAccount.prototype.Pubaccountuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new PubAccount instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubAccount=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.PubAccount} PubAccount instance
                 */
                PubAccount.create = function create(properties) {
                    return new PubAccount(properties);
                };

                /**
                 * Encodes the specified PubAccount message. Does not implicitly {@link Msg.MsgField.ImMsgBody.PubAccount.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubAccount} message PubAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PubAccount.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Buf != null && Object.hasOwnProperty.call(message, "Buf"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Buf);
                    if (message.Pubaccountuin != null && Object.hasOwnProperty.call(message, "Pubaccountuin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Pubaccountuin);
                    return writer;
                };

                /**
                 * Encodes the specified PubAccount message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.PubAccount.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubAccount} message PubAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PubAccount.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PubAccount message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.PubAccount} PubAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PubAccount.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.PubAccount();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Buf = reader.bytes();
                            break;
                        case 2:
                            message.Pubaccountuin = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PubAccount message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.PubAccount} PubAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PubAccount.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PubAccount message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PubAccount.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Buf != null && message.hasOwnProperty("Buf"))
                        if (!(message.Buf && typeof message.Buf.length === "number" || $util.isString(message.Buf)))
                            return "Buf: buffer expected";
                    if (message.Pubaccountuin != null && message.hasOwnProperty("Pubaccountuin"))
                        if (!$util.isInteger(message.Pubaccountuin) && !(message.Pubaccountuin && $util.isInteger(message.Pubaccountuin.low) && $util.isInteger(message.Pubaccountuin.high)))
                            return "Pubaccountuin: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a PubAccount message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.PubAccount} PubAccount
                 */
                PubAccount.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.PubAccount)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.PubAccount();
                    if (object.Buf != null)
                        if (typeof object.Buf === "string")
                            $util.base64.decode(object.Buf, message.Buf = $util.newBuffer($util.base64.length(object.Buf)), 0);
                        else if (object.Buf.length)
                            message.Buf = object.Buf;
                    if (object.Pubaccountuin != null)
                        if ($util.Long)
                            (message.Pubaccountuin = $util.Long.fromValue(object.Pubaccountuin)).unsigned = false;
                        else if (typeof object.Pubaccountuin === "string")
                            message.Pubaccountuin = parseInt(object.Pubaccountuin, 10);
                        else if (typeof object.Pubaccountuin === "number")
                            message.Pubaccountuin = object.Pubaccountuin;
                        else if (typeof object.Pubaccountuin === "object")
                            message.Pubaccountuin = new $util.LongBits(object.Pubaccountuin.low >>> 0, object.Pubaccountuin.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a PubAccount message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.PubAccount} message PubAccount
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PubAccount.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Buf = "";
                        else {
                            object.Buf = [];
                            if (options.bytes !== Array)
                                object.Buf = $util.newBuffer(object.Buf);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Pubaccountuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Pubaccountuin = options.longs === String ? "0" : 0;
                    }
                    if (message.Buf != null && message.hasOwnProperty("Buf"))
                        object.Buf = options.bytes === String ? $util.base64.encode(message.Buf, 0, message.Buf.length) : options.bytes === Array ? Array.prototype.slice.call(message.Buf) : message.Buf;
                    if (message.Pubaccountuin != null && message.hasOwnProperty("Pubaccountuin"))
                        if (typeof message.Pubaccountuin === "number")
                            object.Pubaccountuin = options.longs === String ? String(message.Pubaccountuin) : message.Pubaccountuin;
                        else
                            object.Pubaccountuin = options.longs === String ? $util.Long.prototype.toString.call(message.Pubaccountuin) : options.longs === Number ? new $util.LongBits(message.Pubaccountuin.low >>> 0, message.Pubaccountuin.high >>> 0).toNumber() : message.Pubaccountuin;
                    return object;
                };

                /**
                 * Converts this PubAccount to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.PubAccount
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PubAccount.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PubAccount;
            })();

            ImMsgBody.VideoFile = (function() {

                /**
                 * Properties of a VideoFile.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IVideoFile
                 * @property {Uint8Array|null} [Fileuuid] VideoFile Fileuuid
                 * @property {Uint8Array|null} [Filemd5] VideoFile Filemd5
                 * @property {Uint8Array|null} [Filename] VideoFile Filename
                 * @property {number|null} [Fileformat] VideoFile Fileformat
                 * @property {number|null} [Filetime] VideoFile Filetime
                 * @property {number|null} [Filesize] VideoFile Filesize
                 * @property {number|null} [Thumbwidth] VideoFile Thumbwidth
                 * @property {number|null} [Thumbheight] VideoFile Thumbheight
                 * @property {Uint8Array|null} [Thumbfilemd5] VideoFile Thumbfilemd5
                 * @property {Uint8Array|null} [Source] VideoFile Source
                 * @property {number|null} [Thumbfilesize] VideoFile Thumbfilesize
                 * @property {number|null} [Busitype] VideoFile Busitype
                 * @property {number|null} [Fromchattype] VideoFile Fromchattype
                 * @property {number|null} [Tochattype] VideoFile Tochattype
                 * @property {boolean|null} [Boolsupportprogressive] VideoFile Boolsupportprogressive
                 * @property {number|null} [Filewidth] VideoFile Filewidth
                 * @property {number|null} [Fileheight] VideoFile Fileheight
                 * @property {number|null} [Subbusitype] VideoFile Subbusitype
                 * @property {number|null} [Videoattr] VideoFile Videoattr
                 * @property {Array.<Uint8Array>|null} [Bytesthumbfileurls] VideoFile Bytesthumbfileurls
                 * @property {Array.<Uint8Array>|null} [Bytesvideofileurls] VideoFile Bytesvideofileurls
                 * @property {number|null} [Thumbdownloadflag] VideoFile Thumbdownloadflag
                 * @property {number|null} [Videodownloadflag] VideoFile Videodownloadflag
                 * @property {Uint8Array|null} [Pbreserve] VideoFile Pbreserve
                 */

                /**
                 * Constructs a new VideoFile.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a VideoFile.
                 * @implements IVideoFile
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IVideoFile=} [properties] Properties to set
                 */
                function VideoFile(properties) {
                    this.Bytesthumbfileurls = [];
                    this.Bytesvideofileurls = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * VideoFile Fileuuid.
                 * @member {Uint8Array} Fileuuid
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Fileuuid = $util.newBuffer([]);

                /**
                 * VideoFile Filemd5.
                 * @member {Uint8Array} Filemd5
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Filemd5 = $util.newBuffer([]);

                /**
                 * VideoFile Filename.
                 * @member {Uint8Array} Filename
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Filename = $util.newBuffer([]);

                /**
                 * VideoFile Fileformat.
                 * @member {number} Fileformat
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Fileformat = 0;

                /**
                 * VideoFile Filetime.
                 * @member {number} Filetime
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Filetime = 0;

                /**
                 * VideoFile Filesize.
                 * @member {number} Filesize
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Filesize = 0;

                /**
                 * VideoFile Thumbwidth.
                 * @member {number} Thumbwidth
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Thumbwidth = 0;

                /**
                 * VideoFile Thumbheight.
                 * @member {number} Thumbheight
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Thumbheight = 0;

                /**
                 * VideoFile Thumbfilemd5.
                 * @member {Uint8Array} Thumbfilemd5
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Thumbfilemd5 = $util.newBuffer([]);

                /**
                 * VideoFile Source.
                 * @member {Uint8Array} Source
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Source = $util.newBuffer([]);

                /**
                 * VideoFile Thumbfilesize.
                 * @member {number} Thumbfilesize
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Thumbfilesize = 0;

                /**
                 * VideoFile Busitype.
                 * @member {number} Busitype
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Busitype = 0;

                /**
                 * VideoFile Fromchattype.
                 * @member {number} Fromchattype
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Fromchattype = 0;

                /**
                 * VideoFile Tochattype.
                 * @member {number} Tochattype
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Tochattype = 0;

                /**
                 * VideoFile Boolsupportprogressive.
                 * @member {boolean} Boolsupportprogressive
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Boolsupportprogressive = false;

                /**
                 * VideoFile Filewidth.
                 * @member {number} Filewidth
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Filewidth = 0;

                /**
                 * VideoFile Fileheight.
                 * @member {number} Fileheight
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Fileheight = 0;

                /**
                 * VideoFile Subbusitype.
                 * @member {number} Subbusitype
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Subbusitype = 0;

                /**
                 * VideoFile Videoattr.
                 * @member {number} Videoattr
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Videoattr = 0;

                /**
                 * VideoFile Bytesthumbfileurls.
                 * @member {Array.<Uint8Array>} Bytesthumbfileurls
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Bytesthumbfileurls = $util.emptyArray;

                /**
                 * VideoFile Bytesvideofileurls.
                 * @member {Array.<Uint8Array>} Bytesvideofileurls
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Bytesvideofileurls = $util.emptyArray;

                /**
                 * VideoFile Thumbdownloadflag.
                 * @member {number} Thumbdownloadflag
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Thumbdownloadflag = 0;

                /**
                 * VideoFile Videodownloadflag.
                 * @member {number} Videodownloadflag
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Videodownloadflag = 0;

                /**
                 * VideoFile Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 */
                VideoFile.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * Creates a new VideoFile instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IVideoFile=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.VideoFile} VideoFile instance
                 */
                VideoFile.create = function create(properties) {
                    return new VideoFile(properties);
                };

                /**
                 * Encodes the specified VideoFile message. Does not implicitly {@link Msg.MsgField.ImMsgBody.VideoFile.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IVideoFile} message VideoFile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoFile.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Fileuuid != null && Object.hasOwnProperty.call(message, "Fileuuid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Fileuuid);
                    if (message.Filemd5 != null && Object.hasOwnProperty.call(message, "Filemd5"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Filemd5);
                    if (message.Filename != null && Object.hasOwnProperty.call(message, "Filename"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Filename);
                    if (message.Fileformat != null && Object.hasOwnProperty.call(message, "Fileformat"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Fileformat);
                    if (message.Filetime != null && Object.hasOwnProperty.call(message, "Filetime"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Filetime);
                    if (message.Filesize != null && Object.hasOwnProperty.call(message, "Filesize"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Filesize);
                    if (message.Thumbwidth != null && Object.hasOwnProperty.call(message, "Thumbwidth"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Thumbwidth);
                    if (message.Thumbheight != null && Object.hasOwnProperty.call(message, "Thumbheight"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Thumbheight);
                    if (message.Thumbfilemd5 != null && Object.hasOwnProperty.call(message, "Thumbfilemd5"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.Thumbfilemd5);
                    if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.Source);
                    if (message.Thumbfilesize != null && Object.hasOwnProperty.call(message, "Thumbfilesize"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.Thumbfilesize);
                    if (message.Busitype != null && Object.hasOwnProperty.call(message, "Busitype"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.Busitype);
                    if (message.Fromchattype != null && Object.hasOwnProperty.call(message, "Fromchattype"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.Fromchattype);
                    if (message.Tochattype != null && Object.hasOwnProperty.call(message, "Tochattype"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.Tochattype);
                    if (message.Boolsupportprogressive != null && Object.hasOwnProperty.call(message, "Boolsupportprogressive"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.Boolsupportprogressive);
                    if (message.Filewidth != null && Object.hasOwnProperty.call(message, "Filewidth"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.Filewidth);
                    if (message.Fileheight != null && Object.hasOwnProperty.call(message, "Fileheight"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.Fileheight);
                    if (message.Subbusitype != null && Object.hasOwnProperty.call(message, "Subbusitype"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.Subbusitype);
                    if (message.Videoattr != null && Object.hasOwnProperty.call(message, "Videoattr"))
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.Videoattr);
                    if (message.Bytesthumbfileurls != null && message.Bytesthumbfileurls.length)
                        for (var i = 0; i < message.Bytesthumbfileurls.length; ++i)
                            writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.Bytesthumbfileurls[i]);
                    if (message.Bytesvideofileurls != null && message.Bytesvideofileurls.length)
                        for (var i = 0; i < message.Bytesvideofileurls.length; ++i)
                            writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.Bytesvideofileurls[i]);
                    if (message.Thumbdownloadflag != null && Object.hasOwnProperty.call(message, "Thumbdownloadflag"))
                        writer.uint32(/* id 22, wireType 0 =*/176).int32(message.Thumbdownloadflag);
                    if (message.Videodownloadflag != null && Object.hasOwnProperty.call(message, "Videodownloadflag"))
                        writer.uint32(/* id 23, wireType 0 =*/184).int32(message.Videodownloadflag);
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 24, wireType 2 =*/194).bytes(message.Pbreserve);
                    return writer;
                };

                /**
                 * Encodes the specified VideoFile message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.VideoFile.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IVideoFile} message VideoFile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoFile.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a VideoFile message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.VideoFile} VideoFile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoFile.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.VideoFile();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Fileuuid = reader.bytes();
                            break;
                        case 2:
                            message.Filemd5 = reader.bytes();
                            break;
                        case 3:
                            message.Filename = reader.bytes();
                            break;
                        case 4:
                            message.Fileformat = reader.int32();
                            break;
                        case 5:
                            message.Filetime = reader.int32();
                            break;
                        case 6:
                            message.Filesize = reader.int32();
                            break;
                        case 7:
                            message.Thumbwidth = reader.int32();
                            break;
                        case 8:
                            message.Thumbheight = reader.int32();
                            break;
                        case 9:
                            message.Thumbfilemd5 = reader.bytes();
                            break;
                        case 10:
                            message.Source = reader.bytes();
                            break;
                        case 11:
                            message.Thumbfilesize = reader.int32();
                            break;
                        case 12:
                            message.Busitype = reader.int32();
                            break;
                        case 13:
                            message.Fromchattype = reader.int32();
                            break;
                        case 14:
                            message.Tochattype = reader.int32();
                            break;
                        case 15:
                            message.Boolsupportprogressive = reader.bool();
                            break;
                        case 16:
                            message.Filewidth = reader.int32();
                            break;
                        case 17:
                            message.Fileheight = reader.int32();
                            break;
                        case 18:
                            message.Subbusitype = reader.int32();
                            break;
                        case 19:
                            message.Videoattr = reader.int32();
                            break;
                        case 20:
                            if (!(message.Bytesthumbfileurls && message.Bytesthumbfileurls.length))
                                message.Bytesthumbfileurls = [];
                            message.Bytesthumbfileurls.push(reader.bytes());
                            break;
                        case 21:
                            if (!(message.Bytesvideofileurls && message.Bytesvideofileurls.length))
                                message.Bytesvideofileurls = [];
                            message.Bytesvideofileurls.push(reader.bytes());
                            break;
                        case 22:
                            message.Thumbdownloadflag = reader.int32();
                            break;
                        case 23:
                            message.Videodownloadflag = reader.int32();
                            break;
                        case 24:
                            message.Pbreserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a VideoFile message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.VideoFile} VideoFile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoFile.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a VideoFile message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VideoFile.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Fileuuid != null && message.hasOwnProperty("Fileuuid"))
                        if (!(message.Fileuuid && typeof message.Fileuuid.length === "number" || $util.isString(message.Fileuuid)))
                            return "Fileuuid: buffer expected";
                    if (message.Filemd5 != null && message.hasOwnProperty("Filemd5"))
                        if (!(message.Filemd5 && typeof message.Filemd5.length === "number" || $util.isString(message.Filemd5)))
                            return "Filemd5: buffer expected";
                    if (message.Filename != null && message.hasOwnProperty("Filename"))
                        if (!(message.Filename && typeof message.Filename.length === "number" || $util.isString(message.Filename)))
                            return "Filename: buffer expected";
                    if (message.Fileformat != null && message.hasOwnProperty("Fileformat"))
                        if (!$util.isInteger(message.Fileformat))
                            return "Fileformat: integer expected";
                    if (message.Filetime != null && message.hasOwnProperty("Filetime"))
                        if (!$util.isInteger(message.Filetime))
                            return "Filetime: integer expected";
                    if (message.Filesize != null && message.hasOwnProperty("Filesize"))
                        if (!$util.isInteger(message.Filesize))
                            return "Filesize: integer expected";
                    if (message.Thumbwidth != null && message.hasOwnProperty("Thumbwidth"))
                        if (!$util.isInteger(message.Thumbwidth))
                            return "Thumbwidth: integer expected";
                    if (message.Thumbheight != null && message.hasOwnProperty("Thumbheight"))
                        if (!$util.isInteger(message.Thumbheight))
                            return "Thumbheight: integer expected";
                    if (message.Thumbfilemd5 != null && message.hasOwnProperty("Thumbfilemd5"))
                        if (!(message.Thumbfilemd5 && typeof message.Thumbfilemd5.length === "number" || $util.isString(message.Thumbfilemd5)))
                            return "Thumbfilemd5: buffer expected";
                    if (message.Source != null && message.hasOwnProperty("Source"))
                        if (!(message.Source && typeof message.Source.length === "number" || $util.isString(message.Source)))
                            return "Source: buffer expected";
                    if (message.Thumbfilesize != null && message.hasOwnProperty("Thumbfilesize"))
                        if (!$util.isInteger(message.Thumbfilesize))
                            return "Thumbfilesize: integer expected";
                    if (message.Busitype != null && message.hasOwnProperty("Busitype"))
                        if (!$util.isInteger(message.Busitype))
                            return "Busitype: integer expected";
                    if (message.Fromchattype != null && message.hasOwnProperty("Fromchattype"))
                        if (!$util.isInteger(message.Fromchattype))
                            return "Fromchattype: integer expected";
                    if (message.Tochattype != null && message.hasOwnProperty("Tochattype"))
                        if (!$util.isInteger(message.Tochattype))
                            return "Tochattype: integer expected";
                    if (message.Boolsupportprogressive != null && message.hasOwnProperty("Boolsupportprogressive"))
                        if (typeof message.Boolsupportprogressive !== "boolean")
                            return "Boolsupportprogressive: boolean expected";
                    if (message.Filewidth != null && message.hasOwnProperty("Filewidth"))
                        if (!$util.isInteger(message.Filewidth))
                            return "Filewidth: integer expected";
                    if (message.Fileheight != null && message.hasOwnProperty("Fileheight"))
                        if (!$util.isInteger(message.Fileheight))
                            return "Fileheight: integer expected";
                    if (message.Subbusitype != null && message.hasOwnProperty("Subbusitype"))
                        if (!$util.isInteger(message.Subbusitype))
                            return "Subbusitype: integer expected";
                    if (message.Videoattr != null && message.hasOwnProperty("Videoattr"))
                        if (!$util.isInteger(message.Videoattr))
                            return "Videoattr: integer expected";
                    if (message.Bytesthumbfileurls != null && message.hasOwnProperty("Bytesthumbfileurls")) {
                        if (!Array.isArray(message.Bytesthumbfileurls))
                            return "Bytesthumbfileurls: array expected";
                        for (var i = 0; i < message.Bytesthumbfileurls.length; ++i)
                            if (!(message.Bytesthumbfileurls[i] && typeof message.Bytesthumbfileurls[i].length === "number" || $util.isString(message.Bytesthumbfileurls[i])))
                                return "Bytesthumbfileurls: buffer[] expected";
                    }
                    if (message.Bytesvideofileurls != null && message.hasOwnProperty("Bytesvideofileurls")) {
                        if (!Array.isArray(message.Bytesvideofileurls))
                            return "Bytesvideofileurls: array expected";
                        for (var i = 0; i < message.Bytesvideofileurls.length; ++i)
                            if (!(message.Bytesvideofileurls[i] && typeof message.Bytesvideofileurls[i].length === "number" || $util.isString(message.Bytesvideofileurls[i])))
                                return "Bytesvideofileurls: buffer[] expected";
                    }
                    if (message.Thumbdownloadflag != null && message.hasOwnProperty("Thumbdownloadflag"))
                        if (!$util.isInteger(message.Thumbdownloadflag))
                            return "Thumbdownloadflag: integer expected";
                    if (message.Videodownloadflag != null && message.hasOwnProperty("Videodownloadflag"))
                        if (!$util.isInteger(message.Videodownloadflag))
                            return "Videodownloadflag: integer expected";
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a VideoFile message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.VideoFile} VideoFile
                 */
                VideoFile.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.VideoFile)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.VideoFile();
                    if (object.Fileuuid != null)
                        if (typeof object.Fileuuid === "string")
                            $util.base64.decode(object.Fileuuid, message.Fileuuid = $util.newBuffer($util.base64.length(object.Fileuuid)), 0);
                        else if (object.Fileuuid.length)
                            message.Fileuuid = object.Fileuuid;
                    if (object.Filemd5 != null)
                        if (typeof object.Filemd5 === "string")
                            $util.base64.decode(object.Filemd5, message.Filemd5 = $util.newBuffer($util.base64.length(object.Filemd5)), 0);
                        else if (object.Filemd5.length)
                            message.Filemd5 = object.Filemd5;
                    if (object.Filename != null)
                        if (typeof object.Filename === "string")
                            $util.base64.decode(object.Filename, message.Filename = $util.newBuffer($util.base64.length(object.Filename)), 0);
                        else if (object.Filename.length)
                            message.Filename = object.Filename;
                    if (object.Fileformat != null)
                        message.Fileformat = object.Fileformat | 0;
                    if (object.Filetime != null)
                        message.Filetime = object.Filetime | 0;
                    if (object.Filesize != null)
                        message.Filesize = object.Filesize | 0;
                    if (object.Thumbwidth != null)
                        message.Thumbwidth = object.Thumbwidth | 0;
                    if (object.Thumbheight != null)
                        message.Thumbheight = object.Thumbheight | 0;
                    if (object.Thumbfilemd5 != null)
                        if (typeof object.Thumbfilemd5 === "string")
                            $util.base64.decode(object.Thumbfilemd5, message.Thumbfilemd5 = $util.newBuffer($util.base64.length(object.Thumbfilemd5)), 0);
                        else if (object.Thumbfilemd5.length)
                            message.Thumbfilemd5 = object.Thumbfilemd5;
                    if (object.Source != null)
                        if (typeof object.Source === "string")
                            $util.base64.decode(object.Source, message.Source = $util.newBuffer($util.base64.length(object.Source)), 0);
                        else if (object.Source.length)
                            message.Source = object.Source;
                    if (object.Thumbfilesize != null)
                        message.Thumbfilesize = object.Thumbfilesize | 0;
                    if (object.Busitype != null)
                        message.Busitype = object.Busitype | 0;
                    if (object.Fromchattype != null)
                        message.Fromchattype = object.Fromchattype | 0;
                    if (object.Tochattype != null)
                        message.Tochattype = object.Tochattype | 0;
                    if (object.Boolsupportprogressive != null)
                        message.Boolsupportprogressive = Boolean(object.Boolsupportprogressive);
                    if (object.Filewidth != null)
                        message.Filewidth = object.Filewidth | 0;
                    if (object.Fileheight != null)
                        message.Fileheight = object.Fileheight | 0;
                    if (object.Subbusitype != null)
                        message.Subbusitype = object.Subbusitype | 0;
                    if (object.Videoattr != null)
                        message.Videoattr = object.Videoattr | 0;
                    if (object.Bytesthumbfileurls) {
                        if (!Array.isArray(object.Bytesthumbfileurls))
                            throw TypeError(".Msg.MsgField.ImMsgBody.VideoFile.Bytesthumbfileurls: array expected");
                        message.Bytesthumbfileurls = [];
                        for (var i = 0; i < object.Bytesthumbfileurls.length; ++i)
                            if (typeof object.Bytesthumbfileurls[i] === "string")
                                $util.base64.decode(object.Bytesthumbfileurls[i], message.Bytesthumbfileurls[i] = $util.newBuffer($util.base64.length(object.Bytesthumbfileurls[i])), 0);
                            else if (object.Bytesthumbfileurls[i].length)
                                message.Bytesthumbfileurls[i] = object.Bytesthumbfileurls[i];
                    }
                    if (object.Bytesvideofileurls) {
                        if (!Array.isArray(object.Bytesvideofileurls))
                            throw TypeError(".Msg.MsgField.ImMsgBody.VideoFile.Bytesvideofileurls: array expected");
                        message.Bytesvideofileurls = [];
                        for (var i = 0; i < object.Bytesvideofileurls.length; ++i)
                            if (typeof object.Bytesvideofileurls[i] === "string")
                                $util.base64.decode(object.Bytesvideofileurls[i], message.Bytesvideofileurls[i] = $util.newBuffer($util.base64.length(object.Bytesvideofileurls[i])), 0);
                            else if (object.Bytesvideofileurls[i].length)
                                message.Bytesvideofileurls[i] = object.Bytesvideofileurls[i];
                    }
                    if (object.Thumbdownloadflag != null)
                        message.Thumbdownloadflag = object.Thumbdownloadflag | 0;
                    if (object.Videodownloadflag != null)
                        message.Videodownloadflag = object.Videodownloadflag | 0;
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    return message;
                };

                /**
                 * Creates a plain object from a VideoFile message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.VideoFile} message VideoFile
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VideoFile.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.Bytesthumbfileurls = [];
                        object.Bytesvideofileurls = [];
                    }
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Fileuuid = "";
                        else {
                            object.Fileuuid = [];
                            if (options.bytes !== Array)
                                object.Fileuuid = $util.newBuffer(object.Fileuuid);
                        }
                        if (options.bytes === String)
                            object.Filemd5 = "";
                        else {
                            object.Filemd5 = [];
                            if (options.bytes !== Array)
                                object.Filemd5 = $util.newBuffer(object.Filemd5);
                        }
                        if (options.bytes === String)
                            object.Filename = "";
                        else {
                            object.Filename = [];
                            if (options.bytes !== Array)
                                object.Filename = $util.newBuffer(object.Filename);
                        }
                        object.Fileformat = 0;
                        object.Filetime = 0;
                        object.Filesize = 0;
                        object.Thumbwidth = 0;
                        object.Thumbheight = 0;
                        if (options.bytes === String)
                            object.Thumbfilemd5 = "";
                        else {
                            object.Thumbfilemd5 = [];
                            if (options.bytes !== Array)
                                object.Thumbfilemd5 = $util.newBuffer(object.Thumbfilemd5);
                        }
                        if (options.bytes === String)
                            object.Source = "";
                        else {
                            object.Source = [];
                            if (options.bytes !== Array)
                                object.Source = $util.newBuffer(object.Source);
                        }
                        object.Thumbfilesize = 0;
                        object.Busitype = 0;
                        object.Fromchattype = 0;
                        object.Tochattype = 0;
                        object.Boolsupportprogressive = false;
                        object.Filewidth = 0;
                        object.Fileheight = 0;
                        object.Subbusitype = 0;
                        object.Videoattr = 0;
                        object.Thumbdownloadflag = 0;
                        object.Videodownloadflag = 0;
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                    }
                    if (message.Fileuuid != null && message.hasOwnProperty("Fileuuid"))
                        object.Fileuuid = options.bytes === String ? $util.base64.encode(message.Fileuuid, 0, message.Fileuuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Fileuuid) : message.Fileuuid;
                    if (message.Filemd5 != null && message.hasOwnProperty("Filemd5"))
                        object.Filemd5 = options.bytes === String ? $util.base64.encode(message.Filemd5, 0, message.Filemd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.Filemd5) : message.Filemd5;
                    if (message.Filename != null && message.hasOwnProperty("Filename"))
                        object.Filename = options.bytes === String ? $util.base64.encode(message.Filename, 0, message.Filename.length) : options.bytes === Array ? Array.prototype.slice.call(message.Filename) : message.Filename;
                    if (message.Fileformat != null && message.hasOwnProperty("Fileformat"))
                        object.Fileformat = message.Fileformat;
                    if (message.Filetime != null && message.hasOwnProperty("Filetime"))
                        object.Filetime = message.Filetime;
                    if (message.Filesize != null && message.hasOwnProperty("Filesize"))
                        object.Filesize = message.Filesize;
                    if (message.Thumbwidth != null && message.hasOwnProperty("Thumbwidth"))
                        object.Thumbwidth = message.Thumbwidth;
                    if (message.Thumbheight != null && message.hasOwnProperty("Thumbheight"))
                        object.Thumbheight = message.Thumbheight;
                    if (message.Thumbfilemd5 != null && message.hasOwnProperty("Thumbfilemd5"))
                        object.Thumbfilemd5 = options.bytes === String ? $util.base64.encode(message.Thumbfilemd5, 0, message.Thumbfilemd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.Thumbfilemd5) : message.Thumbfilemd5;
                    if (message.Source != null && message.hasOwnProperty("Source"))
                        object.Source = options.bytes === String ? $util.base64.encode(message.Source, 0, message.Source.length) : options.bytes === Array ? Array.prototype.slice.call(message.Source) : message.Source;
                    if (message.Thumbfilesize != null && message.hasOwnProperty("Thumbfilesize"))
                        object.Thumbfilesize = message.Thumbfilesize;
                    if (message.Busitype != null && message.hasOwnProperty("Busitype"))
                        object.Busitype = message.Busitype;
                    if (message.Fromchattype != null && message.hasOwnProperty("Fromchattype"))
                        object.Fromchattype = message.Fromchattype;
                    if (message.Tochattype != null && message.hasOwnProperty("Tochattype"))
                        object.Tochattype = message.Tochattype;
                    if (message.Boolsupportprogressive != null && message.hasOwnProperty("Boolsupportprogressive"))
                        object.Boolsupportprogressive = message.Boolsupportprogressive;
                    if (message.Filewidth != null && message.hasOwnProperty("Filewidth"))
                        object.Filewidth = message.Filewidth;
                    if (message.Fileheight != null && message.hasOwnProperty("Fileheight"))
                        object.Fileheight = message.Fileheight;
                    if (message.Subbusitype != null && message.hasOwnProperty("Subbusitype"))
                        object.Subbusitype = message.Subbusitype;
                    if (message.Videoattr != null && message.hasOwnProperty("Videoattr"))
                        object.Videoattr = message.Videoattr;
                    if (message.Bytesthumbfileurls && message.Bytesthumbfileurls.length) {
                        object.Bytesthumbfileurls = [];
                        for (var j = 0; j < message.Bytesthumbfileurls.length; ++j)
                            object.Bytesthumbfileurls[j] = options.bytes === String ? $util.base64.encode(message.Bytesthumbfileurls[j], 0, message.Bytesthumbfileurls[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.Bytesthumbfileurls[j]) : message.Bytesthumbfileurls[j];
                    }
                    if (message.Bytesvideofileurls && message.Bytesvideofileurls.length) {
                        object.Bytesvideofileurls = [];
                        for (var j = 0; j < message.Bytesvideofileurls.length; ++j)
                            object.Bytesvideofileurls[j] = options.bytes === String ? $util.base64.encode(message.Bytesvideofileurls[j], 0, message.Bytesvideofileurls[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.Bytesvideofileurls[j]) : message.Bytesvideofileurls[j];
                    }
                    if (message.Thumbdownloadflag != null && message.hasOwnProperty("Thumbdownloadflag"))
                        object.Thumbdownloadflag = message.Thumbdownloadflag;
                    if (message.Videodownloadflag != null && message.hasOwnProperty("Videodownloadflag"))
                        object.Videodownloadflag = message.Videodownloadflag;
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    return object;
                };

                /**
                 * Converts this VideoFile to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.VideoFile
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VideoFile.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return VideoFile;
            })();

            ImMsgBody.TipsInfo = (function() {

                /**
                 * Properties of a TipsInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ITipsInfo
                 * @property {number|null} [Sessiontype] TipsInfo Sessiontype
                 * @property {number|Long|null} [Sessionuin] TipsInfo Sessionuin
                 * @property {string|null} [Text] TipsInfo Text
                 */

                /**
                 * Constructs a new TipsInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a TipsInfo.
                 * @implements ITipsInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ITipsInfo=} [properties] Properties to set
                 */
                function TipsInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TipsInfo Sessiontype.
                 * @member {number} Sessiontype
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @instance
                 */
                TipsInfo.prototype.Sessiontype = 0;

                /**
                 * TipsInfo Sessionuin.
                 * @member {number|Long} Sessionuin
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @instance
                 */
                TipsInfo.prototype.Sessionuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TipsInfo Text.
                 * @member {string} Text
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @instance
                 */
                TipsInfo.prototype.Text = "";

                /**
                 * Creates a new TipsInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITipsInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.TipsInfo} TipsInfo instance
                 */
                TipsInfo.create = function create(properties) {
                    return new TipsInfo(properties);
                };

                /**
                 * Encodes the specified TipsInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.TipsInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITipsInfo} message TipsInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TipsInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Sessiontype != null && Object.hasOwnProperty.call(message, "Sessiontype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Sessiontype);
                    if (message.Sessionuin != null && Object.hasOwnProperty.call(message, "Sessionuin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Sessionuin);
                    if (message.Text != null && Object.hasOwnProperty.call(message, "Text"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Text);
                    return writer;
                };

                /**
                 * Encodes the specified TipsInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.TipsInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ITipsInfo} message TipsInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TipsInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TipsInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.TipsInfo} TipsInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TipsInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.TipsInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Sessiontype = reader.int32();
                            break;
                        case 2:
                            message.Sessionuin = reader.int64();
                            break;
                        case 3:
                            message.Text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TipsInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.TipsInfo} TipsInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TipsInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TipsInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TipsInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Sessiontype != null && message.hasOwnProperty("Sessiontype"))
                        if (!$util.isInteger(message.Sessiontype))
                            return "Sessiontype: integer expected";
                    if (message.Sessionuin != null && message.hasOwnProperty("Sessionuin"))
                        if (!$util.isInteger(message.Sessionuin) && !(message.Sessionuin && $util.isInteger(message.Sessionuin.low) && $util.isInteger(message.Sessionuin.high)))
                            return "Sessionuin: integer|Long expected";
                    if (message.Text != null && message.hasOwnProperty("Text"))
                        if (!$util.isString(message.Text))
                            return "Text: string expected";
                    return null;
                };

                /**
                 * Creates a TipsInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.TipsInfo} TipsInfo
                 */
                TipsInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.TipsInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.TipsInfo();
                    if (object.Sessiontype != null)
                        message.Sessiontype = object.Sessiontype | 0;
                    if (object.Sessionuin != null)
                        if ($util.Long)
                            (message.Sessionuin = $util.Long.fromValue(object.Sessionuin)).unsigned = false;
                        else if (typeof object.Sessionuin === "string")
                            message.Sessionuin = parseInt(object.Sessionuin, 10);
                        else if (typeof object.Sessionuin === "number")
                            message.Sessionuin = object.Sessionuin;
                        else if (typeof object.Sessionuin === "object")
                            message.Sessionuin = new $util.LongBits(object.Sessionuin.low >>> 0, object.Sessionuin.high >>> 0).toNumber();
                    if (object.Text != null)
                        message.Text = String(object.Text);
                    return message;
                };

                /**
                 * Creates a plain object from a TipsInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.TipsInfo} message TipsInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TipsInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Sessiontype = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Sessionuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Sessionuin = options.longs === String ? "0" : 0;
                        object.Text = "";
                    }
                    if (message.Sessiontype != null && message.hasOwnProperty("Sessiontype"))
                        object.Sessiontype = message.Sessiontype;
                    if (message.Sessionuin != null && message.hasOwnProperty("Sessionuin"))
                        if (typeof message.Sessionuin === "number")
                            object.Sessionuin = options.longs === String ? String(message.Sessionuin) : message.Sessionuin;
                        else
                            object.Sessionuin = options.longs === String ? $util.Long.prototype.toString.call(message.Sessionuin) : options.longs === Number ? new $util.LongBits(message.Sessionuin.low >>> 0, message.Sessionuin.high >>> 0).toNumber() : message.Sessionuin;
                    if (message.Text != null && message.hasOwnProperty("Text"))
                        object.Text = message.Text;
                    return object;
                };

                /**
                 * Converts this TipsInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.TipsInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TipsInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TipsInfo;
            })();

            ImMsgBody.AnonGroupMsg = (function() {

                /**
                 * Properties of an AnonGroupMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IAnonGroupMsg
                 * @property {number|null} [Flags] AnonGroupMsg Flags
                 * @property {Uint8Array|null} [Anonid] AnonGroupMsg Anonid
                 * @property {Uint8Array|null} [Anonnick] AnonGroupMsg Anonnick
                 * @property {number|null} [Headportrait] AnonGroupMsg Headportrait
                 * @property {number|null} [Expiretime] AnonGroupMsg Expiretime
                 * @property {number|null} [Bubbleid] AnonGroupMsg Bubbleid
                 * @property {Uint8Array|null} [Rankcolor] AnonGroupMsg Rankcolor
                 */

                /**
                 * Constructs a new AnonGroupMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an AnonGroupMsg.
                 * @implements IAnonGroupMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IAnonGroupMsg=} [properties] Properties to set
                 */
                function AnonGroupMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AnonGroupMsg Flags.
                 * @member {number} Flags
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 */
                AnonGroupMsg.prototype.Flags = 0;

                /**
                 * AnonGroupMsg Anonid.
                 * @member {Uint8Array} Anonid
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 */
                AnonGroupMsg.prototype.Anonid = $util.newBuffer([]);

                /**
                 * AnonGroupMsg Anonnick.
                 * @member {Uint8Array} Anonnick
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 */
                AnonGroupMsg.prototype.Anonnick = $util.newBuffer([]);

                /**
                 * AnonGroupMsg Headportrait.
                 * @member {number} Headportrait
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 */
                AnonGroupMsg.prototype.Headportrait = 0;

                /**
                 * AnonGroupMsg Expiretime.
                 * @member {number} Expiretime
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 */
                AnonGroupMsg.prototype.Expiretime = 0;

                /**
                 * AnonGroupMsg Bubbleid.
                 * @member {number} Bubbleid
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 */
                AnonGroupMsg.prototype.Bubbleid = 0;

                /**
                 * AnonGroupMsg Rankcolor.
                 * @member {Uint8Array} Rankcolor
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 */
                AnonGroupMsg.prototype.Rankcolor = $util.newBuffer([]);

                /**
                 * Creates a new AnonGroupMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IAnonGroupMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.AnonGroupMsg} AnonGroupMsg instance
                 */
                AnonGroupMsg.create = function create(properties) {
                    return new AnonGroupMsg(properties);
                };

                /**
                 * Encodes the specified AnonGroupMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.AnonGroupMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IAnonGroupMsg} message AnonGroupMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AnonGroupMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Flags != null && Object.hasOwnProperty.call(message, "Flags"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Flags);
                    if (message.Anonid != null && Object.hasOwnProperty.call(message, "Anonid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Anonid);
                    if (message.Anonnick != null && Object.hasOwnProperty.call(message, "Anonnick"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Anonnick);
                    if (message.Headportrait != null && Object.hasOwnProperty.call(message, "Headportrait"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Headportrait);
                    if (message.Expiretime != null && Object.hasOwnProperty.call(message, "Expiretime"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Expiretime);
                    if (message.Bubbleid != null && Object.hasOwnProperty.call(message, "Bubbleid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Bubbleid);
                    if (message.Rankcolor != null && Object.hasOwnProperty.call(message, "Rankcolor"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Rankcolor);
                    return writer;
                };

                /**
                 * Encodes the specified AnonGroupMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.AnonGroupMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IAnonGroupMsg} message AnonGroupMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AnonGroupMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AnonGroupMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.AnonGroupMsg} AnonGroupMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AnonGroupMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.AnonGroupMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Flags = reader.int32();
                            break;
                        case 2:
                            message.Anonid = reader.bytes();
                            break;
                        case 3:
                            message.Anonnick = reader.bytes();
                            break;
                        case 4:
                            message.Headportrait = reader.int32();
                            break;
                        case 5:
                            message.Expiretime = reader.int32();
                            break;
                        case 6:
                            message.Bubbleid = reader.int32();
                            break;
                        case 7:
                            message.Rankcolor = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AnonGroupMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.AnonGroupMsg} AnonGroupMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AnonGroupMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AnonGroupMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AnonGroupMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        if (!$util.isInteger(message.Flags))
                            return "Flags: integer expected";
                    if (message.Anonid != null && message.hasOwnProperty("Anonid"))
                        if (!(message.Anonid && typeof message.Anonid.length === "number" || $util.isString(message.Anonid)))
                            return "Anonid: buffer expected";
                    if (message.Anonnick != null && message.hasOwnProperty("Anonnick"))
                        if (!(message.Anonnick && typeof message.Anonnick.length === "number" || $util.isString(message.Anonnick)))
                            return "Anonnick: buffer expected";
                    if (message.Headportrait != null && message.hasOwnProperty("Headportrait"))
                        if (!$util.isInteger(message.Headportrait))
                            return "Headportrait: integer expected";
                    if (message.Expiretime != null && message.hasOwnProperty("Expiretime"))
                        if (!$util.isInteger(message.Expiretime))
                            return "Expiretime: integer expected";
                    if (message.Bubbleid != null && message.hasOwnProperty("Bubbleid"))
                        if (!$util.isInteger(message.Bubbleid))
                            return "Bubbleid: integer expected";
                    if (message.Rankcolor != null && message.hasOwnProperty("Rankcolor"))
                        if (!(message.Rankcolor && typeof message.Rankcolor.length === "number" || $util.isString(message.Rankcolor)))
                            return "Rankcolor: buffer expected";
                    return null;
                };

                /**
                 * Creates an AnonGroupMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.AnonGroupMsg} AnonGroupMsg
                 */
                AnonGroupMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.AnonGroupMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.AnonGroupMsg();
                    if (object.Flags != null)
                        message.Flags = object.Flags | 0;
                    if (object.Anonid != null)
                        if (typeof object.Anonid === "string")
                            $util.base64.decode(object.Anonid, message.Anonid = $util.newBuffer($util.base64.length(object.Anonid)), 0);
                        else if (object.Anonid.length)
                            message.Anonid = object.Anonid;
                    if (object.Anonnick != null)
                        if (typeof object.Anonnick === "string")
                            $util.base64.decode(object.Anonnick, message.Anonnick = $util.newBuffer($util.base64.length(object.Anonnick)), 0);
                        else if (object.Anonnick.length)
                            message.Anonnick = object.Anonnick;
                    if (object.Headportrait != null)
                        message.Headportrait = object.Headportrait | 0;
                    if (object.Expiretime != null)
                        message.Expiretime = object.Expiretime | 0;
                    if (object.Bubbleid != null)
                        message.Bubbleid = object.Bubbleid | 0;
                    if (object.Rankcolor != null)
                        if (typeof object.Rankcolor === "string")
                            $util.base64.decode(object.Rankcolor, message.Rankcolor = $util.newBuffer($util.base64.length(object.Rankcolor)), 0);
                        else if (object.Rankcolor.length)
                            message.Rankcolor = object.Rankcolor;
                    return message;
                };

                /**
                 * Creates a plain object from an AnonGroupMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.AnonGroupMsg} message AnonGroupMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AnonGroupMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Flags = 0;
                        if (options.bytes === String)
                            object.Anonid = "";
                        else {
                            object.Anonid = [];
                            if (options.bytes !== Array)
                                object.Anonid = $util.newBuffer(object.Anonid);
                        }
                        if (options.bytes === String)
                            object.Anonnick = "";
                        else {
                            object.Anonnick = [];
                            if (options.bytes !== Array)
                                object.Anonnick = $util.newBuffer(object.Anonnick);
                        }
                        object.Headportrait = 0;
                        object.Expiretime = 0;
                        object.Bubbleid = 0;
                        if (options.bytes === String)
                            object.Rankcolor = "";
                        else {
                            object.Rankcolor = [];
                            if (options.bytes !== Array)
                                object.Rankcolor = $util.newBuffer(object.Rankcolor);
                        }
                    }
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        object.Flags = message.Flags;
                    if (message.Anonid != null && message.hasOwnProperty("Anonid"))
                        object.Anonid = options.bytes === String ? $util.base64.encode(message.Anonid, 0, message.Anonid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Anonid) : message.Anonid;
                    if (message.Anonnick != null && message.hasOwnProperty("Anonnick"))
                        object.Anonnick = options.bytes === String ? $util.base64.encode(message.Anonnick, 0, message.Anonnick.length) : options.bytes === Array ? Array.prototype.slice.call(message.Anonnick) : message.Anonnick;
                    if (message.Headportrait != null && message.hasOwnProperty("Headportrait"))
                        object.Headportrait = message.Headportrait;
                    if (message.Expiretime != null && message.hasOwnProperty("Expiretime"))
                        object.Expiretime = message.Expiretime;
                    if (message.Bubbleid != null && message.hasOwnProperty("Bubbleid"))
                        object.Bubbleid = message.Bubbleid;
                    if (message.Rankcolor != null && message.hasOwnProperty("Rankcolor"))
                        object.Rankcolor = options.bytes === String ? $util.base64.encode(message.Rankcolor, 0, message.Rankcolor.length) : options.bytes === Array ? Array.prototype.slice.call(message.Rankcolor) : message.Rankcolor;
                    return object;
                };

                /**
                 * Converts this AnonGroupMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.AnonGroupMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AnonGroupMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AnonGroupMsg;
            })();

            ImMsgBody.QqLiveOld = (function() {

                /**
                 * Properties of a QqLiveOld.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IQqLiveOld
                 * @property {number|null} [Subcmd] QqLiveOld Subcmd
                 * @property {Uint8Array|null} [Showtext] QqLiveOld Showtext
                 * @property {Uint8Array|null} [Param] QqLiveOld Param
                 * @property {Uint8Array|null} [Introduce] QqLiveOld Introduce
                 */

                /**
                 * Constructs a new QqLiveOld.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a QqLiveOld.
                 * @implements IQqLiveOld
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IQqLiveOld=} [properties] Properties to set
                 */
                function QqLiveOld(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QqLiveOld Subcmd.
                 * @member {number} Subcmd
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @instance
                 */
                QqLiveOld.prototype.Subcmd = 0;

                /**
                 * QqLiveOld Showtext.
                 * @member {Uint8Array} Showtext
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @instance
                 */
                QqLiveOld.prototype.Showtext = $util.newBuffer([]);

                /**
                 * QqLiveOld Param.
                 * @member {Uint8Array} Param
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @instance
                 */
                QqLiveOld.prototype.Param = $util.newBuffer([]);

                /**
                 * QqLiveOld Introduce.
                 * @member {Uint8Array} Introduce
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @instance
                 */
                QqLiveOld.prototype.Introduce = $util.newBuffer([]);

                /**
                 * Creates a new QqLiveOld instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQqLiveOld=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.QqLiveOld} QqLiveOld instance
                 */
                QqLiveOld.create = function create(properties) {
                    return new QqLiveOld(properties);
                };

                /**
                 * Encodes the specified QqLiveOld message. Does not implicitly {@link Msg.MsgField.ImMsgBody.QqLiveOld.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQqLiveOld} message QqLiveOld message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QqLiveOld.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Subcmd != null && Object.hasOwnProperty.call(message, "Subcmd"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Subcmd);
                    if (message.Showtext != null && Object.hasOwnProperty.call(message, "Showtext"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Showtext);
                    if (message.Param != null && Object.hasOwnProperty.call(message, "Param"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Param);
                    if (message.Introduce != null && Object.hasOwnProperty.call(message, "Introduce"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Introduce);
                    return writer;
                };

                /**
                 * Encodes the specified QqLiveOld message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.QqLiveOld.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQqLiveOld} message QqLiveOld message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QqLiveOld.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QqLiveOld message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.QqLiveOld} QqLiveOld
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QqLiveOld.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.QqLiveOld();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Subcmd = reader.int32();
                            break;
                        case 2:
                            message.Showtext = reader.bytes();
                            break;
                        case 3:
                            message.Param = reader.bytes();
                            break;
                        case 4:
                            message.Introduce = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QqLiveOld message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.QqLiveOld} QqLiveOld
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QqLiveOld.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QqLiveOld message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QqLiveOld.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Subcmd != null && message.hasOwnProperty("Subcmd"))
                        if (!$util.isInteger(message.Subcmd))
                            return "Subcmd: integer expected";
                    if (message.Showtext != null && message.hasOwnProperty("Showtext"))
                        if (!(message.Showtext && typeof message.Showtext.length === "number" || $util.isString(message.Showtext)))
                            return "Showtext: buffer expected";
                    if (message.Param != null && message.hasOwnProperty("Param"))
                        if (!(message.Param && typeof message.Param.length === "number" || $util.isString(message.Param)))
                            return "Param: buffer expected";
                    if (message.Introduce != null && message.hasOwnProperty("Introduce"))
                        if (!(message.Introduce && typeof message.Introduce.length === "number" || $util.isString(message.Introduce)))
                            return "Introduce: buffer expected";
                    return null;
                };

                /**
                 * Creates a QqLiveOld message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.QqLiveOld} QqLiveOld
                 */
                QqLiveOld.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.QqLiveOld)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.QqLiveOld();
                    if (object.Subcmd != null)
                        message.Subcmd = object.Subcmd | 0;
                    if (object.Showtext != null)
                        if (typeof object.Showtext === "string")
                            $util.base64.decode(object.Showtext, message.Showtext = $util.newBuffer($util.base64.length(object.Showtext)), 0);
                        else if (object.Showtext.length)
                            message.Showtext = object.Showtext;
                    if (object.Param != null)
                        if (typeof object.Param === "string")
                            $util.base64.decode(object.Param, message.Param = $util.newBuffer($util.base64.length(object.Param)), 0);
                        else if (object.Param.length)
                            message.Param = object.Param;
                    if (object.Introduce != null)
                        if (typeof object.Introduce === "string")
                            $util.base64.decode(object.Introduce, message.Introduce = $util.newBuffer($util.base64.length(object.Introduce)), 0);
                        else if (object.Introduce.length)
                            message.Introduce = object.Introduce;
                    return message;
                };

                /**
                 * Creates a plain object from a QqLiveOld message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.QqLiveOld} message QqLiveOld
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QqLiveOld.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Subcmd = 0;
                        if (options.bytes === String)
                            object.Showtext = "";
                        else {
                            object.Showtext = [];
                            if (options.bytes !== Array)
                                object.Showtext = $util.newBuffer(object.Showtext);
                        }
                        if (options.bytes === String)
                            object.Param = "";
                        else {
                            object.Param = [];
                            if (options.bytes !== Array)
                                object.Param = $util.newBuffer(object.Param);
                        }
                        if (options.bytes === String)
                            object.Introduce = "";
                        else {
                            object.Introduce = [];
                            if (options.bytes !== Array)
                                object.Introduce = $util.newBuffer(object.Introduce);
                        }
                    }
                    if (message.Subcmd != null && message.hasOwnProperty("Subcmd"))
                        object.Subcmd = message.Subcmd;
                    if (message.Showtext != null && message.hasOwnProperty("Showtext"))
                        object.Showtext = options.bytes === String ? $util.base64.encode(message.Showtext, 0, message.Showtext.length) : options.bytes === Array ? Array.prototype.slice.call(message.Showtext) : message.Showtext;
                    if (message.Param != null && message.hasOwnProperty("Param"))
                        object.Param = options.bytes === String ? $util.base64.encode(message.Param, 0, message.Param.length) : options.bytes === Array ? Array.prototype.slice.call(message.Param) : message.Param;
                    if (message.Introduce != null && message.hasOwnProperty("Introduce"))
                        object.Introduce = options.bytes === String ? $util.base64.encode(message.Introduce, 0, message.Introduce.length) : options.bytes === Array ? Array.prototype.slice.call(message.Introduce) : message.Introduce;
                    return object;
                };

                /**
                 * Converts this QqLiveOld to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.QqLiveOld
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QqLiveOld.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QqLiveOld;
            })();

            ImMsgBody.LifeOnline = (function() {

                /**
                 * Properties of a LifeOnline.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ILifeOnline
                 * @property {number|Long|null} [Uniqueid] LifeOnline Uniqueid
                 * @property {number|null} [Op] LifeOnline Op
                 * @property {number|null} [Showtime] LifeOnline Showtime
                 * @property {number|null} [Report] LifeOnline Report
                 * @property {number|null} [Ack] LifeOnline Ack
                 * @property {number|Long|null} [Bitmap] LifeOnline Bitmap
                 * @property {Uint8Array|null} [Gdtimpdata] LifeOnline Gdtimpdata
                 * @property {Uint8Array|null} [Gdtclidata] LifeOnline Gdtclidata
                 * @property {Uint8Array|null} [Viewid] LifeOnline Viewid
                 */

                /**
                 * Constructs a new LifeOnline.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a LifeOnline.
                 * @implements ILifeOnline
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ILifeOnline=} [properties] Properties to set
                 */
                function LifeOnline(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LifeOnline Uniqueid.
                 * @member {number|Long} Uniqueid
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Uniqueid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LifeOnline Op.
                 * @member {number} Op
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Op = 0;

                /**
                 * LifeOnline Showtime.
                 * @member {number} Showtime
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Showtime = 0;

                /**
                 * LifeOnline Report.
                 * @member {number} Report
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Report = 0;

                /**
                 * LifeOnline Ack.
                 * @member {number} Ack
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Ack = 0;

                /**
                 * LifeOnline Bitmap.
                 * @member {number|Long} Bitmap
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Bitmap = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LifeOnline Gdtimpdata.
                 * @member {Uint8Array} Gdtimpdata
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Gdtimpdata = $util.newBuffer([]);

                /**
                 * LifeOnline Gdtclidata.
                 * @member {Uint8Array} Gdtclidata
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Gdtclidata = $util.newBuffer([]);

                /**
                 * LifeOnline Viewid.
                 * @member {Uint8Array} Viewid
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 */
                LifeOnline.prototype.Viewid = $util.newBuffer([]);

                /**
                 * Creates a new LifeOnline instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILifeOnline=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.LifeOnline} LifeOnline instance
                 */
                LifeOnline.create = function create(properties) {
                    return new LifeOnline(properties);
                };

                /**
                 * Encodes the specified LifeOnline message. Does not implicitly {@link Msg.MsgField.ImMsgBody.LifeOnline.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILifeOnline} message LifeOnline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LifeOnline.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Uniqueid != null && Object.hasOwnProperty.call(message, "Uniqueid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Uniqueid);
                    if (message.Op != null && Object.hasOwnProperty.call(message, "Op"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Op);
                    if (message.Showtime != null && Object.hasOwnProperty.call(message, "Showtime"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Showtime);
                    if (message.Report != null && Object.hasOwnProperty.call(message, "Report"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Report);
                    if (message.Ack != null && Object.hasOwnProperty.call(message, "Ack"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Ack);
                    if (message.Bitmap != null && Object.hasOwnProperty.call(message, "Bitmap"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.Bitmap);
                    if (message.Gdtimpdata != null && Object.hasOwnProperty.call(message, "Gdtimpdata"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Gdtimpdata);
                    if (message.Gdtclidata != null && Object.hasOwnProperty.call(message, "Gdtclidata"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Gdtclidata);
                    if (message.Viewid != null && Object.hasOwnProperty.call(message, "Viewid"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.Viewid);
                    return writer;
                };

                /**
                 * Encodes the specified LifeOnline message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.LifeOnline.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILifeOnline} message LifeOnline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LifeOnline.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LifeOnline message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.LifeOnline} LifeOnline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LifeOnline.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.LifeOnline();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Uniqueid = reader.int64();
                            break;
                        case 2:
                            message.Op = reader.int32();
                            break;
                        case 3:
                            message.Showtime = reader.int32();
                            break;
                        case 4:
                            message.Report = reader.int32();
                            break;
                        case 5:
                            message.Ack = reader.int32();
                            break;
                        case 6:
                            message.Bitmap = reader.int64();
                            break;
                        case 7:
                            message.Gdtimpdata = reader.bytes();
                            break;
                        case 8:
                            message.Gdtclidata = reader.bytes();
                            break;
                        case 9:
                            message.Viewid = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LifeOnline message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.LifeOnline} LifeOnline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LifeOnline.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LifeOnline message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LifeOnline.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Uniqueid != null && message.hasOwnProperty("Uniqueid"))
                        if (!$util.isInteger(message.Uniqueid) && !(message.Uniqueid && $util.isInteger(message.Uniqueid.low) && $util.isInteger(message.Uniqueid.high)))
                            return "Uniqueid: integer|Long expected";
                    if (message.Op != null && message.hasOwnProperty("Op"))
                        if (!$util.isInteger(message.Op))
                            return "Op: integer expected";
                    if (message.Showtime != null && message.hasOwnProperty("Showtime"))
                        if (!$util.isInteger(message.Showtime))
                            return "Showtime: integer expected";
                    if (message.Report != null && message.hasOwnProperty("Report"))
                        if (!$util.isInteger(message.Report))
                            return "Report: integer expected";
                    if (message.Ack != null && message.hasOwnProperty("Ack"))
                        if (!$util.isInteger(message.Ack))
                            return "Ack: integer expected";
                    if (message.Bitmap != null && message.hasOwnProperty("Bitmap"))
                        if (!$util.isInteger(message.Bitmap) && !(message.Bitmap && $util.isInteger(message.Bitmap.low) && $util.isInteger(message.Bitmap.high)))
                            return "Bitmap: integer|Long expected";
                    if (message.Gdtimpdata != null && message.hasOwnProperty("Gdtimpdata"))
                        if (!(message.Gdtimpdata && typeof message.Gdtimpdata.length === "number" || $util.isString(message.Gdtimpdata)))
                            return "Gdtimpdata: buffer expected";
                    if (message.Gdtclidata != null && message.hasOwnProperty("Gdtclidata"))
                        if (!(message.Gdtclidata && typeof message.Gdtclidata.length === "number" || $util.isString(message.Gdtclidata)))
                            return "Gdtclidata: buffer expected";
                    if (message.Viewid != null && message.hasOwnProperty("Viewid"))
                        if (!(message.Viewid && typeof message.Viewid.length === "number" || $util.isString(message.Viewid)))
                            return "Viewid: buffer expected";
                    return null;
                };

                /**
                 * Creates a LifeOnline message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.LifeOnline} LifeOnline
                 */
                LifeOnline.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.LifeOnline)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.LifeOnline();
                    if (object.Uniqueid != null)
                        if ($util.Long)
                            (message.Uniqueid = $util.Long.fromValue(object.Uniqueid)).unsigned = false;
                        else if (typeof object.Uniqueid === "string")
                            message.Uniqueid = parseInt(object.Uniqueid, 10);
                        else if (typeof object.Uniqueid === "number")
                            message.Uniqueid = object.Uniqueid;
                        else if (typeof object.Uniqueid === "object")
                            message.Uniqueid = new $util.LongBits(object.Uniqueid.low >>> 0, object.Uniqueid.high >>> 0).toNumber();
                    if (object.Op != null)
                        message.Op = object.Op | 0;
                    if (object.Showtime != null)
                        message.Showtime = object.Showtime | 0;
                    if (object.Report != null)
                        message.Report = object.Report | 0;
                    if (object.Ack != null)
                        message.Ack = object.Ack | 0;
                    if (object.Bitmap != null)
                        if ($util.Long)
                            (message.Bitmap = $util.Long.fromValue(object.Bitmap)).unsigned = false;
                        else if (typeof object.Bitmap === "string")
                            message.Bitmap = parseInt(object.Bitmap, 10);
                        else if (typeof object.Bitmap === "number")
                            message.Bitmap = object.Bitmap;
                        else if (typeof object.Bitmap === "object")
                            message.Bitmap = new $util.LongBits(object.Bitmap.low >>> 0, object.Bitmap.high >>> 0).toNumber();
                    if (object.Gdtimpdata != null)
                        if (typeof object.Gdtimpdata === "string")
                            $util.base64.decode(object.Gdtimpdata, message.Gdtimpdata = $util.newBuffer($util.base64.length(object.Gdtimpdata)), 0);
                        else if (object.Gdtimpdata.length)
                            message.Gdtimpdata = object.Gdtimpdata;
                    if (object.Gdtclidata != null)
                        if (typeof object.Gdtclidata === "string")
                            $util.base64.decode(object.Gdtclidata, message.Gdtclidata = $util.newBuffer($util.base64.length(object.Gdtclidata)), 0);
                        else if (object.Gdtclidata.length)
                            message.Gdtclidata = object.Gdtclidata;
                    if (object.Viewid != null)
                        if (typeof object.Viewid === "string")
                            $util.base64.decode(object.Viewid, message.Viewid = $util.newBuffer($util.base64.length(object.Viewid)), 0);
                        else if (object.Viewid.length)
                            message.Viewid = object.Viewid;
                    return message;
                };

                /**
                 * Creates a plain object from a LifeOnline message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.LifeOnline} message LifeOnline
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LifeOnline.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Uniqueid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Uniqueid = options.longs === String ? "0" : 0;
                        object.Op = 0;
                        object.Showtime = 0;
                        object.Report = 0;
                        object.Ack = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Bitmap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Bitmap = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.Gdtimpdata = "";
                        else {
                            object.Gdtimpdata = [];
                            if (options.bytes !== Array)
                                object.Gdtimpdata = $util.newBuffer(object.Gdtimpdata);
                        }
                        if (options.bytes === String)
                            object.Gdtclidata = "";
                        else {
                            object.Gdtclidata = [];
                            if (options.bytes !== Array)
                                object.Gdtclidata = $util.newBuffer(object.Gdtclidata);
                        }
                        if (options.bytes === String)
                            object.Viewid = "";
                        else {
                            object.Viewid = [];
                            if (options.bytes !== Array)
                                object.Viewid = $util.newBuffer(object.Viewid);
                        }
                    }
                    if (message.Uniqueid != null && message.hasOwnProperty("Uniqueid"))
                        if (typeof message.Uniqueid === "number")
                            object.Uniqueid = options.longs === String ? String(message.Uniqueid) : message.Uniqueid;
                        else
                            object.Uniqueid = options.longs === String ? $util.Long.prototype.toString.call(message.Uniqueid) : options.longs === Number ? new $util.LongBits(message.Uniqueid.low >>> 0, message.Uniqueid.high >>> 0).toNumber() : message.Uniqueid;
                    if (message.Op != null && message.hasOwnProperty("Op"))
                        object.Op = message.Op;
                    if (message.Showtime != null && message.hasOwnProperty("Showtime"))
                        object.Showtime = message.Showtime;
                    if (message.Report != null && message.hasOwnProperty("Report"))
                        object.Report = message.Report;
                    if (message.Ack != null && message.hasOwnProperty("Ack"))
                        object.Ack = message.Ack;
                    if (message.Bitmap != null && message.hasOwnProperty("Bitmap"))
                        if (typeof message.Bitmap === "number")
                            object.Bitmap = options.longs === String ? String(message.Bitmap) : message.Bitmap;
                        else
                            object.Bitmap = options.longs === String ? $util.Long.prototype.toString.call(message.Bitmap) : options.longs === Number ? new $util.LongBits(message.Bitmap.low >>> 0, message.Bitmap.high >>> 0).toNumber() : message.Bitmap;
                    if (message.Gdtimpdata != null && message.hasOwnProperty("Gdtimpdata"))
                        object.Gdtimpdata = options.bytes === String ? $util.base64.encode(message.Gdtimpdata, 0, message.Gdtimpdata.length) : options.bytes === Array ? Array.prototype.slice.call(message.Gdtimpdata) : message.Gdtimpdata;
                    if (message.Gdtclidata != null && message.hasOwnProperty("Gdtclidata"))
                        object.Gdtclidata = options.bytes === String ? $util.base64.encode(message.Gdtclidata, 0, message.Gdtclidata.length) : options.bytes === Array ? Array.prototype.slice.call(message.Gdtclidata) : message.Gdtclidata;
                    if (message.Viewid != null && message.hasOwnProperty("Viewid"))
                        object.Viewid = options.bytes === String ? $util.base64.encode(message.Viewid, 0, message.Viewid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Viewid) : message.Viewid;
                    return object;
                };

                /**
                 * Converts this LifeOnline to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.LifeOnline
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LifeOnline.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LifeOnline;
            })();

            ImMsgBody.QQWalletAioElem = (function() {

                /**
                 * Properties of a QQWalletAioElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IQQWalletAioElem
                 * @property {number|null} [Background] QQWalletAioElem Background
                 * @property {number|null} [Icon] QQWalletAioElem Icon
                 * @property {Uint8Array|null} [Title] QQWalletAioElem Title
                 * @property {Uint8Array|null} [Subtitle] QQWalletAioElem Subtitle
                 * @property {Uint8Array|null} [Content] QQWalletAioElem Content
                 * @property {Uint8Array|null} [Linkurl] QQWalletAioElem Linkurl
                 * @property {Uint8Array|null} [Blackstripe] QQWalletAioElem Blackstripe
                 * @property {Uint8Array|null} [Notice] QQWalletAioElem Notice
                 * @property {number|null} [Titlecolor] QQWalletAioElem Titlecolor
                 * @property {number|null} [Subtitlecolor] QQWalletAioElem Subtitlecolor
                 * @property {Uint8Array|null} [Actionspriority] QQWalletAioElem Actionspriority
                 * @property {Uint8Array|null} [Jumpurl] QQWalletAioElem Jumpurl
                 * @property {Uint8Array|null} [Nativeios] QQWalletAioElem Nativeios
                 * @property {Uint8Array|null} [Nativeandroid] QQWalletAioElem Nativeandroid
                 * @property {Uint8Array|null} [Iconurl] QQWalletAioElem Iconurl
                 * @property {number|null} [Contentcolor] QQWalletAioElem Contentcolor
                 * @property {number|null} [Contentbgcolor] QQWalletAioElem Contentbgcolor
                 * @property {Uint8Array|null} [Aioimageleft] QQWalletAioElem Aioimageleft
                 * @property {Uint8Array|null} [Aioimageright] QQWalletAioElem Aioimageright
                 * @property {Uint8Array|null} [Cftimage] QQWalletAioElem Cftimage
                 * @property {Uint8Array|null} [Pbreserve] QQWalletAioElem Pbreserve
                 */

                /**
                 * Constructs a new QQWalletAioElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a QQWalletAioElem.
                 * @implements IQQWalletAioElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioElem=} [properties] Properties to set
                 */
                function QQWalletAioElem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QQWalletAioElem Background.
                 * @member {number} Background
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Background = 0;

                /**
                 * QQWalletAioElem Icon.
                 * @member {number} Icon
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Icon = 0;

                /**
                 * QQWalletAioElem Title.
                 * @member {Uint8Array} Title
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Title = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Subtitle.
                 * @member {Uint8Array} Subtitle
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Subtitle = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Content.
                 * @member {Uint8Array} Content
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Content = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Linkurl.
                 * @member {Uint8Array} Linkurl
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Linkurl = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Blackstripe.
                 * @member {Uint8Array} Blackstripe
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Blackstripe = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Notice.
                 * @member {Uint8Array} Notice
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Notice = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Titlecolor.
                 * @member {number} Titlecolor
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Titlecolor = 0;

                /**
                 * QQWalletAioElem Subtitlecolor.
                 * @member {number} Subtitlecolor
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Subtitlecolor = 0;

                /**
                 * QQWalletAioElem Actionspriority.
                 * @member {Uint8Array} Actionspriority
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Actionspriority = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Jumpurl.
                 * @member {Uint8Array} Jumpurl
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Jumpurl = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Nativeios.
                 * @member {Uint8Array} Nativeios
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Nativeios = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Nativeandroid.
                 * @member {Uint8Array} Nativeandroid
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Nativeandroid = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Iconurl.
                 * @member {Uint8Array} Iconurl
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Iconurl = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Contentcolor.
                 * @member {number} Contentcolor
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Contentcolor = 0;

                /**
                 * QQWalletAioElem Contentbgcolor.
                 * @member {number} Contentbgcolor
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Contentbgcolor = 0;

                /**
                 * QQWalletAioElem Aioimageleft.
                 * @member {Uint8Array} Aioimageleft
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Aioimageleft = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Aioimageright.
                 * @member {Uint8Array} Aioimageright
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Aioimageright = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Cftimage.
                 * @member {Uint8Array} Cftimage
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Cftimage = $util.newBuffer([]);

                /**
                 * QQWalletAioElem Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 */
                QQWalletAioElem.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * Creates a new QQWalletAioElem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioElem} QQWalletAioElem instance
                 */
                QQWalletAioElem.create = function create(properties) {
                    return new QQWalletAioElem(properties);
                };

                /**
                 * Encodes the specified QQWalletAioElem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.QQWalletAioElem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioElem} message QQWalletAioElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QQWalletAioElem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Background != null && Object.hasOwnProperty.call(message, "Background"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Background);
                    if (message.Icon != null && Object.hasOwnProperty.call(message, "Icon"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Icon);
                    if (message.Title != null && Object.hasOwnProperty.call(message, "Title"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Title);
                    if (message.Subtitle != null && Object.hasOwnProperty.call(message, "Subtitle"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Subtitle);
                    if (message.Content != null && Object.hasOwnProperty.call(message, "Content"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Content);
                    if (message.Linkurl != null && Object.hasOwnProperty.call(message, "Linkurl"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.Linkurl);
                    if (message.Blackstripe != null && Object.hasOwnProperty.call(message, "Blackstripe"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Blackstripe);
                    if (message.Notice != null && Object.hasOwnProperty.call(message, "Notice"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Notice);
                    if (message.Titlecolor != null && Object.hasOwnProperty.call(message, "Titlecolor"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Titlecolor);
                    if (message.Subtitlecolor != null && Object.hasOwnProperty.call(message, "Subtitlecolor"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Subtitlecolor);
                    if (message.Actionspriority != null && Object.hasOwnProperty.call(message, "Actionspriority"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Actionspriority);
                    if (message.Jumpurl != null && Object.hasOwnProperty.call(message, "Jumpurl"))
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.Jumpurl);
                    if (message.Nativeios != null && Object.hasOwnProperty.call(message, "Nativeios"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.Nativeios);
                    if (message.Nativeandroid != null && Object.hasOwnProperty.call(message, "Nativeandroid"))
                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.Nativeandroid);
                    if (message.Iconurl != null && Object.hasOwnProperty.call(message, "Iconurl"))
                        writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.Iconurl);
                    if (message.Contentcolor != null && Object.hasOwnProperty.call(message, "Contentcolor"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.Contentcolor);
                    if (message.Contentbgcolor != null && Object.hasOwnProperty.call(message, "Contentbgcolor"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.Contentbgcolor);
                    if (message.Aioimageleft != null && Object.hasOwnProperty.call(message, "Aioimageleft"))
                        writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.Aioimageleft);
                    if (message.Aioimageright != null && Object.hasOwnProperty.call(message, "Aioimageright"))
                        writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.Aioimageright);
                    if (message.Cftimage != null && Object.hasOwnProperty.call(message, "Cftimage"))
                        writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.Cftimage);
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.Pbreserve);
                    return writer;
                };

                /**
                 * Encodes the specified QQWalletAioElem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.QQWalletAioElem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioElem} message QQWalletAioElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QQWalletAioElem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QQWalletAioElem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioElem} QQWalletAioElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QQWalletAioElem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.QQWalletAioElem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Background = reader.int32();
                            break;
                        case 2:
                            message.Icon = reader.int32();
                            break;
                        case 3:
                            message.Title = reader.bytes();
                            break;
                        case 4:
                            message.Subtitle = reader.bytes();
                            break;
                        case 5:
                            message.Content = reader.bytes();
                            break;
                        case 6:
                            message.Linkurl = reader.bytes();
                            break;
                        case 7:
                            message.Blackstripe = reader.bytes();
                            break;
                        case 8:
                            message.Notice = reader.bytes();
                            break;
                        case 9:
                            message.Titlecolor = reader.int32();
                            break;
                        case 10:
                            message.Subtitlecolor = reader.int32();
                            break;
                        case 11:
                            message.Actionspriority = reader.bytes();
                            break;
                        case 12:
                            message.Jumpurl = reader.bytes();
                            break;
                        case 13:
                            message.Nativeios = reader.bytes();
                            break;
                        case 14:
                            message.Nativeandroid = reader.bytes();
                            break;
                        case 15:
                            message.Iconurl = reader.bytes();
                            break;
                        case 16:
                            message.Contentcolor = reader.int32();
                            break;
                        case 17:
                            message.Contentbgcolor = reader.int32();
                            break;
                        case 18:
                            message.Aioimageleft = reader.bytes();
                            break;
                        case 19:
                            message.Aioimageright = reader.bytes();
                            break;
                        case 20:
                            message.Cftimage = reader.bytes();
                            break;
                        case 21:
                            message.Pbreserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QQWalletAioElem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioElem} QQWalletAioElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QQWalletAioElem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QQWalletAioElem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QQWalletAioElem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Background != null && message.hasOwnProperty("Background"))
                        if (!$util.isInteger(message.Background))
                            return "Background: integer expected";
                    if (message.Icon != null && message.hasOwnProperty("Icon"))
                        if (!$util.isInteger(message.Icon))
                            return "Icon: integer expected";
                    if (message.Title != null && message.hasOwnProperty("Title"))
                        if (!(message.Title && typeof message.Title.length === "number" || $util.isString(message.Title)))
                            return "Title: buffer expected";
                    if (message.Subtitle != null && message.hasOwnProperty("Subtitle"))
                        if (!(message.Subtitle && typeof message.Subtitle.length === "number" || $util.isString(message.Subtitle)))
                            return "Subtitle: buffer expected";
                    if (message.Content != null && message.hasOwnProperty("Content"))
                        if (!(message.Content && typeof message.Content.length === "number" || $util.isString(message.Content)))
                            return "Content: buffer expected";
                    if (message.Linkurl != null && message.hasOwnProperty("Linkurl"))
                        if (!(message.Linkurl && typeof message.Linkurl.length === "number" || $util.isString(message.Linkurl)))
                            return "Linkurl: buffer expected";
                    if (message.Blackstripe != null && message.hasOwnProperty("Blackstripe"))
                        if (!(message.Blackstripe && typeof message.Blackstripe.length === "number" || $util.isString(message.Blackstripe)))
                            return "Blackstripe: buffer expected";
                    if (message.Notice != null && message.hasOwnProperty("Notice"))
                        if (!(message.Notice && typeof message.Notice.length === "number" || $util.isString(message.Notice)))
                            return "Notice: buffer expected";
                    if (message.Titlecolor != null && message.hasOwnProperty("Titlecolor"))
                        if (!$util.isInteger(message.Titlecolor))
                            return "Titlecolor: integer expected";
                    if (message.Subtitlecolor != null && message.hasOwnProperty("Subtitlecolor"))
                        if (!$util.isInteger(message.Subtitlecolor))
                            return "Subtitlecolor: integer expected";
                    if (message.Actionspriority != null && message.hasOwnProperty("Actionspriority"))
                        if (!(message.Actionspriority && typeof message.Actionspriority.length === "number" || $util.isString(message.Actionspriority)))
                            return "Actionspriority: buffer expected";
                    if (message.Jumpurl != null && message.hasOwnProperty("Jumpurl"))
                        if (!(message.Jumpurl && typeof message.Jumpurl.length === "number" || $util.isString(message.Jumpurl)))
                            return "Jumpurl: buffer expected";
                    if (message.Nativeios != null && message.hasOwnProperty("Nativeios"))
                        if (!(message.Nativeios && typeof message.Nativeios.length === "number" || $util.isString(message.Nativeios)))
                            return "Nativeios: buffer expected";
                    if (message.Nativeandroid != null && message.hasOwnProperty("Nativeandroid"))
                        if (!(message.Nativeandroid && typeof message.Nativeandroid.length === "number" || $util.isString(message.Nativeandroid)))
                            return "Nativeandroid: buffer expected";
                    if (message.Iconurl != null && message.hasOwnProperty("Iconurl"))
                        if (!(message.Iconurl && typeof message.Iconurl.length === "number" || $util.isString(message.Iconurl)))
                            return "Iconurl: buffer expected";
                    if (message.Contentcolor != null && message.hasOwnProperty("Contentcolor"))
                        if (!$util.isInteger(message.Contentcolor))
                            return "Contentcolor: integer expected";
                    if (message.Contentbgcolor != null && message.hasOwnProperty("Contentbgcolor"))
                        if (!$util.isInteger(message.Contentbgcolor))
                            return "Contentbgcolor: integer expected";
                    if (message.Aioimageleft != null && message.hasOwnProperty("Aioimageleft"))
                        if (!(message.Aioimageleft && typeof message.Aioimageleft.length === "number" || $util.isString(message.Aioimageleft)))
                            return "Aioimageleft: buffer expected";
                    if (message.Aioimageright != null && message.hasOwnProperty("Aioimageright"))
                        if (!(message.Aioimageright && typeof message.Aioimageright.length === "number" || $util.isString(message.Aioimageright)))
                            return "Aioimageright: buffer expected";
                    if (message.Cftimage != null && message.hasOwnProperty("Cftimage"))
                        if (!(message.Cftimage && typeof message.Cftimage.length === "number" || $util.isString(message.Cftimage)))
                            return "Cftimage: buffer expected";
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a QQWalletAioElem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioElem} QQWalletAioElem
                 */
                QQWalletAioElem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.QQWalletAioElem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.QQWalletAioElem();
                    if (object.Background != null)
                        message.Background = object.Background | 0;
                    if (object.Icon != null)
                        message.Icon = object.Icon | 0;
                    if (object.Title != null)
                        if (typeof object.Title === "string")
                            $util.base64.decode(object.Title, message.Title = $util.newBuffer($util.base64.length(object.Title)), 0);
                        else if (object.Title.length)
                            message.Title = object.Title;
                    if (object.Subtitle != null)
                        if (typeof object.Subtitle === "string")
                            $util.base64.decode(object.Subtitle, message.Subtitle = $util.newBuffer($util.base64.length(object.Subtitle)), 0);
                        else if (object.Subtitle.length)
                            message.Subtitle = object.Subtitle;
                    if (object.Content != null)
                        if (typeof object.Content === "string")
                            $util.base64.decode(object.Content, message.Content = $util.newBuffer($util.base64.length(object.Content)), 0);
                        else if (object.Content.length)
                            message.Content = object.Content;
                    if (object.Linkurl != null)
                        if (typeof object.Linkurl === "string")
                            $util.base64.decode(object.Linkurl, message.Linkurl = $util.newBuffer($util.base64.length(object.Linkurl)), 0);
                        else if (object.Linkurl.length)
                            message.Linkurl = object.Linkurl;
                    if (object.Blackstripe != null)
                        if (typeof object.Blackstripe === "string")
                            $util.base64.decode(object.Blackstripe, message.Blackstripe = $util.newBuffer($util.base64.length(object.Blackstripe)), 0);
                        else if (object.Blackstripe.length)
                            message.Blackstripe = object.Blackstripe;
                    if (object.Notice != null)
                        if (typeof object.Notice === "string")
                            $util.base64.decode(object.Notice, message.Notice = $util.newBuffer($util.base64.length(object.Notice)), 0);
                        else if (object.Notice.length)
                            message.Notice = object.Notice;
                    if (object.Titlecolor != null)
                        message.Titlecolor = object.Titlecolor | 0;
                    if (object.Subtitlecolor != null)
                        message.Subtitlecolor = object.Subtitlecolor | 0;
                    if (object.Actionspriority != null)
                        if (typeof object.Actionspriority === "string")
                            $util.base64.decode(object.Actionspriority, message.Actionspriority = $util.newBuffer($util.base64.length(object.Actionspriority)), 0);
                        else if (object.Actionspriority.length)
                            message.Actionspriority = object.Actionspriority;
                    if (object.Jumpurl != null)
                        if (typeof object.Jumpurl === "string")
                            $util.base64.decode(object.Jumpurl, message.Jumpurl = $util.newBuffer($util.base64.length(object.Jumpurl)), 0);
                        else if (object.Jumpurl.length)
                            message.Jumpurl = object.Jumpurl;
                    if (object.Nativeios != null)
                        if (typeof object.Nativeios === "string")
                            $util.base64.decode(object.Nativeios, message.Nativeios = $util.newBuffer($util.base64.length(object.Nativeios)), 0);
                        else if (object.Nativeios.length)
                            message.Nativeios = object.Nativeios;
                    if (object.Nativeandroid != null)
                        if (typeof object.Nativeandroid === "string")
                            $util.base64.decode(object.Nativeandroid, message.Nativeandroid = $util.newBuffer($util.base64.length(object.Nativeandroid)), 0);
                        else if (object.Nativeandroid.length)
                            message.Nativeandroid = object.Nativeandroid;
                    if (object.Iconurl != null)
                        if (typeof object.Iconurl === "string")
                            $util.base64.decode(object.Iconurl, message.Iconurl = $util.newBuffer($util.base64.length(object.Iconurl)), 0);
                        else if (object.Iconurl.length)
                            message.Iconurl = object.Iconurl;
                    if (object.Contentcolor != null)
                        message.Contentcolor = object.Contentcolor | 0;
                    if (object.Contentbgcolor != null)
                        message.Contentbgcolor = object.Contentbgcolor | 0;
                    if (object.Aioimageleft != null)
                        if (typeof object.Aioimageleft === "string")
                            $util.base64.decode(object.Aioimageleft, message.Aioimageleft = $util.newBuffer($util.base64.length(object.Aioimageleft)), 0);
                        else if (object.Aioimageleft.length)
                            message.Aioimageleft = object.Aioimageleft;
                    if (object.Aioimageright != null)
                        if (typeof object.Aioimageright === "string")
                            $util.base64.decode(object.Aioimageright, message.Aioimageright = $util.newBuffer($util.base64.length(object.Aioimageright)), 0);
                        else if (object.Aioimageright.length)
                            message.Aioimageright = object.Aioimageright;
                    if (object.Cftimage != null)
                        if (typeof object.Cftimage === "string")
                            $util.base64.decode(object.Cftimage, message.Cftimage = $util.newBuffer($util.base64.length(object.Cftimage)), 0);
                        else if (object.Cftimage.length)
                            message.Cftimage = object.Cftimage;
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    return message;
                };

                /**
                 * Creates a plain object from a QQWalletAioElem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.QQWalletAioElem} message QQWalletAioElem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QQWalletAioElem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Background = 0;
                        object.Icon = 0;
                        if (options.bytes === String)
                            object.Title = "";
                        else {
                            object.Title = [];
                            if (options.bytes !== Array)
                                object.Title = $util.newBuffer(object.Title);
                        }
                        if (options.bytes === String)
                            object.Subtitle = "";
                        else {
                            object.Subtitle = [];
                            if (options.bytes !== Array)
                                object.Subtitle = $util.newBuffer(object.Subtitle);
                        }
                        if (options.bytes === String)
                            object.Content = "";
                        else {
                            object.Content = [];
                            if (options.bytes !== Array)
                                object.Content = $util.newBuffer(object.Content);
                        }
                        if (options.bytes === String)
                            object.Linkurl = "";
                        else {
                            object.Linkurl = [];
                            if (options.bytes !== Array)
                                object.Linkurl = $util.newBuffer(object.Linkurl);
                        }
                        if (options.bytes === String)
                            object.Blackstripe = "";
                        else {
                            object.Blackstripe = [];
                            if (options.bytes !== Array)
                                object.Blackstripe = $util.newBuffer(object.Blackstripe);
                        }
                        if (options.bytes === String)
                            object.Notice = "";
                        else {
                            object.Notice = [];
                            if (options.bytes !== Array)
                                object.Notice = $util.newBuffer(object.Notice);
                        }
                        object.Titlecolor = 0;
                        object.Subtitlecolor = 0;
                        if (options.bytes === String)
                            object.Actionspriority = "";
                        else {
                            object.Actionspriority = [];
                            if (options.bytes !== Array)
                                object.Actionspriority = $util.newBuffer(object.Actionspriority);
                        }
                        if (options.bytes === String)
                            object.Jumpurl = "";
                        else {
                            object.Jumpurl = [];
                            if (options.bytes !== Array)
                                object.Jumpurl = $util.newBuffer(object.Jumpurl);
                        }
                        if (options.bytes === String)
                            object.Nativeios = "";
                        else {
                            object.Nativeios = [];
                            if (options.bytes !== Array)
                                object.Nativeios = $util.newBuffer(object.Nativeios);
                        }
                        if (options.bytes === String)
                            object.Nativeandroid = "";
                        else {
                            object.Nativeandroid = [];
                            if (options.bytes !== Array)
                                object.Nativeandroid = $util.newBuffer(object.Nativeandroid);
                        }
                        if (options.bytes === String)
                            object.Iconurl = "";
                        else {
                            object.Iconurl = [];
                            if (options.bytes !== Array)
                                object.Iconurl = $util.newBuffer(object.Iconurl);
                        }
                        object.Contentcolor = 0;
                        object.Contentbgcolor = 0;
                        if (options.bytes === String)
                            object.Aioimageleft = "";
                        else {
                            object.Aioimageleft = [];
                            if (options.bytes !== Array)
                                object.Aioimageleft = $util.newBuffer(object.Aioimageleft);
                        }
                        if (options.bytes === String)
                            object.Aioimageright = "";
                        else {
                            object.Aioimageright = [];
                            if (options.bytes !== Array)
                                object.Aioimageright = $util.newBuffer(object.Aioimageright);
                        }
                        if (options.bytes === String)
                            object.Cftimage = "";
                        else {
                            object.Cftimage = [];
                            if (options.bytes !== Array)
                                object.Cftimage = $util.newBuffer(object.Cftimage);
                        }
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                    }
                    if (message.Background != null && message.hasOwnProperty("Background"))
                        object.Background = message.Background;
                    if (message.Icon != null && message.hasOwnProperty("Icon"))
                        object.Icon = message.Icon;
                    if (message.Title != null && message.hasOwnProperty("Title"))
                        object.Title = options.bytes === String ? $util.base64.encode(message.Title, 0, message.Title.length) : options.bytes === Array ? Array.prototype.slice.call(message.Title) : message.Title;
                    if (message.Subtitle != null && message.hasOwnProperty("Subtitle"))
                        object.Subtitle = options.bytes === String ? $util.base64.encode(message.Subtitle, 0, message.Subtitle.length) : options.bytes === Array ? Array.prototype.slice.call(message.Subtitle) : message.Subtitle;
                    if (message.Content != null && message.hasOwnProperty("Content"))
                        object.Content = options.bytes === String ? $util.base64.encode(message.Content, 0, message.Content.length) : options.bytes === Array ? Array.prototype.slice.call(message.Content) : message.Content;
                    if (message.Linkurl != null && message.hasOwnProperty("Linkurl"))
                        object.Linkurl = options.bytes === String ? $util.base64.encode(message.Linkurl, 0, message.Linkurl.length) : options.bytes === Array ? Array.prototype.slice.call(message.Linkurl) : message.Linkurl;
                    if (message.Blackstripe != null && message.hasOwnProperty("Blackstripe"))
                        object.Blackstripe = options.bytes === String ? $util.base64.encode(message.Blackstripe, 0, message.Blackstripe.length) : options.bytes === Array ? Array.prototype.slice.call(message.Blackstripe) : message.Blackstripe;
                    if (message.Notice != null && message.hasOwnProperty("Notice"))
                        object.Notice = options.bytes === String ? $util.base64.encode(message.Notice, 0, message.Notice.length) : options.bytes === Array ? Array.prototype.slice.call(message.Notice) : message.Notice;
                    if (message.Titlecolor != null && message.hasOwnProperty("Titlecolor"))
                        object.Titlecolor = message.Titlecolor;
                    if (message.Subtitlecolor != null && message.hasOwnProperty("Subtitlecolor"))
                        object.Subtitlecolor = message.Subtitlecolor;
                    if (message.Actionspriority != null && message.hasOwnProperty("Actionspriority"))
                        object.Actionspriority = options.bytes === String ? $util.base64.encode(message.Actionspriority, 0, message.Actionspriority.length) : options.bytes === Array ? Array.prototype.slice.call(message.Actionspriority) : message.Actionspriority;
                    if (message.Jumpurl != null && message.hasOwnProperty("Jumpurl"))
                        object.Jumpurl = options.bytes === String ? $util.base64.encode(message.Jumpurl, 0, message.Jumpurl.length) : options.bytes === Array ? Array.prototype.slice.call(message.Jumpurl) : message.Jumpurl;
                    if (message.Nativeios != null && message.hasOwnProperty("Nativeios"))
                        object.Nativeios = options.bytes === String ? $util.base64.encode(message.Nativeios, 0, message.Nativeios.length) : options.bytes === Array ? Array.prototype.slice.call(message.Nativeios) : message.Nativeios;
                    if (message.Nativeandroid != null && message.hasOwnProperty("Nativeandroid"))
                        object.Nativeandroid = options.bytes === String ? $util.base64.encode(message.Nativeandroid, 0, message.Nativeandroid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Nativeandroid) : message.Nativeandroid;
                    if (message.Iconurl != null && message.hasOwnProperty("Iconurl"))
                        object.Iconurl = options.bytes === String ? $util.base64.encode(message.Iconurl, 0, message.Iconurl.length) : options.bytes === Array ? Array.prototype.slice.call(message.Iconurl) : message.Iconurl;
                    if (message.Contentcolor != null && message.hasOwnProperty("Contentcolor"))
                        object.Contentcolor = message.Contentcolor;
                    if (message.Contentbgcolor != null && message.hasOwnProperty("Contentbgcolor"))
                        object.Contentbgcolor = message.Contentbgcolor;
                    if (message.Aioimageleft != null && message.hasOwnProperty("Aioimageleft"))
                        object.Aioimageleft = options.bytes === String ? $util.base64.encode(message.Aioimageleft, 0, message.Aioimageleft.length) : options.bytes === Array ? Array.prototype.slice.call(message.Aioimageleft) : message.Aioimageleft;
                    if (message.Aioimageright != null && message.hasOwnProperty("Aioimageright"))
                        object.Aioimageright = options.bytes === String ? $util.base64.encode(message.Aioimageright, 0, message.Aioimageright.length) : options.bytes === Array ? Array.prototype.slice.call(message.Aioimageright) : message.Aioimageright;
                    if (message.Cftimage != null && message.hasOwnProperty("Cftimage"))
                        object.Cftimage = options.bytes === String ? $util.base64.encode(message.Cftimage, 0, message.Cftimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.Cftimage) : message.Cftimage;
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    return object;
                };

                /**
                 * Converts this QQWalletAioElem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioElem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QQWalletAioElem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QQWalletAioElem;
            })();

            ImMsgBody.QQWalletAioBody = (function() {

                /**
                 * Properties of a QQWalletAioBody.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IQQWalletAioBody
                 * @property {number|Long|null} [Senduin] QQWalletAioBody Senduin
                 * @property {Msg.MsgField.ImMsgBody.IQQWalletAioElem|null} [Sender] QQWalletAioBody Sender
                 * @property {Msg.MsgField.ImMsgBody.IQQWalletAioElem|null} [Receiver] QQWalletAioBody Receiver
                 * @property {number|null} [Sint32channelid] QQWalletAioBody Sint32channelid
                 * @property {number|null} [Sint32templateid] QQWalletAioBody Sint32templateid
                 * @property {number|null} [Resend] QQWalletAioBody Resend
                 * @property {number|null} [Msgpriority] QQWalletAioBody Msgpriority
                 * @property {number|null} [Sint32redtype] QQWalletAioBody Sint32redtype
                 * @property {Uint8Array|null} [Billno] QQWalletAioBody Billno
                 * @property {Uint8Array|null} [Authkey] QQWalletAioBody Authkey
                 * @property {number|null} [Sint32sessiontype] QQWalletAioBody Sint32sessiontype
                 * @property {number|null} [Sint32msgtype] QQWalletAioBody Sint32msgtype
                 * @property {number|null} [Sint32envelopeid] QQWalletAioBody Sint32envelopeid
                 * @property {Uint8Array|null} [Name] QQWalletAioBody Name
                 * @property {number|null} [Sint32conftype] QQWalletAioBody Sint32conftype
                 * @property {number|null} [Sint32msgfrom] QQWalletAioBody Sint32msgfrom
                 * @property {Uint8Array|null} [Pcbody] QQWalletAioBody Pcbody
                 * @property {Uint8Array|null} [Ingindex] QQWalletAioBody Ingindex
                 * @property {number|null} [Redchannel] QQWalletAioBody Redchannel
                 * @property {Array.<number|Long>|null} [Grapuin] QQWalletAioBody Grapuin
                 * @property {Uint8Array|null} [Pbreserve] QQWalletAioBody Pbreserve
                 */

                /**
                 * Constructs a new QQWalletAioBody.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a QQWalletAioBody.
                 * @implements IQQWalletAioBody
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioBody=} [properties] Properties to set
                 */
                function QQWalletAioBody(properties) {
                    this.Grapuin = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QQWalletAioBody Senduin.
                 * @member {number|Long} Senduin
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Senduin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * QQWalletAioBody Sender.
                 * @member {Msg.MsgField.ImMsgBody.IQQWalletAioElem|null|undefined} Sender
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sender = null;

                /**
                 * QQWalletAioBody Receiver.
                 * @member {Msg.MsgField.ImMsgBody.IQQWalletAioElem|null|undefined} Receiver
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Receiver = null;

                /**
                 * QQWalletAioBody Sint32channelid.
                 * @member {number} Sint32channelid
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32channelid = 0;

                /**
                 * QQWalletAioBody Sint32templateid.
                 * @member {number} Sint32templateid
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32templateid = 0;

                /**
                 * QQWalletAioBody Resend.
                 * @member {number} Resend
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Resend = 0;

                /**
                 * QQWalletAioBody Msgpriority.
                 * @member {number} Msgpriority
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Msgpriority = 0;

                /**
                 * QQWalletAioBody Sint32redtype.
                 * @member {number} Sint32redtype
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32redtype = 0;

                /**
                 * QQWalletAioBody Billno.
                 * @member {Uint8Array} Billno
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Billno = $util.newBuffer([]);

                /**
                 * QQWalletAioBody Authkey.
                 * @member {Uint8Array} Authkey
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Authkey = $util.newBuffer([]);

                /**
                 * QQWalletAioBody Sint32sessiontype.
                 * @member {number} Sint32sessiontype
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32sessiontype = 0;

                /**
                 * QQWalletAioBody Sint32msgtype.
                 * @member {number} Sint32msgtype
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32msgtype = 0;

                /**
                 * QQWalletAioBody Sint32envelopeid.
                 * @member {number} Sint32envelopeid
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32envelopeid = 0;

                /**
                 * QQWalletAioBody Name.
                 * @member {Uint8Array} Name
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Name = $util.newBuffer([]);

                /**
                 * QQWalletAioBody Sint32conftype.
                 * @member {number} Sint32conftype
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32conftype = 0;

                /**
                 * QQWalletAioBody Sint32msgfrom.
                 * @member {number} Sint32msgfrom
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Sint32msgfrom = 0;

                /**
                 * QQWalletAioBody Pcbody.
                 * @member {Uint8Array} Pcbody
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Pcbody = $util.newBuffer([]);

                /**
                 * QQWalletAioBody Ingindex.
                 * @member {Uint8Array} Ingindex
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Ingindex = $util.newBuffer([]);

                /**
                 * QQWalletAioBody Redchannel.
                 * @member {number} Redchannel
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Redchannel = 0;

                /**
                 * QQWalletAioBody Grapuin.
                 * @member {Array.<number|Long>} Grapuin
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Grapuin = $util.emptyArray;

                /**
                 * QQWalletAioBody Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 */
                QQWalletAioBody.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * Creates a new QQWalletAioBody instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioBody=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioBody} QQWalletAioBody instance
                 */
                QQWalletAioBody.create = function create(properties) {
                    return new QQWalletAioBody(properties);
                };

                /**
                 * Encodes the specified QQWalletAioBody message. Does not implicitly {@link Msg.MsgField.ImMsgBody.QQWalletAioBody.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioBody} message QQWalletAioBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QQWalletAioBody.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Senduin != null && Object.hasOwnProperty.call(message, "Senduin"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Senduin);
                    if (message.Sender != null && Object.hasOwnProperty.call(message, "Sender"))
                        $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.encode(message.Sender, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.Receiver != null && Object.hasOwnProperty.call(message, "Receiver"))
                        $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.encode(message.Receiver, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.Sint32channelid != null && Object.hasOwnProperty.call(message, "Sint32channelid"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Sint32channelid);
                    if (message.Sint32templateid != null && Object.hasOwnProperty.call(message, "Sint32templateid"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Sint32templateid);
                    if (message.Resend != null && Object.hasOwnProperty.call(message, "Resend"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Resend);
                    if (message.Msgpriority != null && Object.hasOwnProperty.call(message, "Msgpriority"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Msgpriority);
                    if (message.Sint32redtype != null && Object.hasOwnProperty.call(message, "Sint32redtype"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Sint32redtype);
                    if (message.Billno != null && Object.hasOwnProperty.call(message, "Billno"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.Billno);
                    if (message.Authkey != null && Object.hasOwnProperty.call(message, "Authkey"))
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.Authkey);
                    if (message.Sint32sessiontype != null && Object.hasOwnProperty.call(message, "Sint32sessiontype"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.Sint32sessiontype);
                    if (message.Sint32msgtype != null && Object.hasOwnProperty.call(message, "Sint32msgtype"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.Sint32msgtype);
                    if (message.Sint32envelopeid != null && Object.hasOwnProperty.call(message, "Sint32envelopeid"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.Sint32envelopeid);
                    if (message.Name != null && Object.hasOwnProperty.call(message, "Name"))
                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.Name);
                    if (message.Sint32conftype != null && Object.hasOwnProperty.call(message, "Sint32conftype"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.Sint32conftype);
                    if (message.Sint32msgfrom != null && Object.hasOwnProperty.call(message, "Sint32msgfrom"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.Sint32msgfrom);
                    if (message.Pcbody != null && Object.hasOwnProperty.call(message, "Pcbody"))
                        writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.Pcbody);
                    if (message.Ingindex != null && Object.hasOwnProperty.call(message, "Ingindex"))
                        writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.Ingindex);
                    if (message.Redchannel != null && Object.hasOwnProperty.call(message, "Redchannel"))
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.Redchannel);
                    if (message.Grapuin != null && message.Grapuin.length) {
                        writer.uint32(/* id 20, wireType 2 =*/162).fork();
                        for (var i = 0; i < message.Grapuin.length; ++i)
                            writer.int64(message.Grapuin[i]);
                        writer.ldelim();
                    }
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.Pbreserve);
                    return writer;
                };

                /**
                 * Encodes the specified QQWalletAioBody message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.QQWalletAioBody.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletAioBody} message QQWalletAioBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QQWalletAioBody.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QQWalletAioBody message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioBody} QQWalletAioBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QQWalletAioBody.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.QQWalletAioBody();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Senduin = reader.int64();
                            break;
                        case 2:
                            message.Sender = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.Receiver = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.Sint32channelid = reader.int32();
                            break;
                        case 5:
                            message.Sint32templateid = reader.int32();
                            break;
                        case 6:
                            message.Resend = reader.int32();
                            break;
                        case 7:
                            message.Msgpriority = reader.int32();
                            break;
                        case 8:
                            message.Sint32redtype = reader.int32();
                            break;
                        case 9:
                            message.Billno = reader.bytes();
                            break;
                        case 10:
                            message.Authkey = reader.bytes();
                            break;
                        case 11:
                            message.Sint32sessiontype = reader.int32();
                            break;
                        case 12:
                            message.Sint32msgtype = reader.int32();
                            break;
                        case 13:
                            message.Sint32envelopeid = reader.int32();
                            break;
                        case 14:
                            message.Name = reader.bytes();
                            break;
                        case 15:
                            message.Sint32conftype = reader.int32();
                            break;
                        case 16:
                            message.Sint32msgfrom = reader.int32();
                            break;
                        case 17:
                            message.Pcbody = reader.bytes();
                            break;
                        case 18:
                            message.Ingindex = reader.bytes();
                            break;
                        case 19:
                            message.Redchannel = reader.int32();
                            break;
                        case 20:
                            if (!(message.Grapuin && message.Grapuin.length))
                                message.Grapuin = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.Grapuin.push(reader.int64());
                            } else
                                message.Grapuin.push(reader.int64());
                            break;
                        case 21:
                            message.Pbreserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QQWalletAioBody message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioBody} QQWalletAioBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QQWalletAioBody.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QQWalletAioBody message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QQWalletAioBody.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Senduin != null && message.hasOwnProperty("Senduin"))
                        if (!$util.isInteger(message.Senduin) && !(message.Senduin && $util.isInteger(message.Senduin.low) && $util.isInteger(message.Senduin.high)))
                            return "Senduin: integer|Long expected";
                    if (message.Sender != null && message.hasOwnProperty("Sender")) {
                        var error = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.verify(message.Sender);
                        if (error)
                            return "Sender." + error;
                    }
                    if (message.Receiver != null && message.hasOwnProperty("Receiver")) {
                        var error = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.verify(message.Receiver);
                        if (error)
                            return "Receiver." + error;
                    }
                    if (message.Sint32channelid != null && message.hasOwnProperty("Sint32channelid"))
                        if (!$util.isInteger(message.Sint32channelid))
                            return "Sint32channelid: integer expected";
                    if (message.Sint32templateid != null && message.hasOwnProperty("Sint32templateid"))
                        if (!$util.isInteger(message.Sint32templateid))
                            return "Sint32templateid: integer expected";
                    if (message.Resend != null && message.hasOwnProperty("Resend"))
                        if (!$util.isInteger(message.Resend))
                            return "Resend: integer expected";
                    if (message.Msgpriority != null && message.hasOwnProperty("Msgpriority"))
                        if (!$util.isInteger(message.Msgpriority))
                            return "Msgpriority: integer expected";
                    if (message.Sint32redtype != null && message.hasOwnProperty("Sint32redtype"))
                        if (!$util.isInteger(message.Sint32redtype))
                            return "Sint32redtype: integer expected";
                    if (message.Billno != null && message.hasOwnProperty("Billno"))
                        if (!(message.Billno && typeof message.Billno.length === "number" || $util.isString(message.Billno)))
                            return "Billno: buffer expected";
                    if (message.Authkey != null && message.hasOwnProperty("Authkey"))
                        if (!(message.Authkey && typeof message.Authkey.length === "number" || $util.isString(message.Authkey)))
                            return "Authkey: buffer expected";
                    if (message.Sint32sessiontype != null && message.hasOwnProperty("Sint32sessiontype"))
                        if (!$util.isInteger(message.Sint32sessiontype))
                            return "Sint32sessiontype: integer expected";
                    if (message.Sint32msgtype != null && message.hasOwnProperty("Sint32msgtype"))
                        if (!$util.isInteger(message.Sint32msgtype))
                            return "Sint32msgtype: integer expected";
                    if (message.Sint32envelopeid != null && message.hasOwnProperty("Sint32envelopeid"))
                        if (!$util.isInteger(message.Sint32envelopeid))
                            return "Sint32envelopeid: integer expected";
                    if (message.Name != null && message.hasOwnProperty("Name"))
                        if (!(message.Name && typeof message.Name.length === "number" || $util.isString(message.Name)))
                            return "Name: buffer expected";
                    if (message.Sint32conftype != null && message.hasOwnProperty("Sint32conftype"))
                        if (!$util.isInteger(message.Sint32conftype))
                            return "Sint32conftype: integer expected";
                    if (message.Sint32msgfrom != null && message.hasOwnProperty("Sint32msgfrom"))
                        if (!$util.isInteger(message.Sint32msgfrom))
                            return "Sint32msgfrom: integer expected";
                    if (message.Pcbody != null && message.hasOwnProperty("Pcbody"))
                        if (!(message.Pcbody && typeof message.Pcbody.length === "number" || $util.isString(message.Pcbody)))
                            return "Pcbody: buffer expected";
                    if (message.Ingindex != null && message.hasOwnProperty("Ingindex"))
                        if (!(message.Ingindex && typeof message.Ingindex.length === "number" || $util.isString(message.Ingindex)))
                            return "Ingindex: buffer expected";
                    if (message.Redchannel != null && message.hasOwnProperty("Redchannel"))
                        if (!$util.isInteger(message.Redchannel))
                            return "Redchannel: integer expected";
                    if (message.Grapuin != null && message.hasOwnProperty("Grapuin")) {
                        if (!Array.isArray(message.Grapuin))
                            return "Grapuin: array expected";
                        for (var i = 0; i < message.Grapuin.length; ++i)
                            if (!$util.isInteger(message.Grapuin[i]) && !(message.Grapuin[i] && $util.isInteger(message.Grapuin[i].low) && $util.isInteger(message.Grapuin[i].high)))
                                return "Grapuin: integer|Long[] expected";
                    }
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a QQWalletAioBody message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletAioBody} QQWalletAioBody
                 */
                QQWalletAioBody.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.QQWalletAioBody)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.QQWalletAioBody();
                    if (object.Senduin != null)
                        if ($util.Long)
                            (message.Senduin = $util.Long.fromValue(object.Senduin)).unsigned = false;
                        else if (typeof object.Senduin === "string")
                            message.Senduin = parseInt(object.Senduin, 10);
                        else if (typeof object.Senduin === "number")
                            message.Senduin = object.Senduin;
                        else if (typeof object.Senduin === "object")
                            message.Senduin = new $util.LongBits(object.Senduin.low >>> 0, object.Senduin.high >>> 0).toNumber();
                    if (object.Sender != null) {
                        if (typeof object.Sender !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.QQWalletAioBody.Sender: object expected");
                        message.Sender = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.fromObject(object.Sender);
                    }
                    if (object.Receiver != null) {
                        if (typeof object.Receiver !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.QQWalletAioBody.Receiver: object expected");
                        message.Receiver = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.fromObject(object.Receiver);
                    }
                    if (object.Sint32channelid != null)
                        message.Sint32channelid = object.Sint32channelid | 0;
                    if (object.Sint32templateid != null)
                        message.Sint32templateid = object.Sint32templateid | 0;
                    if (object.Resend != null)
                        message.Resend = object.Resend | 0;
                    if (object.Msgpriority != null)
                        message.Msgpriority = object.Msgpriority | 0;
                    if (object.Sint32redtype != null)
                        message.Sint32redtype = object.Sint32redtype | 0;
                    if (object.Billno != null)
                        if (typeof object.Billno === "string")
                            $util.base64.decode(object.Billno, message.Billno = $util.newBuffer($util.base64.length(object.Billno)), 0);
                        else if (object.Billno.length)
                            message.Billno = object.Billno;
                    if (object.Authkey != null)
                        if (typeof object.Authkey === "string")
                            $util.base64.decode(object.Authkey, message.Authkey = $util.newBuffer($util.base64.length(object.Authkey)), 0);
                        else if (object.Authkey.length)
                            message.Authkey = object.Authkey;
                    if (object.Sint32sessiontype != null)
                        message.Sint32sessiontype = object.Sint32sessiontype | 0;
                    if (object.Sint32msgtype != null)
                        message.Sint32msgtype = object.Sint32msgtype | 0;
                    if (object.Sint32envelopeid != null)
                        message.Sint32envelopeid = object.Sint32envelopeid | 0;
                    if (object.Name != null)
                        if (typeof object.Name === "string")
                            $util.base64.decode(object.Name, message.Name = $util.newBuffer($util.base64.length(object.Name)), 0);
                        else if (object.Name.length)
                            message.Name = object.Name;
                    if (object.Sint32conftype != null)
                        message.Sint32conftype = object.Sint32conftype | 0;
                    if (object.Sint32msgfrom != null)
                        message.Sint32msgfrom = object.Sint32msgfrom | 0;
                    if (object.Pcbody != null)
                        if (typeof object.Pcbody === "string")
                            $util.base64.decode(object.Pcbody, message.Pcbody = $util.newBuffer($util.base64.length(object.Pcbody)), 0);
                        else if (object.Pcbody.length)
                            message.Pcbody = object.Pcbody;
                    if (object.Ingindex != null)
                        if (typeof object.Ingindex === "string")
                            $util.base64.decode(object.Ingindex, message.Ingindex = $util.newBuffer($util.base64.length(object.Ingindex)), 0);
                        else if (object.Ingindex.length)
                            message.Ingindex = object.Ingindex;
                    if (object.Redchannel != null)
                        message.Redchannel = object.Redchannel | 0;
                    if (object.Grapuin) {
                        if (!Array.isArray(object.Grapuin))
                            throw TypeError(".Msg.MsgField.ImMsgBody.QQWalletAioBody.Grapuin: array expected");
                        message.Grapuin = [];
                        for (var i = 0; i < object.Grapuin.length; ++i)
                            if ($util.Long)
                                (message.Grapuin[i] = $util.Long.fromValue(object.Grapuin[i])).unsigned = false;
                            else if (typeof object.Grapuin[i] === "string")
                                message.Grapuin[i] = parseInt(object.Grapuin[i], 10);
                            else if (typeof object.Grapuin[i] === "number")
                                message.Grapuin[i] = object.Grapuin[i];
                            else if (typeof object.Grapuin[i] === "object")
                                message.Grapuin[i] = new $util.LongBits(object.Grapuin[i].low >>> 0, object.Grapuin[i].high >>> 0).toNumber();
                    }
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    return message;
                };

                /**
                 * Creates a plain object from a QQWalletAioBody message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.QQWalletAioBody} message QQWalletAioBody
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QQWalletAioBody.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.Grapuin = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Senduin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Senduin = options.longs === String ? "0" : 0;
                        object.Sender = null;
                        object.Receiver = null;
                        object.Sint32channelid = 0;
                        object.Sint32templateid = 0;
                        object.Resend = 0;
                        object.Msgpriority = 0;
                        object.Sint32redtype = 0;
                        if (options.bytes === String)
                            object.Billno = "";
                        else {
                            object.Billno = [];
                            if (options.bytes !== Array)
                                object.Billno = $util.newBuffer(object.Billno);
                        }
                        if (options.bytes === String)
                            object.Authkey = "";
                        else {
                            object.Authkey = [];
                            if (options.bytes !== Array)
                                object.Authkey = $util.newBuffer(object.Authkey);
                        }
                        object.Sint32sessiontype = 0;
                        object.Sint32msgtype = 0;
                        object.Sint32envelopeid = 0;
                        if (options.bytes === String)
                            object.Name = "";
                        else {
                            object.Name = [];
                            if (options.bytes !== Array)
                                object.Name = $util.newBuffer(object.Name);
                        }
                        object.Sint32conftype = 0;
                        object.Sint32msgfrom = 0;
                        if (options.bytes === String)
                            object.Pcbody = "";
                        else {
                            object.Pcbody = [];
                            if (options.bytes !== Array)
                                object.Pcbody = $util.newBuffer(object.Pcbody);
                        }
                        if (options.bytes === String)
                            object.Ingindex = "";
                        else {
                            object.Ingindex = [];
                            if (options.bytes !== Array)
                                object.Ingindex = $util.newBuffer(object.Ingindex);
                        }
                        object.Redchannel = 0;
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                    }
                    if (message.Senduin != null && message.hasOwnProperty("Senduin"))
                        if (typeof message.Senduin === "number")
                            object.Senduin = options.longs === String ? String(message.Senduin) : message.Senduin;
                        else
                            object.Senduin = options.longs === String ? $util.Long.prototype.toString.call(message.Senduin) : options.longs === Number ? new $util.LongBits(message.Senduin.low >>> 0, message.Senduin.high >>> 0).toNumber() : message.Senduin;
                    if (message.Sender != null && message.hasOwnProperty("Sender"))
                        object.Sender = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.toObject(message.Sender, options);
                    if (message.Receiver != null && message.hasOwnProperty("Receiver"))
                        object.Receiver = $root.Msg.MsgField.ImMsgBody.QQWalletAioElem.toObject(message.Receiver, options);
                    if (message.Sint32channelid != null && message.hasOwnProperty("Sint32channelid"))
                        object.Sint32channelid = message.Sint32channelid;
                    if (message.Sint32templateid != null && message.hasOwnProperty("Sint32templateid"))
                        object.Sint32templateid = message.Sint32templateid;
                    if (message.Resend != null && message.hasOwnProperty("Resend"))
                        object.Resend = message.Resend;
                    if (message.Msgpriority != null && message.hasOwnProperty("Msgpriority"))
                        object.Msgpriority = message.Msgpriority;
                    if (message.Sint32redtype != null && message.hasOwnProperty("Sint32redtype"))
                        object.Sint32redtype = message.Sint32redtype;
                    if (message.Billno != null && message.hasOwnProperty("Billno"))
                        object.Billno = options.bytes === String ? $util.base64.encode(message.Billno, 0, message.Billno.length) : options.bytes === Array ? Array.prototype.slice.call(message.Billno) : message.Billno;
                    if (message.Authkey != null && message.hasOwnProperty("Authkey"))
                        object.Authkey = options.bytes === String ? $util.base64.encode(message.Authkey, 0, message.Authkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.Authkey) : message.Authkey;
                    if (message.Sint32sessiontype != null && message.hasOwnProperty("Sint32sessiontype"))
                        object.Sint32sessiontype = message.Sint32sessiontype;
                    if (message.Sint32msgtype != null && message.hasOwnProperty("Sint32msgtype"))
                        object.Sint32msgtype = message.Sint32msgtype;
                    if (message.Sint32envelopeid != null && message.hasOwnProperty("Sint32envelopeid"))
                        object.Sint32envelopeid = message.Sint32envelopeid;
                    if (message.Name != null && message.hasOwnProperty("Name"))
                        object.Name = options.bytes === String ? $util.base64.encode(message.Name, 0, message.Name.length) : options.bytes === Array ? Array.prototype.slice.call(message.Name) : message.Name;
                    if (message.Sint32conftype != null && message.hasOwnProperty("Sint32conftype"))
                        object.Sint32conftype = message.Sint32conftype;
                    if (message.Sint32msgfrom != null && message.hasOwnProperty("Sint32msgfrom"))
                        object.Sint32msgfrom = message.Sint32msgfrom;
                    if (message.Pcbody != null && message.hasOwnProperty("Pcbody"))
                        object.Pcbody = options.bytes === String ? $util.base64.encode(message.Pcbody, 0, message.Pcbody.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pcbody) : message.Pcbody;
                    if (message.Ingindex != null && message.hasOwnProperty("Ingindex"))
                        object.Ingindex = options.bytes === String ? $util.base64.encode(message.Ingindex, 0, message.Ingindex.length) : options.bytes === Array ? Array.prototype.slice.call(message.Ingindex) : message.Ingindex;
                    if (message.Redchannel != null && message.hasOwnProperty("Redchannel"))
                        object.Redchannel = message.Redchannel;
                    if (message.Grapuin && message.Grapuin.length) {
                        object.Grapuin = [];
                        for (var j = 0; j < message.Grapuin.length; ++j)
                            if (typeof message.Grapuin[j] === "number")
                                object.Grapuin[j] = options.longs === String ? String(message.Grapuin[j]) : message.Grapuin[j];
                            else
                                object.Grapuin[j] = options.longs === String ? $util.Long.prototype.toString.call(message.Grapuin[j]) : options.longs === Number ? new $util.LongBits(message.Grapuin[j].low >>> 0, message.Grapuin[j].high >>> 0).toNumber() : message.Grapuin[j];
                    }
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    return object;
                };

                /**
                 * Converts this QQWalletAioBody to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletAioBody
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QQWalletAioBody.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QQWalletAioBody;
            })();

            ImMsgBody.QQWalletMsg = (function() {

                /**
                 * Properties of a QQWalletMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IQQWalletMsg
                 * @property {Msg.MsgField.ImMsgBody.IQQWalletAioBody|null} [AioBody] QQWalletMsg AioBody
                 */

                /**
                 * Constructs a new QQWalletMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a QQWalletMsg.
                 * @implements IQQWalletMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletMsg=} [properties] Properties to set
                 */
                function QQWalletMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QQWalletMsg AioBody.
                 * @member {Msg.MsgField.ImMsgBody.IQQWalletAioBody|null|undefined} AioBody
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @instance
                 */
                QQWalletMsg.prototype.AioBody = null;

                /**
                 * Creates a new QQWalletMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletMsg} QQWalletMsg instance
                 */
                QQWalletMsg.create = function create(properties) {
                    return new QQWalletMsg(properties);
                };

                /**
                 * Encodes the specified QQWalletMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.QQWalletMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletMsg} message QQWalletMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QQWalletMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.AioBody != null && Object.hasOwnProperty.call(message, "AioBody"))
                        $root.Msg.MsgField.ImMsgBody.QQWalletAioBody.encode(message.AioBody, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified QQWalletMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.QQWalletMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IQQWalletMsg} message QQWalletMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QQWalletMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QQWalletMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletMsg} QQWalletMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QQWalletMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.QQWalletMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.AioBody = $root.Msg.MsgField.ImMsgBody.QQWalletAioBody.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QQWalletMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletMsg} QQWalletMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QQWalletMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QQWalletMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QQWalletMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.AioBody != null && message.hasOwnProperty("AioBody")) {
                        var error = $root.Msg.MsgField.ImMsgBody.QQWalletAioBody.verify(message.AioBody);
                        if (error)
                            return "AioBody." + error;
                    }
                    return null;
                };

                /**
                 * Creates a QQWalletMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.QQWalletMsg} QQWalletMsg
                 */
                QQWalletMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.QQWalletMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.QQWalletMsg();
                    if (object.AioBody != null) {
                        if (typeof object.AioBody !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.QQWalletMsg.AioBody: object expected");
                        message.AioBody = $root.Msg.MsgField.ImMsgBody.QQWalletAioBody.fromObject(object.AioBody);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QQWalletMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.QQWalletMsg} message QQWalletMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QQWalletMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.AioBody = null;
                    if (message.AioBody != null && message.hasOwnProperty("AioBody"))
                        object.AioBody = $root.Msg.MsgField.ImMsgBody.QQWalletAioBody.toObject(message.AioBody, options);
                    return object;
                };

                /**
                 * Converts this QQWalletMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.QQWalletMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QQWalletMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QQWalletMsg;
            })();

            ImMsgBody.CrmElem = (function() {

                /**
                 * Properties of a CrmElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ICrmElem
                 * @property {Uint8Array|null} [Crmbuf] CrmElem Crmbuf
                 * @property {Uint8Array|null} [Msgresid] CrmElem Msgresid
                 * @property {number|null} [Qidianflag] CrmElem Qidianflag
                 * @property {number|null} [Pushflag] CrmElem Pushflag
                 * @property {number|null} [Countflag] CrmElem Countflag
                 */

                /**
                 * Constructs a new CrmElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a CrmElem.
                 * @implements ICrmElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ICrmElem=} [properties] Properties to set
                 */
                function CrmElem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CrmElem Crmbuf.
                 * @member {Uint8Array} Crmbuf
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @instance
                 */
                CrmElem.prototype.Crmbuf = $util.newBuffer([]);

                /**
                 * CrmElem Msgresid.
                 * @member {Uint8Array} Msgresid
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @instance
                 */
                CrmElem.prototype.Msgresid = $util.newBuffer([]);

                /**
                 * CrmElem Qidianflag.
                 * @member {number} Qidianflag
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @instance
                 */
                CrmElem.prototype.Qidianflag = 0;

                /**
                 * CrmElem Pushflag.
                 * @member {number} Pushflag
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @instance
                 */
                CrmElem.prototype.Pushflag = 0;

                /**
                 * CrmElem Countflag.
                 * @member {number} Countflag
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @instance
                 */
                CrmElem.prototype.Countflag = 0;

                /**
                 * Creates a new CrmElem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICrmElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.CrmElem} CrmElem instance
                 */
                CrmElem.create = function create(properties) {
                    return new CrmElem(properties);
                };

                /**
                 * Encodes the specified CrmElem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.CrmElem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICrmElem} message CrmElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CrmElem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Crmbuf != null && Object.hasOwnProperty.call(message, "Crmbuf"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Crmbuf);
                    if (message.Msgresid != null && Object.hasOwnProperty.call(message, "Msgresid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Msgresid);
                    if (message.Qidianflag != null && Object.hasOwnProperty.call(message, "Qidianflag"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Qidianflag);
                    if (message.Pushflag != null && Object.hasOwnProperty.call(message, "Pushflag"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Pushflag);
                    if (message.Countflag != null && Object.hasOwnProperty.call(message, "Countflag"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Countflag);
                    return writer;
                };

                /**
                 * Encodes the specified CrmElem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.CrmElem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICrmElem} message CrmElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CrmElem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CrmElem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.CrmElem} CrmElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CrmElem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.CrmElem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Crmbuf = reader.bytes();
                            break;
                        case 2:
                            message.Msgresid = reader.bytes();
                            break;
                        case 3:
                            message.Qidianflag = reader.int32();
                            break;
                        case 4:
                            message.Pushflag = reader.int32();
                            break;
                        case 5:
                            message.Countflag = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CrmElem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.CrmElem} CrmElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CrmElem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CrmElem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CrmElem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Crmbuf != null && message.hasOwnProperty("Crmbuf"))
                        if (!(message.Crmbuf && typeof message.Crmbuf.length === "number" || $util.isString(message.Crmbuf)))
                            return "Crmbuf: buffer expected";
                    if (message.Msgresid != null && message.hasOwnProperty("Msgresid"))
                        if (!(message.Msgresid && typeof message.Msgresid.length === "number" || $util.isString(message.Msgresid)))
                            return "Msgresid: buffer expected";
                    if (message.Qidianflag != null && message.hasOwnProperty("Qidianflag"))
                        if (!$util.isInteger(message.Qidianflag))
                            return "Qidianflag: integer expected";
                    if (message.Pushflag != null && message.hasOwnProperty("Pushflag"))
                        if (!$util.isInteger(message.Pushflag))
                            return "Pushflag: integer expected";
                    if (message.Countflag != null && message.hasOwnProperty("Countflag"))
                        if (!$util.isInteger(message.Countflag))
                            return "Countflag: integer expected";
                    return null;
                };

                /**
                 * Creates a CrmElem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.CrmElem} CrmElem
                 */
                CrmElem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.CrmElem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.CrmElem();
                    if (object.Crmbuf != null)
                        if (typeof object.Crmbuf === "string")
                            $util.base64.decode(object.Crmbuf, message.Crmbuf = $util.newBuffer($util.base64.length(object.Crmbuf)), 0);
                        else if (object.Crmbuf.length)
                            message.Crmbuf = object.Crmbuf;
                    if (object.Msgresid != null)
                        if (typeof object.Msgresid === "string")
                            $util.base64.decode(object.Msgresid, message.Msgresid = $util.newBuffer($util.base64.length(object.Msgresid)), 0);
                        else if (object.Msgresid.length)
                            message.Msgresid = object.Msgresid;
                    if (object.Qidianflag != null)
                        message.Qidianflag = object.Qidianflag | 0;
                    if (object.Pushflag != null)
                        message.Pushflag = object.Pushflag | 0;
                    if (object.Countflag != null)
                        message.Countflag = object.Countflag | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a CrmElem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.CrmElem} message CrmElem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CrmElem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Crmbuf = "";
                        else {
                            object.Crmbuf = [];
                            if (options.bytes !== Array)
                                object.Crmbuf = $util.newBuffer(object.Crmbuf);
                        }
                        if (options.bytes === String)
                            object.Msgresid = "";
                        else {
                            object.Msgresid = [];
                            if (options.bytes !== Array)
                                object.Msgresid = $util.newBuffer(object.Msgresid);
                        }
                        object.Qidianflag = 0;
                        object.Pushflag = 0;
                        object.Countflag = 0;
                    }
                    if (message.Crmbuf != null && message.hasOwnProperty("Crmbuf"))
                        object.Crmbuf = options.bytes === String ? $util.base64.encode(message.Crmbuf, 0, message.Crmbuf.length) : options.bytes === Array ? Array.prototype.slice.call(message.Crmbuf) : message.Crmbuf;
                    if (message.Msgresid != null && message.hasOwnProperty("Msgresid"))
                        object.Msgresid = options.bytes === String ? $util.base64.encode(message.Msgresid, 0, message.Msgresid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Msgresid) : message.Msgresid;
                    if (message.Qidianflag != null && message.hasOwnProperty("Qidianflag"))
                        object.Qidianflag = message.Qidianflag;
                    if (message.Pushflag != null && message.hasOwnProperty("Pushflag"))
                        object.Pushflag = message.Pushflag;
                    if (message.Countflag != null && message.hasOwnProperty("Countflag"))
                        object.Countflag = message.Countflag;
                    return object;
                };

                /**
                 * Converts this CrmElem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.CrmElem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CrmElem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CrmElem;
            })();

            ImMsgBody.ConferenceTipsInfo = (function() {

                /**
                 * Properties of a ConferenceTipsInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IConferenceTipsInfo
                 * @property {number|null} [Sessiontype] ConferenceTipsInfo Sessiontype
                 * @property {number|Long|null} [Sessionuin] ConferenceTipsInfo Sessionuin
                 * @property {string|null} [Text] ConferenceTipsInfo Text
                 */

                /**
                 * Constructs a new ConferenceTipsInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a ConferenceTipsInfo.
                 * @implements IConferenceTipsInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IConferenceTipsInfo=} [properties] Properties to set
                 */
                function ConferenceTipsInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConferenceTipsInfo Sessiontype.
                 * @member {number} Sessiontype
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @instance
                 */
                ConferenceTipsInfo.prototype.Sessiontype = 0;

                /**
                 * ConferenceTipsInfo Sessionuin.
                 * @member {number|Long} Sessionuin
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @instance
                 */
                ConferenceTipsInfo.prototype.Sessionuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ConferenceTipsInfo Text.
                 * @member {string} Text
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @instance
                 */
                ConferenceTipsInfo.prototype.Text = "";

                /**
                 * Creates a new ConferenceTipsInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IConferenceTipsInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.ConferenceTipsInfo} ConferenceTipsInfo instance
                 */
                ConferenceTipsInfo.create = function create(properties) {
                    return new ConferenceTipsInfo(properties);
                };

                /**
                 * Encodes the specified ConferenceTipsInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.ConferenceTipsInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IConferenceTipsInfo} message ConferenceTipsInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConferenceTipsInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Sessiontype != null && Object.hasOwnProperty.call(message, "Sessiontype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Sessiontype);
                    if (message.Sessionuin != null && Object.hasOwnProperty.call(message, "Sessionuin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Sessionuin);
                    if (message.Text != null && Object.hasOwnProperty.call(message, "Text"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Text);
                    return writer;
                };

                /**
                 * Encodes the specified ConferenceTipsInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.ConferenceTipsInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IConferenceTipsInfo} message ConferenceTipsInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConferenceTipsInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ConferenceTipsInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.ConferenceTipsInfo} ConferenceTipsInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConferenceTipsInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Sessiontype = reader.int32();
                            break;
                        case 2:
                            message.Sessionuin = reader.int64();
                            break;
                        case 3:
                            message.Text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ConferenceTipsInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.ConferenceTipsInfo} ConferenceTipsInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConferenceTipsInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ConferenceTipsInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConferenceTipsInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Sessiontype != null && message.hasOwnProperty("Sessiontype"))
                        if (!$util.isInteger(message.Sessiontype))
                            return "Sessiontype: integer expected";
                    if (message.Sessionuin != null && message.hasOwnProperty("Sessionuin"))
                        if (!$util.isInteger(message.Sessionuin) && !(message.Sessionuin && $util.isInteger(message.Sessionuin.low) && $util.isInteger(message.Sessionuin.high)))
                            return "Sessionuin: integer|Long expected";
                    if (message.Text != null && message.hasOwnProperty("Text"))
                        if (!$util.isString(message.Text))
                            return "Text: string expected";
                    return null;
                };

                /**
                 * Creates a ConferenceTipsInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.ConferenceTipsInfo} ConferenceTipsInfo
                 */
                ConferenceTipsInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo();
                    if (object.Sessiontype != null)
                        message.Sessiontype = object.Sessiontype | 0;
                    if (object.Sessionuin != null)
                        if ($util.Long)
                            (message.Sessionuin = $util.Long.fromValue(object.Sessionuin)).unsigned = false;
                        else if (typeof object.Sessionuin === "string")
                            message.Sessionuin = parseInt(object.Sessionuin, 10);
                        else if (typeof object.Sessionuin === "number")
                            message.Sessionuin = object.Sessionuin;
                        else if (typeof object.Sessionuin === "object")
                            message.Sessionuin = new $util.LongBits(object.Sessionuin.low >>> 0, object.Sessionuin.high >>> 0).toNumber();
                    if (object.Text != null)
                        message.Text = String(object.Text);
                    return message;
                };

                /**
                 * Creates a plain object from a ConferenceTipsInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ConferenceTipsInfo} message ConferenceTipsInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConferenceTipsInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Sessiontype = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Sessionuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Sessionuin = options.longs === String ? "0" : 0;
                        object.Text = "";
                    }
                    if (message.Sessiontype != null && message.hasOwnProperty("Sessiontype"))
                        object.Sessiontype = message.Sessiontype;
                    if (message.Sessionuin != null && message.hasOwnProperty("Sessionuin"))
                        if (typeof message.Sessionuin === "number")
                            object.Sessionuin = options.longs === String ? String(message.Sessionuin) : message.Sessionuin;
                        else
                            object.Sessionuin = options.longs === String ? $util.Long.prototype.toString.call(message.Sessionuin) : options.longs === Number ? new $util.LongBits(message.Sessionuin.low >>> 0, message.Sessionuin.high >>> 0).toNumber() : message.Sessionuin;
                    if (message.Text != null && message.hasOwnProperty("Text"))
                        object.Text = message.Text;
                    return object;
                };

                /**
                 * Converts this ConferenceTipsInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.ConferenceTipsInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConferenceTipsInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConferenceTipsInfo;
            })();

            ImMsgBody.RedbagInfo = (function() {

                /**
                 * Properties of a RedbagInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IRedbagInfo
                 * @property {number|null} [Type] RedbagInfo Type
                 */

                /**
                 * Constructs a new RedbagInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a RedbagInfo.
                 * @implements IRedbagInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IRedbagInfo=} [properties] Properties to set
                 */
                function RedbagInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RedbagInfo Type.
                 * @member {number} Type
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @instance
                 */
                RedbagInfo.prototype.Type = 0;

                /**
                 * Creates a new RedbagInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRedbagInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.RedbagInfo} RedbagInfo instance
                 */
                RedbagInfo.create = function create(properties) {
                    return new RedbagInfo(properties);
                };

                /**
                 * Encodes the specified RedbagInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.RedbagInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRedbagInfo} message RedbagInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RedbagInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
                    return writer;
                };

                /**
                 * Encodes the specified RedbagInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.RedbagInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRedbagInfo} message RedbagInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RedbagInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RedbagInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.RedbagInfo} RedbagInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RedbagInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.RedbagInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RedbagInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.RedbagInfo} RedbagInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RedbagInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RedbagInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RedbagInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        if (!$util.isInteger(message.Type))
                            return "Type: integer expected";
                    return null;
                };

                /**
                 * Creates a RedbagInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.RedbagInfo} RedbagInfo
                 */
                RedbagInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.RedbagInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.RedbagInfo();
                    if (object.Type != null)
                        message.Type = object.Type | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a RedbagInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.RedbagInfo} message RedbagInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RedbagInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.Type = 0;
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    return object;
                };

                /**
                 * Converts this RedbagInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.RedbagInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RedbagInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RedbagInfo;
            })();

            ImMsgBody.LowVersionTips = (function() {

                /**
                 * Properties of a LowVersionTips.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ILowVersionTips
                 * @property {number|null} [Businessid] LowVersionTips Businessid
                 * @property {number|null} [Sessiontype] LowVersionTips Sessiontype
                 * @property {number|Long|null} [Sessionuin] LowVersionTips Sessionuin
                 * @property {number|Long|null} [Senderuin] LowVersionTips Senderuin
                 * @property {string|null} [Text] LowVersionTips Text
                 */

                /**
                 * Constructs a new LowVersionTips.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a LowVersionTips.
                 * @implements ILowVersionTips
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ILowVersionTips=} [properties] Properties to set
                 */
                function LowVersionTips(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LowVersionTips Businessid.
                 * @member {number} Businessid
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @instance
                 */
                LowVersionTips.prototype.Businessid = 0;

                /**
                 * LowVersionTips Sessiontype.
                 * @member {number} Sessiontype
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @instance
                 */
                LowVersionTips.prototype.Sessiontype = 0;

                /**
                 * LowVersionTips Sessionuin.
                 * @member {number|Long} Sessionuin
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @instance
                 */
                LowVersionTips.prototype.Sessionuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LowVersionTips Senderuin.
                 * @member {number|Long} Senderuin
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @instance
                 */
                LowVersionTips.prototype.Senderuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LowVersionTips Text.
                 * @member {string} Text
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @instance
                 */
                LowVersionTips.prototype.Text = "";

                /**
                 * Creates a new LowVersionTips instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILowVersionTips=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.LowVersionTips} LowVersionTips instance
                 */
                LowVersionTips.create = function create(properties) {
                    return new LowVersionTips(properties);
                };

                /**
                 * Encodes the specified LowVersionTips message. Does not implicitly {@link Msg.MsgField.ImMsgBody.LowVersionTips.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILowVersionTips} message LowVersionTips message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LowVersionTips.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Businessid != null && Object.hasOwnProperty.call(message, "Businessid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Businessid);
                    if (message.Sessiontype != null && Object.hasOwnProperty.call(message, "Sessiontype"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Sessiontype);
                    if (message.Sessionuin != null && Object.hasOwnProperty.call(message, "Sessionuin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.Sessionuin);
                    if (message.Senderuin != null && Object.hasOwnProperty.call(message, "Senderuin"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.Senderuin);
                    if (message.Text != null && Object.hasOwnProperty.call(message, "Text"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.Text);
                    return writer;
                };

                /**
                 * Encodes the specified LowVersionTips message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.LowVersionTips.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILowVersionTips} message LowVersionTips message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LowVersionTips.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LowVersionTips message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.LowVersionTips} LowVersionTips
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LowVersionTips.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.LowVersionTips();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Businessid = reader.int32();
                            break;
                        case 2:
                            message.Sessiontype = reader.int32();
                            break;
                        case 3:
                            message.Sessionuin = reader.int64();
                            break;
                        case 4:
                            message.Senderuin = reader.int64();
                            break;
                        case 5:
                            message.Text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LowVersionTips message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.LowVersionTips} LowVersionTips
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LowVersionTips.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LowVersionTips message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LowVersionTips.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Businessid != null && message.hasOwnProperty("Businessid"))
                        if (!$util.isInteger(message.Businessid))
                            return "Businessid: integer expected";
                    if (message.Sessiontype != null && message.hasOwnProperty("Sessiontype"))
                        if (!$util.isInteger(message.Sessiontype))
                            return "Sessiontype: integer expected";
                    if (message.Sessionuin != null && message.hasOwnProperty("Sessionuin"))
                        if (!$util.isInteger(message.Sessionuin) && !(message.Sessionuin && $util.isInteger(message.Sessionuin.low) && $util.isInteger(message.Sessionuin.high)))
                            return "Sessionuin: integer|Long expected";
                    if (message.Senderuin != null && message.hasOwnProperty("Senderuin"))
                        if (!$util.isInteger(message.Senderuin) && !(message.Senderuin && $util.isInteger(message.Senderuin.low) && $util.isInteger(message.Senderuin.high)))
                            return "Senderuin: integer|Long expected";
                    if (message.Text != null && message.hasOwnProperty("Text"))
                        if (!$util.isString(message.Text))
                            return "Text: string expected";
                    return null;
                };

                /**
                 * Creates a LowVersionTips message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.LowVersionTips} LowVersionTips
                 */
                LowVersionTips.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.LowVersionTips)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.LowVersionTips();
                    if (object.Businessid != null)
                        message.Businessid = object.Businessid | 0;
                    if (object.Sessiontype != null)
                        message.Sessiontype = object.Sessiontype | 0;
                    if (object.Sessionuin != null)
                        if ($util.Long)
                            (message.Sessionuin = $util.Long.fromValue(object.Sessionuin)).unsigned = false;
                        else if (typeof object.Sessionuin === "string")
                            message.Sessionuin = parseInt(object.Sessionuin, 10);
                        else if (typeof object.Sessionuin === "number")
                            message.Sessionuin = object.Sessionuin;
                        else if (typeof object.Sessionuin === "object")
                            message.Sessionuin = new $util.LongBits(object.Sessionuin.low >>> 0, object.Sessionuin.high >>> 0).toNumber();
                    if (object.Senderuin != null)
                        if ($util.Long)
                            (message.Senderuin = $util.Long.fromValue(object.Senderuin)).unsigned = false;
                        else if (typeof object.Senderuin === "string")
                            message.Senderuin = parseInt(object.Senderuin, 10);
                        else if (typeof object.Senderuin === "number")
                            message.Senderuin = object.Senderuin;
                        else if (typeof object.Senderuin === "object")
                            message.Senderuin = new $util.LongBits(object.Senderuin.low >>> 0, object.Senderuin.high >>> 0).toNumber();
                    if (object.Text != null)
                        message.Text = String(object.Text);
                    return message;
                };

                /**
                 * Creates a plain object from a LowVersionTips message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.LowVersionTips} message LowVersionTips
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LowVersionTips.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Businessid = 0;
                        object.Sessiontype = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Sessionuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Sessionuin = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Senderuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Senderuin = options.longs === String ? "0" : 0;
                        object.Text = "";
                    }
                    if (message.Businessid != null && message.hasOwnProperty("Businessid"))
                        object.Businessid = message.Businessid;
                    if (message.Sessiontype != null && message.hasOwnProperty("Sessiontype"))
                        object.Sessiontype = message.Sessiontype;
                    if (message.Sessionuin != null && message.hasOwnProperty("Sessionuin"))
                        if (typeof message.Sessionuin === "number")
                            object.Sessionuin = options.longs === String ? String(message.Sessionuin) : message.Sessionuin;
                        else
                            object.Sessionuin = options.longs === String ? $util.Long.prototype.toString.call(message.Sessionuin) : options.longs === Number ? new $util.LongBits(message.Sessionuin.low >>> 0, message.Sessionuin.high >>> 0).toNumber() : message.Sessionuin;
                    if (message.Senderuin != null && message.hasOwnProperty("Senderuin"))
                        if (typeof message.Senderuin === "number")
                            object.Senderuin = options.longs === String ? String(message.Senderuin) : message.Senderuin;
                        else
                            object.Senderuin = options.longs === String ? $util.Long.prototype.toString.call(message.Senderuin) : options.longs === Number ? new $util.LongBits(message.Senderuin.low >>> 0, message.Senderuin.high >>> 0).toNumber() : message.Senderuin;
                    if (message.Text != null && message.hasOwnProperty("Text"))
                        object.Text = message.Text;
                    return object;
                };

                /**
                 * Converts this LowVersionTips to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.LowVersionTips
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LowVersionTips.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LowVersionTips;
            })();

            ImMsgBody.NearByMsg = (function() {

                /**
                 * Properties of a NearByMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface INearByMsg
                 * @property {number|null} [Type] NearByMsg Type
                 * @property {number|null} [IdentifyType] NearByMsg IdentifyType
                 */

                /**
                 * Constructs a new NearByMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a NearByMsg.
                 * @implements INearByMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.INearByMsg=} [properties] Properties to set
                 */
                function NearByMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NearByMsg Type.
                 * @member {number} Type
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @instance
                 */
                NearByMsg.prototype.Type = 0;

                /**
                 * NearByMsg IdentifyType.
                 * @member {number} IdentifyType
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @instance
                 */
                NearByMsg.prototype.IdentifyType = 0;

                /**
                 * Creates a new NearByMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INearByMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.NearByMsg} NearByMsg instance
                 */
                NearByMsg.create = function create(properties) {
                    return new NearByMsg(properties);
                };

                /**
                 * Encodes the specified NearByMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.NearByMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INearByMsg} message NearByMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NearByMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
                    if (message.IdentifyType != null && Object.hasOwnProperty.call(message, "IdentifyType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.IdentifyType);
                    return writer;
                };

                /**
                 * Encodes the specified NearByMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.NearByMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.INearByMsg} message NearByMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NearByMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NearByMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.NearByMsg} NearByMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NearByMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.NearByMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Type = reader.int32();
                            break;
                        case 2:
                            message.IdentifyType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NearByMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.NearByMsg} NearByMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NearByMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NearByMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NearByMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        if (!$util.isInteger(message.Type))
                            return "Type: integer expected";
                    if (message.IdentifyType != null && message.hasOwnProperty("IdentifyType"))
                        if (!$util.isInteger(message.IdentifyType))
                            return "IdentifyType: integer expected";
                    return null;
                };

                /**
                 * Creates a NearByMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.NearByMsg} NearByMsg
                 */
                NearByMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.NearByMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.NearByMsg();
                    if (object.Type != null)
                        message.Type = object.Type | 0;
                    if (object.IdentifyType != null)
                        message.IdentifyType = object.IdentifyType | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a NearByMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.NearByMsg} message NearByMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NearByMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Type = 0;
                        object.IdentifyType = 0;
                    }
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    if (message.IdentifyType != null && message.hasOwnProperty("IdentifyType"))
                        object.IdentifyType = message.IdentifyType;
                    return object;
                };

                /**
                 * Converts this NearByMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.NearByMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NearByMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NearByMsg;
            })();

            ImMsgBody.CustomElem = (function() {

                /**
                 * Properties of a CustomElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ICustomElem
                 * @property {Uint8Array|null} [Desc] CustomElem Desc
                 * @property {Uint8Array|null} [Data] CustomElem Data
                 * @property {number|null} [Enumtype] CustomElem Enumtype
                 * @property {Uint8Array|null} [Ext] CustomElem Ext
                 * @property {Uint8Array|null} [Sound] CustomElem Sound
                 */

                /**
                 * Constructs a new CustomElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a CustomElem.
                 * @implements ICustomElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ICustomElem=} [properties] Properties to set
                 */
                function CustomElem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CustomElem Desc.
                 * @member {Uint8Array} Desc
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @instance
                 */
                CustomElem.prototype.Desc = $util.newBuffer([]);

                /**
                 * CustomElem Data.
                 * @member {Uint8Array} Data
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @instance
                 */
                CustomElem.prototype.Data = $util.newBuffer([]);

                /**
                 * CustomElem Enumtype.
                 * @member {number} Enumtype
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @instance
                 */
                CustomElem.prototype.Enumtype = 0;

                /**
                 * CustomElem Ext.
                 * @member {Uint8Array} Ext
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @instance
                 */
                CustomElem.prototype.Ext = $util.newBuffer([]);

                /**
                 * CustomElem Sound.
                 * @member {Uint8Array} Sound
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @instance
                 */
                CustomElem.prototype.Sound = $util.newBuffer([]);

                /**
                 * Creates a new CustomElem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICustomElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.CustomElem} CustomElem instance
                 */
                CustomElem.create = function create(properties) {
                    return new CustomElem(properties);
                };

                /**
                 * Encodes the specified CustomElem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.CustomElem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICustomElem} message CustomElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomElem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Desc != null && Object.hasOwnProperty.call(message, "Desc"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Desc);
                    if (message.Data != null && Object.hasOwnProperty.call(message, "Data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Data);
                    if (message.Enumtype != null && Object.hasOwnProperty.call(message, "Enumtype"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Enumtype);
                    if (message.Ext != null && Object.hasOwnProperty.call(message, "Ext"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Ext);
                    if (message.Sound != null && Object.hasOwnProperty.call(message, "Sound"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Sound);
                    return writer;
                };

                /**
                 * Encodes the specified CustomElem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.CustomElem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICustomElem} message CustomElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomElem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CustomElem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.CustomElem} CustomElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomElem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.CustomElem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Desc = reader.bytes();
                            break;
                        case 2:
                            message.Data = reader.bytes();
                            break;
                        case 3:
                            message.Enumtype = reader.int32();
                            break;
                        case 4:
                            message.Ext = reader.bytes();
                            break;
                        case 5:
                            message.Sound = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CustomElem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.CustomElem} CustomElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomElem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CustomElem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CustomElem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Desc != null && message.hasOwnProperty("Desc"))
                        if (!(message.Desc && typeof message.Desc.length === "number" || $util.isString(message.Desc)))
                            return "Desc: buffer expected";
                    if (message.Data != null && message.hasOwnProperty("Data"))
                        if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                            return "Data: buffer expected";
                    if (message.Enumtype != null && message.hasOwnProperty("Enumtype"))
                        if (!$util.isInteger(message.Enumtype))
                            return "Enumtype: integer expected";
                    if (message.Ext != null && message.hasOwnProperty("Ext"))
                        if (!(message.Ext && typeof message.Ext.length === "number" || $util.isString(message.Ext)))
                            return "Ext: buffer expected";
                    if (message.Sound != null && message.hasOwnProperty("Sound"))
                        if (!(message.Sound && typeof message.Sound.length === "number" || $util.isString(message.Sound)))
                            return "Sound: buffer expected";
                    return null;
                };

                /**
                 * Creates a CustomElem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.CustomElem} CustomElem
                 */
                CustomElem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.CustomElem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.CustomElem();
                    if (object.Desc != null)
                        if (typeof object.Desc === "string")
                            $util.base64.decode(object.Desc, message.Desc = $util.newBuffer($util.base64.length(object.Desc)), 0);
                        else if (object.Desc.length)
                            message.Desc = object.Desc;
                    if (object.Data != null)
                        if (typeof object.Data === "string")
                            $util.base64.decode(object.Data, message.Data = $util.newBuffer($util.base64.length(object.Data)), 0);
                        else if (object.Data.length)
                            message.Data = object.Data;
                    if (object.Enumtype != null)
                        message.Enumtype = object.Enumtype | 0;
                    if (object.Ext != null)
                        if (typeof object.Ext === "string")
                            $util.base64.decode(object.Ext, message.Ext = $util.newBuffer($util.base64.length(object.Ext)), 0);
                        else if (object.Ext.length)
                            message.Ext = object.Ext;
                    if (object.Sound != null)
                        if (typeof object.Sound === "string")
                            $util.base64.decode(object.Sound, message.Sound = $util.newBuffer($util.base64.length(object.Sound)), 0);
                        else if (object.Sound.length)
                            message.Sound = object.Sound;
                    return message;
                };

                /**
                 * Creates a plain object from a CustomElem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.CustomElem} message CustomElem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CustomElem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Desc = "";
                        else {
                            object.Desc = [];
                            if (options.bytes !== Array)
                                object.Desc = $util.newBuffer(object.Desc);
                        }
                        if (options.bytes === String)
                            object.Data = "";
                        else {
                            object.Data = [];
                            if (options.bytes !== Array)
                                object.Data = $util.newBuffer(object.Data);
                        }
                        object.Enumtype = 0;
                        if (options.bytes === String)
                            object.Ext = "";
                        else {
                            object.Ext = [];
                            if (options.bytes !== Array)
                                object.Ext = $util.newBuffer(object.Ext);
                        }
                        if (options.bytes === String)
                            object.Sound = "";
                        else {
                            object.Sound = [];
                            if (options.bytes !== Array)
                                object.Sound = $util.newBuffer(object.Sound);
                        }
                    }
                    if (message.Desc != null && message.hasOwnProperty("Desc"))
                        object.Desc = options.bytes === String ? $util.base64.encode(message.Desc, 0, message.Desc.length) : options.bytes === Array ? Array.prototype.slice.call(message.Desc) : message.Desc;
                    if (message.Data != null && message.hasOwnProperty("Data"))
                        object.Data = options.bytes === String ? $util.base64.encode(message.Data, 0, message.Data.length) : options.bytes === Array ? Array.prototype.slice.call(message.Data) : message.Data;
                    if (message.Enumtype != null && message.hasOwnProperty("Enumtype"))
                        object.Enumtype = message.Enumtype;
                    if (message.Ext != null && message.hasOwnProperty("Ext"))
                        object.Ext = options.bytes === String ? $util.base64.encode(message.Ext, 0, message.Ext.length) : options.bytes === Array ? Array.prototype.slice.call(message.Ext) : message.Ext;
                    if (message.Sound != null && message.hasOwnProperty("Sound"))
                        object.Sound = options.bytes === String ? $util.base64.encode(message.Sound, 0, message.Sound.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sound) : message.Sound;
                    return object;
                };

                /**
                 * Converts this CustomElem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.CustomElem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CustomElem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CustomElem;
            })();

            ImMsgBody.LocationInfo = (function() {

                /**
                 * Properties of a LocationInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ILocationInfo
                 * @property {number|null} [Longitude] LocationInfo Longitude
                 * @property {number|null} [Latitude] LocationInfo Latitude
                 * @property {Uint8Array|null} [Desc] LocationInfo Desc
                 */

                /**
                 * Constructs a new LocationInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a LocationInfo.
                 * @implements ILocationInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ILocationInfo=} [properties] Properties to set
                 */
                function LocationInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LocationInfo Longitude.
                 * @member {number} Longitude
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @instance
                 */
                LocationInfo.prototype.Longitude = 0;

                /**
                 * LocationInfo Latitude.
                 * @member {number} Latitude
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @instance
                 */
                LocationInfo.prototype.Latitude = 0;

                /**
                 * LocationInfo Desc.
                 * @member {Uint8Array} Desc
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @instance
                 */
                LocationInfo.prototype.Desc = $util.newBuffer([]);

                /**
                 * Creates a new LocationInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILocationInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.LocationInfo} LocationInfo instance
                 */
                LocationInfo.create = function create(properties) {
                    return new LocationInfo(properties);
                };

                /**
                 * Encodes the specified LocationInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.LocationInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILocationInfo} message LocationInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LocationInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Longitude != null && Object.hasOwnProperty.call(message, "Longitude"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.Longitude);
                    if (message.Latitude != null && Object.hasOwnProperty.call(message, "Latitude"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.Latitude);
                    if (message.Desc != null && Object.hasOwnProperty.call(message, "Desc"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Desc);
                    return writer;
                };

                /**
                 * Encodes the specified LocationInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.LocationInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILocationInfo} message LocationInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LocationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LocationInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.LocationInfo} LocationInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LocationInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.LocationInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Longitude = reader.double();
                            break;
                        case 2:
                            message.Latitude = reader.double();
                            break;
                        case 3:
                            message.Desc = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LocationInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.LocationInfo} LocationInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LocationInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LocationInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LocationInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Longitude != null && message.hasOwnProperty("Longitude"))
                        if (typeof message.Longitude !== "number")
                            return "Longitude: number expected";
                    if (message.Latitude != null && message.hasOwnProperty("Latitude"))
                        if (typeof message.Latitude !== "number")
                            return "Latitude: number expected";
                    if (message.Desc != null && message.hasOwnProperty("Desc"))
                        if (!(message.Desc && typeof message.Desc.length === "number" || $util.isString(message.Desc)))
                            return "Desc: buffer expected";
                    return null;
                };

                /**
                 * Creates a LocationInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.LocationInfo} LocationInfo
                 */
                LocationInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.LocationInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.LocationInfo();
                    if (object.Longitude != null)
                        message.Longitude = Number(object.Longitude);
                    if (object.Latitude != null)
                        message.Latitude = Number(object.Latitude);
                    if (object.Desc != null)
                        if (typeof object.Desc === "string")
                            $util.base64.decode(object.Desc, message.Desc = $util.newBuffer($util.base64.length(object.Desc)), 0);
                        else if (object.Desc.length)
                            message.Desc = object.Desc;
                    return message;
                };

                /**
                 * Creates a plain object from a LocationInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.LocationInfo} message LocationInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LocationInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Longitude = 0;
                        object.Latitude = 0;
                        if (options.bytes === String)
                            object.Desc = "";
                        else {
                            object.Desc = [];
                            if (options.bytes !== Array)
                                object.Desc = $util.newBuffer(object.Desc);
                        }
                    }
                    if (message.Longitude != null && message.hasOwnProperty("Longitude"))
                        object.Longitude = options.json && !isFinite(message.Longitude) ? String(message.Longitude) : message.Longitude;
                    if (message.Latitude != null && message.hasOwnProperty("Latitude"))
                        object.Latitude = options.json && !isFinite(message.Latitude) ? String(message.Latitude) : message.Latitude;
                    if (message.Desc != null && message.hasOwnProperty("Desc"))
                        object.Desc = options.bytes === String ? $util.base64.encode(message.Desc, 0, message.Desc.length) : options.bytes === Array ? Array.prototype.slice.call(message.Desc) : message.Desc;
                    return object;
                };

                /**
                 * Converts this LocationInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.LocationInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LocationInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LocationInfo;
            })();

            ImMsgBody.PubAccInfo = (function() {

                /**
                 * Properties of a PubAccInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IPubAccInfo
                 * @property {number|null} [Isinternum] PubAccInfo Isinternum
                 * @property {string|null} [Ingmsgtemplateid] PubAccInfo Ingmsgtemplateid
                 * @property {string|null} [Inglongmsgurl] PubAccInfo Inglongmsgurl
                 * @property {Uint8Array|null} [Downloadkey] PubAccInfo Downloadkey
                 */

                /**
                 * Constructs a new PubAccInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a PubAccInfo.
                 * @implements IPubAccInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IPubAccInfo=} [properties] Properties to set
                 */
                function PubAccInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PubAccInfo Isinternum.
                 * @member {number} Isinternum
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @instance
                 */
                PubAccInfo.prototype.Isinternum = 0;

                /**
                 * PubAccInfo Ingmsgtemplateid.
                 * @member {string} Ingmsgtemplateid
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @instance
                 */
                PubAccInfo.prototype.Ingmsgtemplateid = "";

                /**
                 * PubAccInfo Inglongmsgurl.
                 * @member {string} Inglongmsgurl
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @instance
                 */
                PubAccInfo.prototype.Inglongmsgurl = "";

                /**
                 * PubAccInfo Downloadkey.
                 * @member {Uint8Array} Downloadkey
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @instance
                 */
                PubAccInfo.prototype.Downloadkey = $util.newBuffer([]);

                /**
                 * Creates a new PubAccInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubAccInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.PubAccInfo} PubAccInfo instance
                 */
                PubAccInfo.create = function create(properties) {
                    return new PubAccInfo(properties);
                };

                /**
                 * Encodes the specified PubAccInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.PubAccInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubAccInfo} message PubAccInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PubAccInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Isinternum != null && Object.hasOwnProperty.call(message, "Isinternum"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Isinternum);
                    if (message.Ingmsgtemplateid != null && Object.hasOwnProperty.call(message, "Ingmsgtemplateid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Ingmsgtemplateid);
                    if (message.Inglongmsgurl != null && Object.hasOwnProperty.call(message, "Inglongmsgurl"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Inglongmsgurl);
                    if (message.Downloadkey != null && Object.hasOwnProperty.call(message, "Downloadkey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Downloadkey);
                    return writer;
                };

                /**
                 * Encodes the specified PubAccInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.PubAccInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPubAccInfo} message PubAccInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PubAccInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PubAccInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.PubAccInfo} PubAccInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PubAccInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.PubAccInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Isinternum = reader.int32();
                            break;
                        case 2:
                            message.Ingmsgtemplateid = reader.string();
                            break;
                        case 3:
                            message.Inglongmsgurl = reader.string();
                            break;
                        case 4:
                            message.Downloadkey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PubAccInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.PubAccInfo} PubAccInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PubAccInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PubAccInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PubAccInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Isinternum != null && message.hasOwnProperty("Isinternum"))
                        if (!$util.isInteger(message.Isinternum))
                            return "Isinternum: integer expected";
                    if (message.Ingmsgtemplateid != null && message.hasOwnProperty("Ingmsgtemplateid"))
                        if (!$util.isString(message.Ingmsgtemplateid))
                            return "Ingmsgtemplateid: string expected";
                    if (message.Inglongmsgurl != null && message.hasOwnProperty("Inglongmsgurl"))
                        if (!$util.isString(message.Inglongmsgurl))
                            return "Inglongmsgurl: string expected";
                    if (message.Downloadkey != null && message.hasOwnProperty("Downloadkey"))
                        if (!(message.Downloadkey && typeof message.Downloadkey.length === "number" || $util.isString(message.Downloadkey)))
                            return "Downloadkey: buffer expected";
                    return null;
                };

                /**
                 * Creates a PubAccInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.PubAccInfo} PubAccInfo
                 */
                PubAccInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.PubAccInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.PubAccInfo();
                    if (object.Isinternum != null)
                        message.Isinternum = object.Isinternum | 0;
                    if (object.Ingmsgtemplateid != null)
                        message.Ingmsgtemplateid = String(object.Ingmsgtemplateid);
                    if (object.Inglongmsgurl != null)
                        message.Inglongmsgurl = String(object.Inglongmsgurl);
                    if (object.Downloadkey != null)
                        if (typeof object.Downloadkey === "string")
                            $util.base64.decode(object.Downloadkey, message.Downloadkey = $util.newBuffer($util.base64.length(object.Downloadkey)), 0);
                        else if (object.Downloadkey.length)
                            message.Downloadkey = object.Downloadkey;
                    return message;
                };

                /**
                 * Creates a plain object from a PubAccInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.PubAccInfo} message PubAccInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PubAccInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Isinternum = 0;
                        object.Ingmsgtemplateid = "";
                        object.Inglongmsgurl = "";
                        if (options.bytes === String)
                            object.Downloadkey = "";
                        else {
                            object.Downloadkey = [];
                            if (options.bytes !== Array)
                                object.Downloadkey = $util.newBuffer(object.Downloadkey);
                        }
                    }
                    if (message.Isinternum != null && message.hasOwnProperty("Isinternum"))
                        object.Isinternum = message.Isinternum;
                    if (message.Ingmsgtemplateid != null && message.hasOwnProperty("Ingmsgtemplateid"))
                        object.Ingmsgtemplateid = message.Ingmsgtemplateid;
                    if (message.Inglongmsgurl != null && message.hasOwnProperty("Inglongmsgurl"))
                        object.Inglongmsgurl = message.Inglongmsgurl;
                    if (message.Downloadkey != null && message.hasOwnProperty("Downloadkey"))
                        object.Downloadkey = options.bytes === String ? $util.base64.encode(message.Downloadkey, 0, message.Downloadkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.Downloadkey) : message.Downloadkey;
                    return object;
                };

                /**
                 * Converts this PubAccInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.PubAccInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PubAccInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PubAccInfo;
            })();

            ImMsgBody.SmallEmoji = (function() {

                /**
                 * Properties of a SmallEmoji.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ISmallEmoji
                 * @property {number|null} [Packidsum] SmallEmoji Packidsum
                 * @property {number|null} [Imagetype] SmallEmoji Imagetype
                 */

                /**
                 * Constructs a new SmallEmoji.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a SmallEmoji.
                 * @implements ISmallEmoji
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ISmallEmoji=} [properties] Properties to set
                 */
                function SmallEmoji(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SmallEmoji Packidsum.
                 * @member {number} Packidsum
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @instance
                 */
                SmallEmoji.prototype.Packidsum = 0;

                /**
                 * SmallEmoji Imagetype.
                 * @member {number} Imagetype
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @instance
                 */
                SmallEmoji.prototype.Imagetype = 0;

                /**
                 * Creates a new SmallEmoji instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISmallEmoji=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.SmallEmoji} SmallEmoji instance
                 */
                SmallEmoji.create = function create(properties) {
                    return new SmallEmoji(properties);
                };

                /**
                 * Encodes the specified SmallEmoji message. Does not implicitly {@link Msg.MsgField.ImMsgBody.SmallEmoji.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISmallEmoji} message SmallEmoji message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SmallEmoji.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Packidsum != null && Object.hasOwnProperty.call(message, "Packidsum"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Packidsum);
                    if (message.Imagetype != null && Object.hasOwnProperty.call(message, "Imagetype"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Imagetype);
                    return writer;
                };

                /**
                 * Encodes the specified SmallEmoji message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.SmallEmoji.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISmallEmoji} message SmallEmoji message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SmallEmoji.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SmallEmoji message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.SmallEmoji} SmallEmoji
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SmallEmoji.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.SmallEmoji();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Packidsum = reader.int32();
                            break;
                        case 2:
                            message.Imagetype = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SmallEmoji message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.SmallEmoji} SmallEmoji
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SmallEmoji.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SmallEmoji message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SmallEmoji.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Packidsum != null && message.hasOwnProperty("Packidsum"))
                        if (!$util.isInteger(message.Packidsum))
                            return "Packidsum: integer expected";
                    if (message.Imagetype != null && message.hasOwnProperty("Imagetype"))
                        if (!$util.isInteger(message.Imagetype))
                            return "Imagetype: integer expected";
                    return null;
                };

                /**
                 * Creates a SmallEmoji message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.SmallEmoji} SmallEmoji
                 */
                SmallEmoji.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.SmallEmoji)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.SmallEmoji();
                    if (object.Packidsum != null)
                        message.Packidsum = object.Packidsum | 0;
                    if (object.Imagetype != null)
                        message.Imagetype = object.Imagetype | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SmallEmoji message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.SmallEmoji} message SmallEmoji
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SmallEmoji.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Packidsum = 0;
                        object.Imagetype = 0;
                    }
                    if (message.Packidsum != null && message.hasOwnProperty("Packidsum"))
                        object.Packidsum = message.Packidsum;
                    if (message.Imagetype != null && message.hasOwnProperty("Imagetype"))
                        object.Imagetype = message.Imagetype;
                    return object;
                };

                /**
                 * Converts this SmallEmoji to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.SmallEmoji
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SmallEmoji.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SmallEmoji;
            })();

            ImMsgBody.FsjMsgElem = (function() {

                /**
                 * Properties of a FsjMsgElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IFsjMsgElem
                 * @property {number|null} [MsgType] FsjMsgElem MsgType
                 */

                /**
                 * Constructs a new FsjMsgElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a FsjMsgElem.
                 * @implements IFsjMsgElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IFsjMsgElem=} [properties] Properties to set
                 */
                function FsjMsgElem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FsjMsgElem MsgType.
                 * @member {number} MsgType
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @instance
                 */
                FsjMsgElem.prototype.MsgType = 0;

                /**
                 * Creates a new FsjMsgElem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFsjMsgElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.FsjMsgElem} FsjMsgElem instance
                 */
                FsjMsgElem.create = function create(properties) {
                    return new FsjMsgElem(properties);
                };

                /**
                 * Encodes the specified FsjMsgElem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.FsjMsgElem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFsjMsgElem} message FsjMsgElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FsjMsgElem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MsgType != null && Object.hasOwnProperty.call(message, "MsgType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MsgType);
                    return writer;
                };

                /**
                 * Encodes the specified FsjMsgElem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.FsjMsgElem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IFsjMsgElem} message FsjMsgElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FsjMsgElem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FsjMsgElem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.FsjMsgElem} FsjMsgElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FsjMsgElem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.FsjMsgElem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.MsgType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FsjMsgElem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.FsjMsgElem} FsjMsgElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FsjMsgElem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FsjMsgElem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FsjMsgElem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                        if (!$util.isInteger(message.MsgType))
                            return "MsgType: integer expected";
                    return null;
                };

                /**
                 * Creates a FsjMsgElem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.FsjMsgElem} FsjMsgElem
                 */
                FsjMsgElem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.FsjMsgElem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.FsjMsgElem();
                    if (object.MsgType != null)
                        message.MsgType = object.MsgType | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a FsjMsgElem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.FsjMsgElem} message FsjMsgElem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FsjMsgElem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.MsgType = 0;
                    if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                        object.MsgType = message.MsgType;
                    return object;
                };

                /**
                 * Converts this FsjMsgElem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.FsjMsgElem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FsjMsgElem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FsjMsgElem;
            })();

            ImMsgBody.ArkApp = (function() {

                /**
                 * Properties of an ArkApp.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IArkApp
                 * @property {string|null} [Appname] ArkApp Appname
                 * @property {string|null} [Minversion] ArkApp Minversion
                 * @property {string|null} [Xmltemplate] ArkApp Xmltemplate
                 * @property {Uint8Array|null} [Data] ArkApp Data
                 */

                /**
                 * Constructs a new ArkApp.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an ArkApp.
                 * @implements IArkApp
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IArkApp=} [properties] Properties to set
                 */
                function ArkApp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ArkApp Appname.
                 * @member {string} Appname
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @instance
                 */
                ArkApp.prototype.Appname = "";

                /**
                 * ArkApp Minversion.
                 * @member {string} Minversion
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @instance
                 */
                ArkApp.prototype.Minversion = "";

                /**
                 * ArkApp Xmltemplate.
                 * @member {string} Xmltemplate
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @instance
                 */
                ArkApp.prototype.Xmltemplate = "";

                /**
                 * ArkApp Data.
                 * @member {Uint8Array} Data
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @instance
                 */
                ArkApp.prototype.Data = $util.newBuffer([]);

                /**
                 * Creates a new ArkApp instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IArkApp=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.ArkApp} ArkApp instance
                 */
                ArkApp.create = function create(properties) {
                    return new ArkApp(properties);
                };

                /**
                 * Encodes the specified ArkApp message. Does not implicitly {@link Msg.MsgField.ImMsgBody.ArkApp.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IArkApp} message ArkApp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArkApp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Appname != null && Object.hasOwnProperty.call(message, "Appname"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.Appname);
                    if (message.Minversion != null && Object.hasOwnProperty.call(message, "Minversion"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Minversion);
                    if (message.Xmltemplate != null && Object.hasOwnProperty.call(message, "Xmltemplate"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Xmltemplate);
                    if (message.Data != null && Object.hasOwnProperty.call(message, "Data"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Data);
                    return writer;
                };

                /**
                 * Encodes the specified ArkApp message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.ArkApp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IArkApp} message ArkApp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArkApp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ArkApp message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.ArkApp} ArkApp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArkApp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.ArkApp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Appname = reader.string();
                            break;
                        case 2:
                            message.Minversion = reader.string();
                            break;
                        case 3:
                            message.Xmltemplate = reader.string();
                            break;
                        case 4:
                            message.Data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ArkApp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.ArkApp} ArkApp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArkApp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ArkApp message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArkApp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Appname != null && message.hasOwnProperty("Appname"))
                        if (!$util.isString(message.Appname))
                            return "Appname: string expected";
                    if (message.Minversion != null && message.hasOwnProperty("Minversion"))
                        if (!$util.isString(message.Minversion))
                            return "Minversion: string expected";
                    if (message.Xmltemplate != null && message.hasOwnProperty("Xmltemplate"))
                        if (!$util.isString(message.Xmltemplate))
                            return "Xmltemplate: string expected";
                    if (message.Data != null && message.hasOwnProperty("Data"))
                        if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                            return "Data: buffer expected";
                    return null;
                };

                /**
                 * Creates an ArkApp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.ArkApp} ArkApp
                 */
                ArkApp.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.ArkApp)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.ArkApp();
                    if (object.Appname != null)
                        message.Appname = String(object.Appname);
                    if (object.Minversion != null)
                        message.Minversion = String(object.Minversion);
                    if (object.Xmltemplate != null)
                        message.Xmltemplate = String(object.Xmltemplate);
                    if (object.Data != null)
                        if (typeof object.Data === "string")
                            $util.base64.decode(object.Data, message.Data = $util.newBuffer($util.base64.length(object.Data)), 0);
                        else if (object.Data.length)
                            message.Data = object.Data;
                    return message;
                };

                /**
                 * Creates a plain object from an ArkApp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ArkApp} message ArkApp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArkApp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Appname = "";
                        object.Minversion = "";
                        object.Xmltemplate = "";
                        if (options.bytes === String)
                            object.Data = "";
                        else {
                            object.Data = [];
                            if (options.bytes !== Array)
                                object.Data = $util.newBuffer(object.Data);
                        }
                    }
                    if (message.Appname != null && message.hasOwnProperty("Appname"))
                        object.Appname = message.Appname;
                    if (message.Minversion != null && message.hasOwnProperty("Minversion"))
                        object.Minversion = message.Minversion;
                    if (message.Xmltemplate != null && message.hasOwnProperty("Xmltemplate"))
                        object.Xmltemplate = message.Xmltemplate;
                    if (message.Data != null && message.hasOwnProperty("Data"))
                        object.Data = options.bytes === String ? $util.base64.encode(message.Data, 0, message.Data.length) : options.bytes === Array ? Array.prototype.slice.call(message.Data) : message.Data;
                    return object;
                };

                /**
                 * Converts this ArkApp to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.ArkApp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArkApp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ArkApp;
            })();

            ImMsgBody.GeneralFlags = (function() {

                /**
                 * Properties of a GeneralFlags.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IGeneralFlags
                 * @property {number|null} [Bubblediytextid] GeneralFlags Bubblediytextid
                 * @property {number|null} [Groupflagnew] GeneralFlags Groupflagnew
                 * @property {number|Long|null} [Uin] GeneralFlags Uin
                 * @property {Uint8Array|null} [Rpid] GeneralFlags Rpid
                 * @property {number|null} [Prpfold] GeneralFlags Prpfold
                 * @property {number|null} [Longtextflag] GeneralFlags Longtextflag
                 * @property {string|null} [Longtextresid] GeneralFlags Longtextresid
                 * @property {number|null} [Grouptype] GeneralFlags Grouptype
                 * @property {number|null} [Touinflag] GeneralFlags Touinflag
                 * @property {number|null} [Glamourlevel] GeneralFlags Glamourlevel
                 * @property {number|null} [Memberlevel] GeneralFlags Memberlevel
                 * @property {number|Long|null} [Grouprankseq] GeneralFlags Grouprankseq
                 * @property {number|null} [Olympictorch] GeneralFlags Olympictorch
                 * @property {Uint8Array|null} [Babyqguidemsgcookie] GeneralFlags Babyqguidemsgcookie
                 * @property {number|null} [Uin32expertflag] GeneralFlags Uin32expertflag
                 * @property {number|null} [Bubblesubid] GeneralFlags Bubblesubid
                 * @property {number|Long|null} [Pendantid] GeneralFlags Pendantid
                 * @property {Uint8Array|null} [Rpindex] GeneralFlags Rpindex
                 * @property {Uint8Array|null} [Pbreserve] GeneralFlags Pbreserve
                 */

                /**
                 * Constructs a new GeneralFlags.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a GeneralFlags.
                 * @implements IGeneralFlags
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IGeneralFlags=} [properties] Properties to set
                 */
                function GeneralFlags(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GeneralFlags Bubblediytextid.
                 * @member {number} Bubblediytextid
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Bubblediytextid = 0;

                /**
                 * GeneralFlags Groupflagnew.
                 * @member {number} Groupflagnew
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Groupflagnew = 0;

                /**
                 * GeneralFlags Uin.
                 * @member {number|Long} Uin
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Uin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * GeneralFlags Rpid.
                 * @member {Uint8Array} Rpid
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Rpid = $util.newBuffer([]);

                /**
                 * GeneralFlags Prpfold.
                 * @member {number} Prpfold
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Prpfold = 0;

                /**
                 * GeneralFlags Longtextflag.
                 * @member {number} Longtextflag
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Longtextflag = 0;

                /**
                 * GeneralFlags Longtextresid.
                 * @member {string} Longtextresid
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Longtextresid = "";

                /**
                 * GeneralFlags Grouptype.
                 * @member {number} Grouptype
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Grouptype = 0;

                /**
                 * GeneralFlags Touinflag.
                 * @member {number} Touinflag
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Touinflag = 0;

                /**
                 * GeneralFlags Glamourlevel.
                 * @member {number} Glamourlevel
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Glamourlevel = 0;

                /**
                 * GeneralFlags Memberlevel.
                 * @member {number} Memberlevel
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Memberlevel = 0;

                /**
                 * GeneralFlags Grouprankseq.
                 * @member {number|Long} Grouprankseq
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Grouprankseq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * GeneralFlags Olympictorch.
                 * @member {number} Olympictorch
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Olympictorch = 0;

                /**
                 * GeneralFlags Babyqguidemsgcookie.
                 * @member {Uint8Array} Babyqguidemsgcookie
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Babyqguidemsgcookie = $util.newBuffer([]);

                /**
                 * GeneralFlags Uin32expertflag.
                 * @member {number} Uin32expertflag
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Uin32expertflag = 0;

                /**
                 * GeneralFlags Bubblesubid.
                 * @member {number} Bubblesubid
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Bubblesubid = 0;

                /**
                 * GeneralFlags Pendantid.
                 * @member {number|Long} Pendantid
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Pendantid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * GeneralFlags Rpindex.
                 * @member {Uint8Array} Rpindex
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Rpindex = $util.newBuffer([]);

                /**
                 * GeneralFlags Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 */
                GeneralFlags.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * Creates a new GeneralFlags instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGeneralFlags=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.GeneralFlags} GeneralFlags instance
                 */
                GeneralFlags.create = function create(properties) {
                    return new GeneralFlags(properties);
                };

                /**
                 * Encodes the specified GeneralFlags message. Does not implicitly {@link Msg.MsgField.ImMsgBody.GeneralFlags.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGeneralFlags} message GeneralFlags message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneralFlags.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Bubblediytextid != null && Object.hasOwnProperty.call(message, "Bubblediytextid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Bubblediytextid);
                    if (message.Groupflagnew != null && Object.hasOwnProperty.call(message, "Groupflagnew"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Groupflagnew);
                    if (message.Uin != null && Object.hasOwnProperty.call(message, "Uin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.Uin);
                    if (message.Rpid != null && Object.hasOwnProperty.call(message, "Rpid"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Rpid);
                    if (message.Prpfold != null && Object.hasOwnProperty.call(message, "Prpfold"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Prpfold);
                    if (message.Longtextflag != null && Object.hasOwnProperty.call(message, "Longtextflag"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Longtextflag);
                    if (message.Longtextresid != null && Object.hasOwnProperty.call(message, "Longtextresid"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.Longtextresid);
                    if (message.Grouptype != null && Object.hasOwnProperty.call(message, "Grouptype"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Grouptype);
                    if (message.Touinflag != null && Object.hasOwnProperty.call(message, "Touinflag"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Touinflag);
                    if (message.Glamourlevel != null && Object.hasOwnProperty.call(message, "Glamourlevel"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Glamourlevel);
                    if (message.Memberlevel != null && Object.hasOwnProperty.call(message, "Memberlevel"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.Memberlevel);
                    if (message.Grouprankseq != null && Object.hasOwnProperty.call(message, "Grouprankseq"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int64(message.Grouprankseq);
                    if (message.Olympictorch != null && Object.hasOwnProperty.call(message, "Olympictorch"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.Olympictorch);
                    if (message.Babyqguidemsgcookie != null && Object.hasOwnProperty.call(message, "Babyqguidemsgcookie"))
                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.Babyqguidemsgcookie);
                    if (message.Uin32expertflag != null && Object.hasOwnProperty.call(message, "Uin32expertflag"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.Uin32expertflag);
                    if (message.Bubblesubid != null && Object.hasOwnProperty.call(message, "Bubblesubid"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.Bubblesubid);
                    if (message.Pendantid != null && Object.hasOwnProperty.call(message, "Pendantid"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int64(message.Pendantid);
                    if (message.Rpindex != null && Object.hasOwnProperty.call(message, "Rpindex"))
                        writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.Rpindex);
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.Pbreserve);
                    return writer;
                };

                /**
                 * Encodes the specified GeneralFlags message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.GeneralFlags.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGeneralFlags} message GeneralFlags message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneralFlags.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GeneralFlags message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.GeneralFlags} GeneralFlags
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneralFlags.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.GeneralFlags();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Bubblediytextid = reader.int32();
                            break;
                        case 2:
                            message.Groupflagnew = reader.int32();
                            break;
                        case 3:
                            message.Uin = reader.int64();
                            break;
                        case 4:
                            message.Rpid = reader.bytes();
                            break;
                        case 5:
                            message.Prpfold = reader.int32();
                            break;
                        case 6:
                            message.Longtextflag = reader.int32();
                            break;
                        case 7:
                            message.Longtextresid = reader.string();
                            break;
                        case 8:
                            message.Grouptype = reader.int32();
                            break;
                        case 9:
                            message.Touinflag = reader.int32();
                            break;
                        case 10:
                            message.Glamourlevel = reader.int32();
                            break;
                        case 11:
                            message.Memberlevel = reader.int32();
                            break;
                        case 12:
                            message.Grouprankseq = reader.int64();
                            break;
                        case 13:
                            message.Olympictorch = reader.int32();
                            break;
                        case 14:
                            message.Babyqguidemsgcookie = reader.bytes();
                            break;
                        case 15:
                            message.Uin32expertflag = reader.int32();
                            break;
                        case 16:
                            message.Bubblesubid = reader.int32();
                            break;
                        case 17:
                            message.Pendantid = reader.int64();
                            break;
                        case 18:
                            message.Rpindex = reader.bytes();
                            break;
                        case 19:
                            message.Pbreserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GeneralFlags message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.GeneralFlags} GeneralFlags
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneralFlags.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GeneralFlags message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeneralFlags.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Bubblediytextid != null && message.hasOwnProperty("Bubblediytextid"))
                        if (!$util.isInteger(message.Bubblediytextid))
                            return "Bubblediytextid: integer expected";
                    if (message.Groupflagnew != null && message.hasOwnProperty("Groupflagnew"))
                        if (!$util.isInteger(message.Groupflagnew))
                            return "Groupflagnew: integer expected";
                    if (message.Uin != null && message.hasOwnProperty("Uin"))
                        if (!$util.isInteger(message.Uin) && !(message.Uin && $util.isInteger(message.Uin.low) && $util.isInteger(message.Uin.high)))
                            return "Uin: integer|Long expected";
                    if (message.Rpid != null && message.hasOwnProperty("Rpid"))
                        if (!(message.Rpid && typeof message.Rpid.length === "number" || $util.isString(message.Rpid)))
                            return "Rpid: buffer expected";
                    if (message.Prpfold != null && message.hasOwnProperty("Prpfold"))
                        if (!$util.isInteger(message.Prpfold))
                            return "Prpfold: integer expected";
                    if (message.Longtextflag != null && message.hasOwnProperty("Longtextflag"))
                        if (!$util.isInteger(message.Longtextflag))
                            return "Longtextflag: integer expected";
                    if (message.Longtextresid != null && message.hasOwnProperty("Longtextresid"))
                        if (!$util.isString(message.Longtextresid))
                            return "Longtextresid: string expected";
                    if (message.Grouptype != null && message.hasOwnProperty("Grouptype"))
                        if (!$util.isInteger(message.Grouptype))
                            return "Grouptype: integer expected";
                    if (message.Touinflag != null && message.hasOwnProperty("Touinflag"))
                        if (!$util.isInteger(message.Touinflag))
                            return "Touinflag: integer expected";
                    if (message.Glamourlevel != null && message.hasOwnProperty("Glamourlevel"))
                        if (!$util.isInteger(message.Glamourlevel))
                            return "Glamourlevel: integer expected";
                    if (message.Memberlevel != null && message.hasOwnProperty("Memberlevel"))
                        if (!$util.isInteger(message.Memberlevel))
                            return "Memberlevel: integer expected";
                    if (message.Grouprankseq != null && message.hasOwnProperty("Grouprankseq"))
                        if (!$util.isInteger(message.Grouprankseq) && !(message.Grouprankseq && $util.isInteger(message.Grouprankseq.low) && $util.isInteger(message.Grouprankseq.high)))
                            return "Grouprankseq: integer|Long expected";
                    if (message.Olympictorch != null && message.hasOwnProperty("Olympictorch"))
                        if (!$util.isInteger(message.Olympictorch))
                            return "Olympictorch: integer expected";
                    if (message.Babyqguidemsgcookie != null && message.hasOwnProperty("Babyqguidemsgcookie"))
                        if (!(message.Babyqguidemsgcookie && typeof message.Babyqguidemsgcookie.length === "number" || $util.isString(message.Babyqguidemsgcookie)))
                            return "Babyqguidemsgcookie: buffer expected";
                    if (message.Uin32expertflag != null && message.hasOwnProperty("Uin32expertflag"))
                        if (!$util.isInteger(message.Uin32expertflag))
                            return "Uin32expertflag: integer expected";
                    if (message.Bubblesubid != null && message.hasOwnProperty("Bubblesubid"))
                        if (!$util.isInteger(message.Bubblesubid))
                            return "Bubblesubid: integer expected";
                    if (message.Pendantid != null && message.hasOwnProperty("Pendantid"))
                        if (!$util.isInteger(message.Pendantid) && !(message.Pendantid && $util.isInteger(message.Pendantid.low) && $util.isInteger(message.Pendantid.high)))
                            return "Pendantid: integer|Long expected";
                    if (message.Rpindex != null && message.hasOwnProperty("Rpindex"))
                        if (!(message.Rpindex && typeof message.Rpindex.length === "number" || $util.isString(message.Rpindex)))
                            return "Rpindex: buffer expected";
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a GeneralFlags message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.GeneralFlags} GeneralFlags
                 */
                GeneralFlags.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.GeneralFlags)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.GeneralFlags();
                    if (object.Bubblediytextid != null)
                        message.Bubblediytextid = object.Bubblediytextid | 0;
                    if (object.Groupflagnew != null)
                        message.Groupflagnew = object.Groupflagnew | 0;
                    if (object.Uin != null)
                        if ($util.Long)
                            (message.Uin = $util.Long.fromValue(object.Uin)).unsigned = false;
                        else if (typeof object.Uin === "string")
                            message.Uin = parseInt(object.Uin, 10);
                        else if (typeof object.Uin === "number")
                            message.Uin = object.Uin;
                        else if (typeof object.Uin === "object")
                            message.Uin = new $util.LongBits(object.Uin.low >>> 0, object.Uin.high >>> 0).toNumber();
                    if (object.Rpid != null)
                        if (typeof object.Rpid === "string")
                            $util.base64.decode(object.Rpid, message.Rpid = $util.newBuffer($util.base64.length(object.Rpid)), 0);
                        else if (object.Rpid.length)
                            message.Rpid = object.Rpid;
                    if (object.Prpfold != null)
                        message.Prpfold = object.Prpfold | 0;
                    if (object.Longtextflag != null)
                        message.Longtextflag = object.Longtextflag | 0;
                    if (object.Longtextresid != null)
                        message.Longtextresid = String(object.Longtextresid);
                    if (object.Grouptype != null)
                        message.Grouptype = object.Grouptype | 0;
                    if (object.Touinflag != null)
                        message.Touinflag = object.Touinflag | 0;
                    if (object.Glamourlevel != null)
                        message.Glamourlevel = object.Glamourlevel | 0;
                    if (object.Memberlevel != null)
                        message.Memberlevel = object.Memberlevel | 0;
                    if (object.Grouprankseq != null)
                        if ($util.Long)
                            (message.Grouprankseq = $util.Long.fromValue(object.Grouprankseq)).unsigned = false;
                        else if (typeof object.Grouprankseq === "string")
                            message.Grouprankseq = parseInt(object.Grouprankseq, 10);
                        else if (typeof object.Grouprankseq === "number")
                            message.Grouprankseq = object.Grouprankseq;
                        else if (typeof object.Grouprankseq === "object")
                            message.Grouprankseq = new $util.LongBits(object.Grouprankseq.low >>> 0, object.Grouprankseq.high >>> 0).toNumber();
                    if (object.Olympictorch != null)
                        message.Olympictorch = object.Olympictorch | 0;
                    if (object.Babyqguidemsgcookie != null)
                        if (typeof object.Babyqguidemsgcookie === "string")
                            $util.base64.decode(object.Babyqguidemsgcookie, message.Babyqguidemsgcookie = $util.newBuffer($util.base64.length(object.Babyqguidemsgcookie)), 0);
                        else if (object.Babyqguidemsgcookie.length)
                            message.Babyqguidemsgcookie = object.Babyqguidemsgcookie;
                    if (object.Uin32expertflag != null)
                        message.Uin32expertflag = object.Uin32expertflag | 0;
                    if (object.Bubblesubid != null)
                        message.Bubblesubid = object.Bubblesubid | 0;
                    if (object.Pendantid != null)
                        if ($util.Long)
                            (message.Pendantid = $util.Long.fromValue(object.Pendantid)).unsigned = false;
                        else if (typeof object.Pendantid === "string")
                            message.Pendantid = parseInt(object.Pendantid, 10);
                        else if (typeof object.Pendantid === "number")
                            message.Pendantid = object.Pendantid;
                        else if (typeof object.Pendantid === "object")
                            message.Pendantid = new $util.LongBits(object.Pendantid.low >>> 0, object.Pendantid.high >>> 0).toNumber();
                    if (object.Rpindex != null)
                        if (typeof object.Rpindex === "string")
                            $util.base64.decode(object.Rpindex, message.Rpindex = $util.newBuffer($util.base64.length(object.Rpindex)), 0);
                        else if (object.Rpindex.length)
                            message.Rpindex = object.Rpindex;
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    return message;
                };

                /**
                 * Creates a plain object from a GeneralFlags message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.GeneralFlags} message GeneralFlags
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeneralFlags.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Bubblediytextid = 0;
                        object.Groupflagnew = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Uin = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.Rpid = "";
                        else {
                            object.Rpid = [];
                            if (options.bytes !== Array)
                                object.Rpid = $util.newBuffer(object.Rpid);
                        }
                        object.Prpfold = 0;
                        object.Longtextflag = 0;
                        object.Longtextresid = "";
                        object.Grouptype = 0;
                        object.Touinflag = 0;
                        object.Glamourlevel = 0;
                        object.Memberlevel = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Grouprankseq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Grouprankseq = options.longs === String ? "0" : 0;
                        object.Olympictorch = 0;
                        if (options.bytes === String)
                            object.Babyqguidemsgcookie = "";
                        else {
                            object.Babyqguidemsgcookie = [];
                            if (options.bytes !== Array)
                                object.Babyqguidemsgcookie = $util.newBuffer(object.Babyqguidemsgcookie);
                        }
                        object.Uin32expertflag = 0;
                        object.Bubblesubid = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Pendantid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Pendantid = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.Rpindex = "";
                        else {
                            object.Rpindex = [];
                            if (options.bytes !== Array)
                                object.Rpindex = $util.newBuffer(object.Rpindex);
                        }
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                    }
                    if (message.Bubblediytextid != null && message.hasOwnProperty("Bubblediytextid"))
                        object.Bubblediytextid = message.Bubblediytextid;
                    if (message.Groupflagnew != null && message.hasOwnProperty("Groupflagnew"))
                        object.Groupflagnew = message.Groupflagnew;
                    if (message.Uin != null && message.hasOwnProperty("Uin"))
                        if (typeof message.Uin === "number")
                            object.Uin = options.longs === String ? String(message.Uin) : message.Uin;
                        else
                            object.Uin = options.longs === String ? $util.Long.prototype.toString.call(message.Uin) : options.longs === Number ? new $util.LongBits(message.Uin.low >>> 0, message.Uin.high >>> 0).toNumber() : message.Uin;
                    if (message.Rpid != null && message.hasOwnProperty("Rpid"))
                        object.Rpid = options.bytes === String ? $util.base64.encode(message.Rpid, 0, message.Rpid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Rpid) : message.Rpid;
                    if (message.Prpfold != null && message.hasOwnProperty("Prpfold"))
                        object.Prpfold = message.Prpfold;
                    if (message.Longtextflag != null && message.hasOwnProperty("Longtextflag"))
                        object.Longtextflag = message.Longtextflag;
                    if (message.Longtextresid != null && message.hasOwnProperty("Longtextresid"))
                        object.Longtextresid = message.Longtextresid;
                    if (message.Grouptype != null && message.hasOwnProperty("Grouptype"))
                        object.Grouptype = message.Grouptype;
                    if (message.Touinflag != null && message.hasOwnProperty("Touinflag"))
                        object.Touinflag = message.Touinflag;
                    if (message.Glamourlevel != null && message.hasOwnProperty("Glamourlevel"))
                        object.Glamourlevel = message.Glamourlevel;
                    if (message.Memberlevel != null && message.hasOwnProperty("Memberlevel"))
                        object.Memberlevel = message.Memberlevel;
                    if (message.Grouprankseq != null && message.hasOwnProperty("Grouprankseq"))
                        if (typeof message.Grouprankseq === "number")
                            object.Grouprankseq = options.longs === String ? String(message.Grouprankseq) : message.Grouprankseq;
                        else
                            object.Grouprankseq = options.longs === String ? $util.Long.prototype.toString.call(message.Grouprankseq) : options.longs === Number ? new $util.LongBits(message.Grouprankseq.low >>> 0, message.Grouprankseq.high >>> 0).toNumber() : message.Grouprankseq;
                    if (message.Olympictorch != null && message.hasOwnProperty("Olympictorch"))
                        object.Olympictorch = message.Olympictorch;
                    if (message.Babyqguidemsgcookie != null && message.hasOwnProperty("Babyqguidemsgcookie"))
                        object.Babyqguidemsgcookie = options.bytes === String ? $util.base64.encode(message.Babyqguidemsgcookie, 0, message.Babyqguidemsgcookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.Babyqguidemsgcookie) : message.Babyqguidemsgcookie;
                    if (message.Uin32expertflag != null && message.hasOwnProperty("Uin32expertflag"))
                        object.Uin32expertflag = message.Uin32expertflag;
                    if (message.Bubblesubid != null && message.hasOwnProperty("Bubblesubid"))
                        object.Bubblesubid = message.Bubblesubid;
                    if (message.Pendantid != null && message.hasOwnProperty("Pendantid"))
                        if (typeof message.Pendantid === "number")
                            object.Pendantid = options.longs === String ? String(message.Pendantid) : message.Pendantid;
                        else
                            object.Pendantid = options.longs === String ? $util.Long.prototype.toString.call(message.Pendantid) : options.longs === Number ? new $util.LongBits(message.Pendantid.low >>> 0, message.Pendantid.high >>> 0).toNumber() : message.Pendantid;
                    if (message.Rpindex != null && message.hasOwnProperty("Rpindex"))
                        object.Rpindex = options.bytes === String ? $util.base64.encode(message.Rpindex, 0, message.Rpindex.length) : options.bytes === Array ? Array.prototype.slice.call(message.Rpindex) : message.Rpindex;
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    return object;
                };

                /**
                 * Converts this GeneralFlags to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.GeneralFlags
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeneralFlags.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GeneralFlags;
            })();

            ImMsgBody.HcFlashPic = (function() {

                /**
                 * Properties of a HcFlashPic.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IHcFlashPic
                 * @property {Uint8Array|null} [Guid] HcFlashPic Guid
                 * @property {string|null} [Filepath] HcFlashPic Filepath
                 * @property {string|null} [Shortcut] HcFlashPic Shortcut
                 * @property {Uint8Array|null} [Buffer] HcFlashPic Buffer
                 * @property {Uint8Array|null} [Flag] HcFlashPic Flag
                 * @property {Uint8Array|null} [Olddata] HcFlashPic Olddata
                 * @property {number|null} [Fileid] HcFlashPic Fileid
                 * @property {number|null} [Serverip] HcFlashPic Serverip
                 * @property {number|null} [Serverport] HcFlashPic Serverport
                 * @property {number|null} [Filetype] HcFlashPic Filetype
                 * @property {Uint8Array|null} [Signature] HcFlashPic Signature
                 * @property {number|null} [Useful] HcFlashPic Useful
                 * @property {Uint8Array|null} [Md5] HcFlashPic Md5
                 * @property {string|null} [Thumburl] HcFlashPic Thumburl
                 * @property {string|null} [Bigurl] HcFlashPic Bigurl
                 * @property {string|null} [Origurl] HcFlashPic Origurl
                 * @property {number|null} [Biztype] HcFlashPic Biztype
                 * @property {number|null} [Repeatindex] HcFlashPic Repeatindex
                 * @property {number|null} [Repeatimage] HcFlashPic Repeatimage
                 * @property {number|null} [Imagetype] HcFlashPic Imagetype
                 * @property {number|null} [Index] HcFlashPic Index
                 * @property {number|null} [Width] HcFlashPic Width
                 * @property {number|null} [Height] HcFlashPic Height
                 * @property {number|null} [Source] HcFlashPic Source
                 * @property {number|null} [Size] HcFlashPic Size
                 * @property {number|null} [Origin] HcFlashPic Origin
                 * @property {number|null} [Thumbwidth] HcFlashPic Thumbwidth
                 * @property {number|null} [Thumbheight] HcFlashPic Thumbheight
                 * @property {number|null} [Showlen] HcFlashPic Showlen
                 * @property {number|null} [Downloadlen] HcFlashPic Downloadlen
                 * @property {string|null} [Url] HcFlashPic Url
                 * @property {number|null} [Otherwidth] HcFlashPic Otherwidth
                 * @property {number|null} [Otherheight] HcFlashPic Otherheight
                 * @property {Uint8Array|null} [Pbreserve] HcFlashPic Pbreserve
                 */

                /**
                 * Constructs a new HcFlashPic.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a HcFlashPic.
                 * @implements IHcFlashPic
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IHcFlashPic=} [properties] Properties to set
                 */
                function HcFlashPic(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HcFlashPic Guid.
                 * @member {Uint8Array} Guid
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Guid = $util.newBuffer([]);

                /**
                 * HcFlashPic Filepath.
                 * @member {string} Filepath
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Filepath = "";

                /**
                 * HcFlashPic Shortcut.
                 * @member {string} Shortcut
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Shortcut = "";

                /**
                 * HcFlashPic Buffer.
                 * @member {Uint8Array} Buffer
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Buffer = $util.newBuffer([]);

                /**
                 * HcFlashPic Flag.
                 * @member {Uint8Array} Flag
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Flag = $util.newBuffer([]);

                /**
                 * HcFlashPic Olddata.
                 * @member {Uint8Array} Olddata
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Olddata = $util.newBuffer([]);

                /**
                 * HcFlashPic Fileid.
                 * @member {number} Fileid
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Fileid = 0;

                /**
                 * HcFlashPic Serverip.
                 * @member {number} Serverip
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Serverip = 0;

                /**
                 * HcFlashPic Serverport.
                 * @member {number} Serverport
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Serverport = 0;

                /**
                 * HcFlashPic Filetype.
                 * @member {number} Filetype
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Filetype = 0;

                /**
                 * HcFlashPic Signature.
                 * @member {Uint8Array} Signature
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Signature = $util.newBuffer([]);

                /**
                 * HcFlashPic Useful.
                 * @member {number} Useful
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Useful = 0;

                /**
                 * HcFlashPic Md5.
                 * @member {Uint8Array} Md5
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Md5 = $util.newBuffer([]);

                /**
                 * HcFlashPic Thumburl.
                 * @member {string} Thumburl
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Thumburl = "";

                /**
                 * HcFlashPic Bigurl.
                 * @member {string} Bigurl
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Bigurl = "";

                /**
                 * HcFlashPic Origurl.
                 * @member {string} Origurl
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Origurl = "";

                /**
                 * HcFlashPic Biztype.
                 * @member {number} Biztype
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Biztype = 0;

                /**
                 * HcFlashPic Repeatindex.
                 * @member {number} Repeatindex
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Repeatindex = 0;

                /**
                 * HcFlashPic Repeatimage.
                 * @member {number} Repeatimage
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Repeatimage = 0;

                /**
                 * HcFlashPic Imagetype.
                 * @member {number} Imagetype
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Imagetype = 0;

                /**
                 * HcFlashPic Index.
                 * @member {number} Index
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Index = 0;

                /**
                 * HcFlashPic Width.
                 * @member {number} Width
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Width = 0;

                /**
                 * HcFlashPic Height.
                 * @member {number} Height
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Height = 0;

                /**
                 * HcFlashPic Source.
                 * @member {number} Source
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Source = 0;

                /**
                 * HcFlashPic Size.
                 * @member {number} Size
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Size = 0;

                /**
                 * HcFlashPic Origin.
                 * @member {number} Origin
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Origin = 0;

                /**
                 * HcFlashPic Thumbwidth.
                 * @member {number} Thumbwidth
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Thumbwidth = 0;

                /**
                 * HcFlashPic Thumbheight.
                 * @member {number} Thumbheight
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Thumbheight = 0;

                /**
                 * HcFlashPic Showlen.
                 * @member {number} Showlen
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Showlen = 0;

                /**
                 * HcFlashPic Downloadlen.
                 * @member {number} Downloadlen
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Downloadlen = 0;

                /**
                 * HcFlashPic Url.
                 * @member {string} Url
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Url = "";

                /**
                 * HcFlashPic Otherwidth.
                 * @member {number} Otherwidth
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Otherwidth = 0;

                /**
                 * HcFlashPic Otherheight.
                 * @member {number} Otherheight
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Otherheight = 0;

                /**
                 * HcFlashPic Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 */
                HcFlashPic.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * Creates a new HcFlashPic instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IHcFlashPic=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.HcFlashPic} HcFlashPic instance
                 */
                HcFlashPic.create = function create(properties) {
                    return new HcFlashPic(properties);
                };

                /**
                 * Encodes the specified HcFlashPic message. Does not implicitly {@link Msg.MsgField.ImMsgBody.HcFlashPic.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IHcFlashPic} message HcFlashPic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HcFlashPic.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Guid != null && Object.hasOwnProperty.call(message, "Guid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Guid);
                    if (message.Filepath != null && Object.hasOwnProperty.call(message, "Filepath"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Filepath);
                    if (message.Shortcut != null && Object.hasOwnProperty.call(message, "Shortcut"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Shortcut);
                    if (message.Buffer != null && Object.hasOwnProperty.call(message, "Buffer"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Buffer);
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Flag);
                    if (message.Olddata != null && Object.hasOwnProperty.call(message, "Olddata"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.Olddata);
                    if (message.Fileid != null && Object.hasOwnProperty.call(message, "Fileid"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Fileid);
                    if (message.Serverip != null && Object.hasOwnProperty.call(message, "Serverip"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Serverip);
                    if (message.Serverport != null && Object.hasOwnProperty.call(message, "Serverport"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Serverport);
                    if (message.Filetype != null && Object.hasOwnProperty.call(message, "Filetype"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Filetype);
                    if (message.Signature != null && Object.hasOwnProperty.call(message, "Signature"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Signature);
                    if (message.Useful != null && Object.hasOwnProperty.call(message, "Useful"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.Useful);
                    if (message.Md5 != null && Object.hasOwnProperty.call(message, "Md5"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.Md5);
                    if (message.Thumburl != null && Object.hasOwnProperty.call(message, "Thumburl"))
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.Thumburl);
                    if (message.Bigurl != null && Object.hasOwnProperty.call(message, "Bigurl"))
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.Bigurl);
                    if (message.Origurl != null && Object.hasOwnProperty.call(message, "Origurl"))
                        writer.uint32(/* id 16, wireType 2 =*/130).string(message.Origurl);
                    if (message.Biztype != null && Object.hasOwnProperty.call(message, "Biztype"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.Biztype);
                    if (message.Repeatindex != null && Object.hasOwnProperty.call(message, "Repeatindex"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.Repeatindex);
                    if (message.Repeatimage != null && Object.hasOwnProperty.call(message, "Repeatimage"))
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.Repeatimage);
                    if (message.Imagetype != null && Object.hasOwnProperty.call(message, "Imagetype"))
                        writer.uint32(/* id 20, wireType 0 =*/160).int32(message.Imagetype);
                    if (message.Index != null && Object.hasOwnProperty.call(message, "Index"))
                        writer.uint32(/* id 21, wireType 0 =*/168).int32(message.Index);
                    if (message.Width != null && Object.hasOwnProperty.call(message, "Width"))
                        writer.uint32(/* id 22, wireType 0 =*/176).int32(message.Width);
                    if (message.Height != null && Object.hasOwnProperty.call(message, "Height"))
                        writer.uint32(/* id 23, wireType 0 =*/184).int32(message.Height);
                    if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                        writer.uint32(/* id 24, wireType 0 =*/192).int32(message.Source);
                    if (message.Size != null && Object.hasOwnProperty.call(message, "Size"))
                        writer.uint32(/* id 25, wireType 0 =*/200).int32(message.Size);
                    if (message.Origin != null && Object.hasOwnProperty.call(message, "Origin"))
                        writer.uint32(/* id 26, wireType 0 =*/208).int32(message.Origin);
                    if (message.Thumbwidth != null && Object.hasOwnProperty.call(message, "Thumbwidth"))
                        writer.uint32(/* id 27, wireType 0 =*/216).int32(message.Thumbwidth);
                    if (message.Thumbheight != null && Object.hasOwnProperty.call(message, "Thumbheight"))
                        writer.uint32(/* id 28, wireType 0 =*/224).int32(message.Thumbheight);
                    if (message.Showlen != null && Object.hasOwnProperty.call(message, "Showlen"))
                        writer.uint32(/* id 29, wireType 0 =*/232).int32(message.Showlen);
                    if (message.Downloadlen != null && Object.hasOwnProperty.call(message, "Downloadlen"))
                        writer.uint32(/* id 30, wireType 0 =*/240).int32(message.Downloadlen);
                    if (message.Url != null && Object.hasOwnProperty.call(message, "Url"))
                        writer.uint32(/* id 31, wireType 2 =*/250).string(message.Url);
                    if (message.Otherwidth != null && Object.hasOwnProperty.call(message, "Otherwidth"))
                        writer.uint32(/* id 32, wireType 0 =*/256).int32(message.Otherwidth);
                    if (message.Otherheight != null && Object.hasOwnProperty.call(message, "Otherheight"))
                        writer.uint32(/* id 33, wireType 0 =*/264).int32(message.Otherheight);
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 34, wireType 2 =*/274).bytes(message.Pbreserve);
                    return writer;
                };

                /**
                 * Encodes the specified HcFlashPic message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.HcFlashPic.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IHcFlashPic} message HcFlashPic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HcFlashPic.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a HcFlashPic message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.HcFlashPic} HcFlashPic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HcFlashPic.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.HcFlashPic();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Guid = reader.bytes();
                            break;
                        case 2:
                            message.Filepath = reader.string();
                            break;
                        case 3:
                            message.Shortcut = reader.string();
                            break;
                        case 4:
                            message.Buffer = reader.bytes();
                            break;
                        case 5:
                            message.Flag = reader.bytes();
                            break;
                        case 6:
                            message.Olddata = reader.bytes();
                            break;
                        case 7:
                            message.Fileid = reader.int32();
                            break;
                        case 8:
                            message.Serverip = reader.int32();
                            break;
                        case 9:
                            message.Serverport = reader.int32();
                            break;
                        case 10:
                            message.Filetype = reader.int32();
                            break;
                        case 11:
                            message.Signature = reader.bytes();
                            break;
                        case 12:
                            message.Useful = reader.int32();
                            break;
                        case 13:
                            message.Md5 = reader.bytes();
                            break;
                        case 14:
                            message.Thumburl = reader.string();
                            break;
                        case 15:
                            message.Bigurl = reader.string();
                            break;
                        case 16:
                            message.Origurl = reader.string();
                            break;
                        case 17:
                            message.Biztype = reader.int32();
                            break;
                        case 18:
                            message.Repeatindex = reader.int32();
                            break;
                        case 19:
                            message.Repeatimage = reader.int32();
                            break;
                        case 20:
                            message.Imagetype = reader.int32();
                            break;
                        case 21:
                            message.Index = reader.int32();
                            break;
                        case 22:
                            message.Width = reader.int32();
                            break;
                        case 23:
                            message.Height = reader.int32();
                            break;
                        case 24:
                            message.Source = reader.int32();
                            break;
                        case 25:
                            message.Size = reader.int32();
                            break;
                        case 26:
                            message.Origin = reader.int32();
                            break;
                        case 27:
                            message.Thumbwidth = reader.int32();
                            break;
                        case 28:
                            message.Thumbheight = reader.int32();
                            break;
                        case 29:
                            message.Showlen = reader.int32();
                            break;
                        case 30:
                            message.Downloadlen = reader.int32();
                            break;
                        case 31:
                            message.Url = reader.string();
                            break;
                        case 32:
                            message.Otherwidth = reader.int32();
                            break;
                        case 33:
                            message.Otherheight = reader.int32();
                            break;
                        case 34:
                            message.Pbreserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a HcFlashPic message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.HcFlashPic} HcFlashPic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HcFlashPic.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a HcFlashPic message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HcFlashPic.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Guid != null && message.hasOwnProperty("Guid"))
                        if (!(message.Guid && typeof message.Guid.length === "number" || $util.isString(message.Guid)))
                            return "Guid: buffer expected";
                    if (message.Filepath != null && message.hasOwnProperty("Filepath"))
                        if (!$util.isString(message.Filepath))
                            return "Filepath: string expected";
                    if (message.Shortcut != null && message.hasOwnProperty("Shortcut"))
                        if (!$util.isString(message.Shortcut))
                            return "Shortcut: string expected";
                    if (message.Buffer != null && message.hasOwnProperty("Buffer"))
                        if (!(message.Buffer && typeof message.Buffer.length === "number" || $util.isString(message.Buffer)))
                            return "Buffer: buffer expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!(message.Flag && typeof message.Flag.length === "number" || $util.isString(message.Flag)))
                            return "Flag: buffer expected";
                    if (message.Olddata != null && message.hasOwnProperty("Olddata"))
                        if (!(message.Olddata && typeof message.Olddata.length === "number" || $util.isString(message.Olddata)))
                            return "Olddata: buffer expected";
                    if (message.Fileid != null && message.hasOwnProperty("Fileid"))
                        if (!$util.isInteger(message.Fileid))
                            return "Fileid: integer expected";
                    if (message.Serverip != null && message.hasOwnProperty("Serverip"))
                        if (!$util.isInteger(message.Serverip))
                            return "Serverip: integer expected";
                    if (message.Serverport != null && message.hasOwnProperty("Serverport"))
                        if (!$util.isInteger(message.Serverport))
                            return "Serverport: integer expected";
                    if (message.Filetype != null && message.hasOwnProperty("Filetype"))
                        if (!$util.isInteger(message.Filetype))
                            return "Filetype: integer expected";
                    if (message.Signature != null && message.hasOwnProperty("Signature"))
                        if (!(message.Signature && typeof message.Signature.length === "number" || $util.isString(message.Signature)))
                            return "Signature: buffer expected";
                    if (message.Useful != null && message.hasOwnProperty("Useful"))
                        if (!$util.isInteger(message.Useful))
                            return "Useful: integer expected";
                    if (message.Md5 != null && message.hasOwnProperty("Md5"))
                        if (!(message.Md5 && typeof message.Md5.length === "number" || $util.isString(message.Md5)))
                            return "Md5: buffer expected";
                    if (message.Thumburl != null && message.hasOwnProperty("Thumburl"))
                        if (!$util.isString(message.Thumburl))
                            return "Thumburl: string expected";
                    if (message.Bigurl != null && message.hasOwnProperty("Bigurl"))
                        if (!$util.isString(message.Bigurl))
                            return "Bigurl: string expected";
                    if (message.Origurl != null && message.hasOwnProperty("Origurl"))
                        if (!$util.isString(message.Origurl))
                            return "Origurl: string expected";
                    if (message.Biztype != null && message.hasOwnProperty("Biztype"))
                        if (!$util.isInteger(message.Biztype))
                            return "Biztype: integer expected";
                    if (message.Repeatindex != null && message.hasOwnProperty("Repeatindex"))
                        if (!$util.isInteger(message.Repeatindex))
                            return "Repeatindex: integer expected";
                    if (message.Repeatimage != null && message.hasOwnProperty("Repeatimage"))
                        if (!$util.isInteger(message.Repeatimage))
                            return "Repeatimage: integer expected";
                    if (message.Imagetype != null && message.hasOwnProperty("Imagetype"))
                        if (!$util.isInteger(message.Imagetype))
                            return "Imagetype: integer expected";
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        if (!$util.isInteger(message.Index))
                            return "Index: integer expected";
                    if (message.Width != null && message.hasOwnProperty("Width"))
                        if (!$util.isInteger(message.Width))
                            return "Width: integer expected";
                    if (message.Height != null && message.hasOwnProperty("Height"))
                        if (!$util.isInteger(message.Height))
                            return "Height: integer expected";
                    if (message.Source != null && message.hasOwnProperty("Source"))
                        if (!$util.isInteger(message.Source))
                            return "Source: integer expected";
                    if (message.Size != null && message.hasOwnProperty("Size"))
                        if (!$util.isInteger(message.Size))
                            return "Size: integer expected";
                    if (message.Origin != null && message.hasOwnProperty("Origin"))
                        if (!$util.isInteger(message.Origin))
                            return "Origin: integer expected";
                    if (message.Thumbwidth != null && message.hasOwnProperty("Thumbwidth"))
                        if (!$util.isInteger(message.Thumbwidth))
                            return "Thumbwidth: integer expected";
                    if (message.Thumbheight != null && message.hasOwnProperty("Thumbheight"))
                        if (!$util.isInteger(message.Thumbheight))
                            return "Thumbheight: integer expected";
                    if (message.Showlen != null && message.hasOwnProperty("Showlen"))
                        if (!$util.isInteger(message.Showlen))
                            return "Showlen: integer expected";
                    if (message.Downloadlen != null && message.hasOwnProperty("Downloadlen"))
                        if (!$util.isInteger(message.Downloadlen))
                            return "Downloadlen: integer expected";
                    if (message.Url != null && message.hasOwnProperty("Url"))
                        if (!$util.isString(message.Url))
                            return "Url: string expected";
                    if (message.Otherwidth != null && message.hasOwnProperty("Otherwidth"))
                        if (!$util.isInteger(message.Otherwidth))
                            return "Otherwidth: integer expected";
                    if (message.Otherheight != null && message.hasOwnProperty("Otherheight"))
                        if (!$util.isInteger(message.Otherheight))
                            return "Otherheight: integer expected";
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    return null;
                };

                /**
                 * Creates a HcFlashPic message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.HcFlashPic} HcFlashPic
                 */
                HcFlashPic.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.HcFlashPic)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.HcFlashPic();
                    if (object.Guid != null)
                        if (typeof object.Guid === "string")
                            $util.base64.decode(object.Guid, message.Guid = $util.newBuffer($util.base64.length(object.Guid)), 0);
                        else if (object.Guid.length)
                            message.Guid = object.Guid;
                    if (object.Filepath != null)
                        message.Filepath = String(object.Filepath);
                    if (object.Shortcut != null)
                        message.Shortcut = String(object.Shortcut);
                    if (object.Buffer != null)
                        if (typeof object.Buffer === "string")
                            $util.base64.decode(object.Buffer, message.Buffer = $util.newBuffer($util.base64.length(object.Buffer)), 0);
                        else if (object.Buffer.length)
                            message.Buffer = object.Buffer;
                    if (object.Flag != null)
                        if (typeof object.Flag === "string")
                            $util.base64.decode(object.Flag, message.Flag = $util.newBuffer($util.base64.length(object.Flag)), 0);
                        else if (object.Flag.length)
                            message.Flag = object.Flag;
                    if (object.Olddata != null)
                        if (typeof object.Olddata === "string")
                            $util.base64.decode(object.Olddata, message.Olddata = $util.newBuffer($util.base64.length(object.Olddata)), 0);
                        else if (object.Olddata.length)
                            message.Olddata = object.Olddata;
                    if (object.Fileid != null)
                        message.Fileid = object.Fileid | 0;
                    if (object.Serverip != null)
                        message.Serverip = object.Serverip | 0;
                    if (object.Serverport != null)
                        message.Serverport = object.Serverport | 0;
                    if (object.Filetype != null)
                        message.Filetype = object.Filetype | 0;
                    if (object.Signature != null)
                        if (typeof object.Signature === "string")
                            $util.base64.decode(object.Signature, message.Signature = $util.newBuffer($util.base64.length(object.Signature)), 0);
                        else if (object.Signature.length)
                            message.Signature = object.Signature;
                    if (object.Useful != null)
                        message.Useful = object.Useful | 0;
                    if (object.Md5 != null)
                        if (typeof object.Md5 === "string")
                            $util.base64.decode(object.Md5, message.Md5 = $util.newBuffer($util.base64.length(object.Md5)), 0);
                        else if (object.Md5.length)
                            message.Md5 = object.Md5;
                    if (object.Thumburl != null)
                        message.Thumburl = String(object.Thumburl);
                    if (object.Bigurl != null)
                        message.Bigurl = String(object.Bigurl);
                    if (object.Origurl != null)
                        message.Origurl = String(object.Origurl);
                    if (object.Biztype != null)
                        message.Biztype = object.Biztype | 0;
                    if (object.Repeatindex != null)
                        message.Repeatindex = object.Repeatindex | 0;
                    if (object.Repeatimage != null)
                        message.Repeatimage = object.Repeatimage | 0;
                    if (object.Imagetype != null)
                        message.Imagetype = object.Imagetype | 0;
                    if (object.Index != null)
                        message.Index = object.Index | 0;
                    if (object.Width != null)
                        message.Width = object.Width | 0;
                    if (object.Height != null)
                        message.Height = object.Height | 0;
                    if (object.Source != null)
                        message.Source = object.Source | 0;
                    if (object.Size != null)
                        message.Size = object.Size | 0;
                    if (object.Origin != null)
                        message.Origin = object.Origin | 0;
                    if (object.Thumbwidth != null)
                        message.Thumbwidth = object.Thumbwidth | 0;
                    if (object.Thumbheight != null)
                        message.Thumbheight = object.Thumbheight | 0;
                    if (object.Showlen != null)
                        message.Showlen = object.Showlen | 0;
                    if (object.Downloadlen != null)
                        message.Downloadlen = object.Downloadlen | 0;
                    if (object.Url != null)
                        message.Url = String(object.Url);
                    if (object.Otherwidth != null)
                        message.Otherwidth = object.Otherwidth | 0;
                    if (object.Otherheight != null)
                        message.Otherheight = object.Otherheight | 0;
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    return message;
                };

                /**
                 * Creates a plain object from a HcFlashPic message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.HcFlashPic} message HcFlashPic
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HcFlashPic.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Guid = "";
                        else {
                            object.Guid = [];
                            if (options.bytes !== Array)
                                object.Guid = $util.newBuffer(object.Guid);
                        }
                        object.Filepath = "";
                        object.Shortcut = "";
                        if (options.bytes === String)
                            object.Buffer = "";
                        else {
                            object.Buffer = [];
                            if (options.bytes !== Array)
                                object.Buffer = $util.newBuffer(object.Buffer);
                        }
                        if (options.bytes === String)
                            object.Flag = "";
                        else {
                            object.Flag = [];
                            if (options.bytes !== Array)
                                object.Flag = $util.newBuffer(object.Flag);
                        }
                        if (options.bytes === String)
                            object.Olddata = "";
                        else {
                            object.Olddata = [];
                            if (options.bytes !== Array)
                                object.Olddata = $util.newBuffer(object.Olddata);
                        }
                        object.Fileid = 0;
                        object.Serverip = 0;
                        object.Serverport = 0;
                        object.Filetype = 0;
                        if (options.bytes === String)
                            object.Signature = "";
                        else {
                            object.Signature = [];
                            if (options.bytes !== Array)
                                object.Signature = $util.newBuffer(object.Signature);
                        }
                        object.Useful = 0;
                        if (options.bytes === String)
                            object.Md5 = "";
                        else {
                            object.Md5 = [];
                            if (options.bytes !== Array)
                                object.Md5 = $util.newBuffer(object.Md5);
                        }
                        object.Thumburl = "";
                        object.Bigurl = "";
                        object.Origurl = "";
                        object.Biztype = 0;
                        object.Repeatindex = 0;
                        object.Repeatimage = 0;
                        object.Imagetype = 0;
                        object.Index = 0;
                        object.Width = 0;
                        object.Height = 0;
                        object.Source = 0;
                        object.Size = 0;
                        object.Origin = 0;
                        object.Thumbwidth = 0;
                        object.Thumbheight = 0;
                        object.Showlen = 0;
                        object.Downloadlen = 0;
                        object.Url = "";
                        object.Otherwidth = 0;
                        object.Otherheight = 0;
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                    }
                    if (message.Guid != null && message.hasOwnProperty("Guid"))
                        object.Guid = options.bytes === String ? $util.base64.encode(message.Guid, 0, message.Guid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Guid) : message.Guid;
                    if (message.Filepath != null && message.hasOwnProperty("Filepath"))
                        object.Filepath = message.Filepath;
                    if (message.Shortcut != null && message.hasOwnProperty("Shortcut"))
                        object.Shortcut = message.Shortcut;
                    if (message.Buffer != null && message.hasOwnProperty("Buffer"))
                        object.Buffer = options.bytes === String ? $util.base64.encode(message.Buffer, 0, message.Buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.Buffer) : message.Buffer;
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = options.bytes === String ? $util.base64.encode(message.Flag, 0, message.Flag.length) : options.bytes === Array ? Array.prototype.slice.call(message.Flag) : message.Flag;
                    if (message.Olddata != null && message.hasOwnProperty("Olddata"))
                        object.Olddata = options.bytes === String ? $util.base64.encode(message.Olddata, 0, message.Olddata.length) : options.bytes === Array ? Array.prototype.slice.call(message.Olddata) : message.Olddata;
                    if (message.Fileid != null && message.hasOwnProperty("Fileid"))
                        object.Fileid = message.Fileid;
                    if (message.Serverip != null && message.hasOwnProperty("Serverip"))
                        object.Serverip = message.Serverip;
                    if (message.Serverport != null && message.hasOwnProperty("Serverport"))
                        object.Serverport = message.Serverport;
                    if (message.Filetype != null && message.hasOwnProperty("Filetype"))
                        object.Filetype = message.Filetype;
                    if (message.Signature != null && message.hasOwnProperty("Signature"))
                        object.Signature = options.bytes === String ? $util.base64.encode(message.Signature, 0, message.Signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.Signature) : message.Signature;
                    if (message.Useful != null && message.hasOwnProperty("Useful"))
                        object.Useful = message.Useful;
                    if (message.Md5 != null && message.hasOwnProperty("Md5"))
                        object.Md5 = options.bytes === String ? $util.base64.encode(message.Md5, 0, message.Md5.length) : options.bytes === Array ? Array.prototype.slice.call(message.Md5) : message.Md5;
                    if (message.Thumburl != null && message.hasOwnProperty("Thumburl"))
                        object.Thumburl = message.Thumburl;
                    if (message.Bigurl != null && message.hasOwnProperty("Bigurl"))
                        object.Bigurl = message.Bigurl;
                    if (message.Origurl != null && message.hasOwnProperty("Origurl"))
                        object.Origurl = message.Origurl;
                    if (message.Biztype != null && message.hasOwnProperty("Biztype"))
                        object.Biztype = message.Biztype;
                    if (message.Repeatindex != null && message.hasOwnProperty("Repeatindex"))
                        object.Repeatindex = message.Repeatindex;
                    if (message.Repeatimage != null && message.hasOwnProperty("Repeatimage"))
                        object.Repeatimage = message.Repeatimage;
                    if (message.Imagetype != null && message.hasOwnProperty("Imagetype"))
                        object.Imagetype = message.Imagetype;
                    if (message.Index != null && message.hasOwnProperty("Index"))
                        object.Index = message.Index;
                    if (message.Width != null && message.hasOwnProperty("Width"))
                        object.Width = message.Width;
                    if (message.Height != null && message.hasOwnProperty("Height"))
                        object.Height = message.Height;
                    if (message.Source != null && message.hasOwnProperty("Source"))
                        object.Source = message.Source;
                    if (message.Size != null && message.hasOwnProperty("Size"))
                        object.Size = message.Size;
                    if (message.Origin != null && message.hasOwnProperty("Origin"))
                        object.Origin = message.Origin;
                    if (message.Thumbwidth != null && message.hasOwnProperty("Thumbwidth"))
                        object.Thumbwidth = message.Thumbwidth;
                    if (message.Thumbheight != null && message.hasOwnProperty("Thumbheight"))
                        object.Thumbheight = message.Thumbheight;
                    if (message.Showlen != null && message.hasOwnProperty("Showlen"))
                        object.Showlen = message.Showlen;
                    if (message.Downloadlen != null && message.hasOwnProperty("Downloadlen"))
                        object.Downloadlen = message.Downloadlen;
                    if (message.Url != null && message.hasOwnProperty("Url"))
                        object.Url = message.Url;
                    if (message.Otherwidth != null && message.hasOwnProperty("Otherwidth"))
                        object.Otherwidth = message.Otherwidth;
                    if (message.Otherheight != null && message.hasOwnProperty("Otherheight"))
                        object.Otherheight = message.Otherheight;
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    return object;
                };

                /**
                 * Converts this HcFlashPic to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.HcFlashPic
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HcFlashPic.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HcFlashPic;
            })();

            ImMsgBody.DeliverGiftMsg = (function() {

                /**
                 * Properties of a DeliverGiftMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IDeliverGiftMsg
                 * @property {Uint8Array|null} [Graytipcontent] DeliverGiftMsg Graytipcontent
                 * @property {number|null} [Animationpackageid] DeliverGiftMsg Animationpackageid
                 * @property {Uint8Array|null} [Animationpackageurla] DeliverGiftMsg Animationpackageurla
                 * @property {Uint8Array|null} [Animationpackageurli] DeliverGiftMsg Animationpackageurli
                 * @property {Uint8Array|null} [Remindbrief] DeliverGiftMsg Remindbrief
                 * @property {number|null} [Giftid] DeliverGiftMsg Giftid
                 * @property {number|null} [Giftcount] DeliverGiftMsg Giftcount
                 * @property {Uint8Array|null} [Animationbrief] DeliverGiftMsg Animationbrief
                 * @property {number|Long|null} [Senderuin] DeliverGiftMsg Senderuin
                 * @property {number|Long|null} [Receiveruin] DeliverGiftMsg Receiveruin
                 * @property {Uint8Array|null} [Stmessagetitle] DeliverGiftMsg Stmessagetitle
                 * @property {Uint8Array|null} [Stmessagesubtitle] DeliverGiftMsg Stmessagesubtitle
                 * @property {Uint8Array|null} [Stmessagemessage] DeliverGiftMsg Stmessagemessage
                 * @property {number|null} [Stmessagegiftpicid] DeliverGiftMsg Stmessagegiftpicid
                 * @property {Uint8Array|null} [Stmessagecomefrom] DeliverGiftMsg Stmessagecomefrom
                 * @property {number|null} [Stmessageexflag] DeliverGiftMsg Stmessageexflag
                 * @property {Uint8Array|null} [Toallgiftid] DeliverGiftMsg Toallgiftid
                 * @property {Uint8Array|null} [Comefromlink] DeliverGiftMsg Comefromlink
                 * @property {Uint8Array|null} [Pbreserve] DeliverGiftMsg Pbreserve
                 * @property {Uint8Array|null} [Receivername] DeliverGiftMsg Receivername
                 * @property {Uint8Array|null} [Receiverpic] DeliverGiftMsg Receiverpic
                 * @property {Uint8Array|null} [Stmessagegifturl] DeliverGiftMsg Stmessagegifturl
                 */

                /**
                 * Constructs a new DeliverGiftMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a DeliverGiftMsg.
                 * @implements IDeliverGiftMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IDeliverGiftMsg=} [properties] Properties to set
                 */
                function DeliverGiftMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeliverGiftMsg Graytipcontent.
                 * @member {Uint8Array} Graytipcontent
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Graytipcontent = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Animationpackageid.
                 * @member {number} Animationpackageid
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Animationpackageid = 0;

                /**
                 * DeliverGiftMsg Animationpackageurla.
                 * @member {Uint8Array} Animationpackageurla
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Animationpackageurla = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Animationpackageurli.
                 * @member {Uint8Array} Animationpackageurli
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Animationpackageurli = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Remindbrief.
                 * @member {Uint8Array} Remindbrief
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Remindbrief = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Giftid.
                 * @member {number} Giftid
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Giftid = 0;

                /**
                 * DeliverGiftMsg Giftcount.
                 * @member {number} Giftcount
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Giftcount = 0;

                /**
                 * DeliverGiftMsg Animationbrief.
                 * @member {Uint8Array} Animationbrief
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Animationbrief = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Senderuin.
                 * @member {number|Long} Senderuin
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Senderuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DeliverGiftMsg Receiveruin.
                 * @member {number|Long} Receiveruin
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Receiveruin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DeliverGiftMsg Stmessagetitle.
                 * @member {Uint8Array} Stmessagetitle
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Stmessagetitle = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Stmessagesubtitle.
                 * @member {Uint8Array} Stmessagesubtitle
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Stmessagesubtitle = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Stmessagemessage.
                 * @member {Uint8Array} Stmessagemessage
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Stmessagemessage = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Stmessagegiftpicid.
                 * @member {number} Stmessagegiftpicid
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Stmessagegiftpicid = 0;

                /**
                 * DeliverGiftMsg Stmessagecomefrom.
                 * @member {Uint8Array} Stmessagecomefrom
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Stmessagecomefrom = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Stmessageexflag.
                 * @member {number} Stmessageexflag
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Stmessageexflag = 0;

                /**
                 * DeliverGiftMsg Toallgiftid.
                 * @member {Uint8Array} Toallgiftid
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Toallgiftid = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Comefromlink.
                 * @member {Uint8Array} Comefromlink
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Comefromlink = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Receivername.
                 * @member {Uint8Array} Receivername
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Receivername = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Receiverpic.
                 * @member {Uint8Array} Receiverpic
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Receiverpic = $util.newBuffer([]);

                /**
                 * DeliverGiftMsg Stmessagegifturl.
                 * @member {Uint8Array} Stmessagegifturl
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 */
                DeliverGiftMsg.prototype.Stmessagegifturl = $util.newBuffer([]);

                /**
                 * Creates a new DeliverGiftMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IDeliverGiftMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.DeliverGiftMsg} DeliverGiftMsg instance
                 */
                DeliverGiftMsg.create = function create(properties) {
                    return new DeliverGiftMsg(properties);
                };

                /**
                 * Encodes the specified DeliverGiftMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.DeliverGiftMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IDeliverGiftMsg} message DeliverGiftMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeliverGiftMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Graytipcontent != null && Object.hasOwnProperty.call(message, "Graytipcontent"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Graytipcontent);
                    if (message.Animationpackageid != null && Object.hasOwnProperty.call(message, "Animationpackageid"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Animationpackageid);
                    if (message.Animationpackageurla != null && Object.hasOwnProperty.call(message, "Animationpackageurla"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Animationpackageurla);
                    if (message.Animationpackageurli != null && Object.hasOwnProperty.call(message, "Animationpackageurli"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Animationpackageurli);
                    if (message.Remindbrief != null && Object.hasOwnProperty.call(message, "Remindbrief"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Remindbrief);
                    if (message.Giftid != null && Object.hasOwnProperty.call(message, "Giftid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Giftid);
                    if (message.Giftcount != null && Object.hasOwnProperty.call(message, "Giftcount"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Giftcount);
                    if (message.Animationbrief != null && Object.hasOwnProperty.call(message, "Animationbrief"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Animationbrief);
                    if (message.Senderuin != null && Object.hasOwnProperty.call(message, "Senderuin"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int64(message.Senderuin);
                    if (message.Receiveruin != null && Object.hasOwnProperty.call(message, "Receiveruin"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int64(message.Receiveruin);
                    if (message.Stmessagetitle != null && Object.hasOwnProperty.call(message, "Stmessagetitle"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Stmessagetitle);
                    if (message.Stmessagesubtitle != null && Object.hasOwnProperty.call(message, "Stmessagesubtitle"))
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.Stmessagesubtitle);
                    if (message.Stmessagemessage != null && Object.hasOwnProperty.call(message, "Stmessagemessage"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.Stmessagemessage);
                    if (message.Stmessagegiftpicid != null && Object.hasOwnProperty.call(message, "Stmessagegiftpicid"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.Stmessagegiftpicid);
                    if (message.Stmessagecomefrom != null && Object.hasOwnProperty.call(message, "Stmessagecomefrom"))
                        writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.Stmessagecomefrom);
                    if (message.Stmessageexflag != null && Object.hasOwnProperty.call(message, "Stmessageexflag"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.Stmessageexflag);
                    if (message.Toallgiftid != null && Object.hasOwnProperty.call(message, "Toallgiftid"))
                        writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.Toallgiftid);
                    if (message.Comefromlink != null && Object.hasOwnProperty.call(message, "Comefromlink"))
                        writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.Comefromlink);
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.Pbreserve);
                    if (message.Receivername != null && Object.hasOwnProperty.call(message, "Receivername"))
                        writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.Receivername);
                    if (message.Receiverpic != null && Object.hasOwnProperty.call(message, "Receiverpic"))
                        writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.Receiverpic);
                    if (message.Stmessagegifturl != null && Object.hasOwnProperty.call(message, "Stmessagegifturl"))
                        writer.uint32(/* id 22, wireType 2 =*/178).bytes(message.Stmessagegifturl);
                    return writer;
                };

                /**
                 * Encodes the specified DeliverGiftMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.DeliverGiftMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IDeliverGiftMsg} message DeliverGiftMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeliverGiftMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeliverGiftMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.DeliverGiftMsg} DeliverGiftMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeliverGiftMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Graytipcontent = reader.bytes();
                            break;
                        case 2:
                            message.Animationpackageid = reader.int32();
                            break;
                        case 3:
                            message.Animationpackageurla = reader.bytes();
                            break;
                        case 4:
                            message.Animationpackageurli = reader.bytes();
                            break;
                        case 5:
                            message.Remindbrief = reader.bytes();
                            break;
                        case 6:
                            message.Giftid = reader.int32();
                            break;
                        case 7:
                            message.Giftcount = reader.int32();
                            break;
                        case 8:
                            message.Animationbrief = reader.bytes();
                            break;
                        case 9:
                            message.Senderuin = reader.int64();
                            break;
                        case 10:
                            message.Receiveruin = reader.int64();
                            break;
                        case 11:
                            message.Stmessagetitle = reader.bytes();
                            break;
                        case 12:
                            message.Stmessagesubtitle = reader.bytes();
                            break;
                        case 13:
                            message.Stmessagemessage = reader.bytes();
                            break;
                        case 14:
                            message.Stmessagegiftpicid = reader.int32();
                            break;
                        case 15:
                            message.Stmessagecomefrom = reader.bytes();
                            break;
                        case 16:
                            message.Stmessageexflag = reader.int32();
                            break;
                        case 17:
                            message.Toallgiftid = reader.bytes();
                            break;
                        case 18:
                            message.Comefromlink = reader.bytes();
                            break;
                        case 19:
                            message.Pbreserve = reader.bytes();
                            break;
                        case 20:
                            message.Receivername = reader.bytes();
                            break;
                        case 21:
                            message.Receiverpic = reader.bytes();
                            break;
                        case 22:
                            message.Stmessagegifturl = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeliverGiftMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.DeliverGiftMsg} DeliverGiftMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeliverGiftMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeliverGiftMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeliverGiftMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Graytipcontent != null && message.hasOwnProperty("Graytipcontent"))
                        if (!(message.Graytipcontent && typeof message.Graytipcontent.length === "number" || $util.isString(message.Graytipcontent)))
                            return "Graytipcontent: buffer expected";
                    if (message.Animationpackageid != null && message.hasOwnProperty("Animationpackageid"))
                        if (!$util.isInteger(message.Animationpackageid))
                            return "Animationpackageid: integer expected";
                    if (message.Animationpackageurla != null && message.hasOwnProperty("Animationpackageurla"))
                        if (!(message.Animationpackageurla && typeof message.Animationpackageurla.length === "number" || $util.isString(message.Animationpackageurla)))
                            return "Animationpackageurla: buffer expected";
                    if (message.Animationpackageurli != null && message.hasOwnProperty("Animationpackageurli"))
                        if (!(message.Animationpackageurli && typeof message.Animationpackageurli.length === "number" || $util.isString(message.Animationpackageurli)))
                            return "Animationpackageurli: buffer expected";
                    if (message.Remindbrief != null && message.hasOwnProperty("Remindbrief"))
                        if (!(message.Remindbrief && typeof message.Remindbrief.length === "number" || $util.isString(message.Remindbrief)))
                            return "Remindbrief: buffer expected";
                    if (message.Giftid != null && message.hasOwnProperty("Giftid"))
                        if (!$util.isInteger(message.Giftid))
                            return "Giftid: integer expected";
                    if (message.Giftcount != null && message.hasOwnProperty("Giftcount"))
                        if (!$util.isInteger(message.Giftcount))
                            return "Giftcount: integer expected";
                    if (message.Animationbrief != null && message.hasOwnProperty("Animationbrief"))
                        if (!(message.Animationbrief && typeof message.Animationbrief.length === "number" || $util.isString(message.Animationbrief)))
                            return "Animationbrief: buffer expected";
                    if (message.Senderuin != null && message.hasOwnProperty("Senderuin"))
                        if (!$util.isInteger(message.Senderuin) && !(message.Senderuin && $util.isInteger(message.Senderuin.low) && $util.isInteger(message.Senderuin.high)))
                            return "Senderuin: integer|Long expected";
                    if (message.Receiveruin != null && message.hasOwnProperty("Receiveruin"))
                        if (!$util.isInteger(message.Receiveruin) && !(message.Receiveruin && $util.isInteger(message.Receiveruin.low) && $util.isInteger(message.Receiveruin.high)))
                            return "Receiveruin: integer|Long expected";
                    if (message.Stmessagetitle != null && message.hasOwnProperty("Stmessagetitle"))
                        if (!(message.Stmessagetitle && typeof message.Stmessagetitle.length === "number" || $util.isString(message.Stmessagetitle)))
                            return "Stmessagetitle: buffer expected";
                    if (message.Stmessagesubtitle != null && message.hasOwnProperty("Stmessagesubtitle"))
                        if (!(message.Stmessagesubtitle && typeof message.Stmessagesubtitle.length === "number" || $util.isString(message.Stmessagesubtitle)))
                            return "Stmessagesubtitle: buffer expected";
                    if (message.Stmessagemessage != null && message.hasOwnProperty("Stmessagemessage"))
                        if (!(message.Stmessagemessage && typeof message.Stmessagemessage.length === "number" || $util.isString(message.Stmessagemessage)))
                            return "Stmessagemessage: buffer expected";
                    if (message.Stmessagegiftpicid != null && message.hasOwnProperty("Stmessagegiftpicid"))
                        if (!$util.isInteger(message.Stmessagegiftpicid))
                            return "Stmessagegiftpicid: integer expected";
                    if (message.Stmessagecomefrom != null && message.hasOwnProperty("Stmessagecomefrom"))
                        if (!(message.Stmessagecomefrom && typeof message.Stmessagecomefrom.length === "number" || $util.isString(message.Stmessagecomefrom)))
                            return "Stmessagecomefrom: buffer expected";
                    if (message.Stmessageexflag != null && message.hasOwnProperty("Stmessageexflag"))
                        if (!$util.isInteger(message.Stmessageexflag))
                            return "Stmessageexflag: integer expected";
                    if (message.Toallgiftid != null && message.hasOwnProperty("Toallgiftid"))
                        if (!(message.Toallgiftid && typeof message.Toallgiftid.length === "number" || $util.isString(message.Toallgiftid)))
                            return "Toallgiftid: buffer expected";
                    if (message.Comefromlink != null && message.hasOwnProperty("Comefromlink"))
                        if (!(message.Comefromlink && typeof message.Comefromlink.length === "number" || $util.isString(message.Comefromlink)))
                            return "Comefromlink: buffer expected";
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    if (message.Receivername != null && message.hasOwnProperty("Receivername"))
                        if (!(message.Receivername && typeof message.Receivername.length === "number" || $util.isString(message.Receivername)))
                            return "Receivername: buffer expected";
                    if (message.Receiverpic != null && message.hasOwnProperty("Receiverpic"))
                        if (!(message.Receiverpic && typeof message.Receiverpic.length === "number" || $util.isString(message.Receiverpic)))
                            return "Receiverpic: buffer expected";
                    if (message.Stmessagegifturl != null && message.hasOwnProperty("Stmessagegifturl"))
                        if (!(message.Stmessagegifturl && typeof message.Stmessagegifturl.length === "number" || $util.isString(message.Stmessagegifturl)))
                            return "Stmessagegifturl: buffer expected";
                    return null;
                };

                /**
                 * Creates a DeliverGiftMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.DeliverGiftMsg} DeliverGiftMsg
                 */
                DeliverGiftMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg();
                    if (object.Graytipcontent != null)
                        if (typeof object.Graytipcontent === "string")
                            $util.base64.decode(object.Graytipcontent, message.Graytipcontent = $util.newBuffer($util.base64.length(object.Graytipcontent)), 0);
                        else if (object.Graytipcontent.length)
                            message.Graytipcontent = object.Graytipcontent;
                    if (object.Animationpackageid != null)
                        message.Animationpackageid = object.Animationpackageid | 0;
                    if (object.Animationpackageurla != null)
                        if (typeof object.Animationpackageurla === "string")
                            $util.base64.decode(object.Animationpackageurla, message.Animationpackageurla = $util.newBuffer($util.base64.length(object.Animationpackageurla)), 0);
                        else if (object.Animationpackageurla.length)
                            message.Animationpackageurla = object.Animationpackageurla;
                    if (object.Animationpackageurli != null)
                        if (typeof object.Animationpackageurli === "string")
                            $util.base64.decode(object.Animationpackageurli, message.Animationpackageurli = $util.newBuffer($util.base64.length(object.Animationpackageurli)), 0);
                        else if (object.Animationpackageurli.length)
                            message.Animationpackageurli = object.Animationpackageurli;
                    if (object.Remindbrief != null)
                        if (typeof object.Remindbrief === "string")
                            $util.base64.decode(object.Remindbrief, message.Remindbrief = $util.newBuffer($util.base64.length(object.Remindbrief)), 0);
                        else if (object.Remindbrief.length)
                            message.Remindbrief = object.Remindbrief;
                    if (object.Giftid != null)
                        message.Giftid = object.Giftid | 0;
                    if (object.Giftcount != null)
                        message.Giftcount = object.Giftcount | 0;
                    if (object.Animationbrief != null)
                        if (typeof object.Animationbrief === "string")
                            $util.base64.decode(object.Animationbrief, message.Animationbrief = $util.newBuffer($util.base64.length(object.Animationbrief)), 0);
                        else if (object.Animationbrief.length)
                            message.Animationbrief = object.Animationbrief;
                    if (object.Senderuin != null)
                        if ($util.Long)
                            (message.Senderuin = $util.Long.fromValue(object.Senderuin)).unsigned = false;
                        else if (typeof object.Senderuin === "string")
                            message.Senderuin = parseInt(object.Senderuin, 10);
                        else if (typeof object.Senderuin === "number")
                            message.Senderuin = object.Senderuin;
                        else if (typeof object.Senderuin === "object")
                            message.Senderuin = new $util.LongBits(object.Senderuin.low >>> 0, object.Senderuin.high >>> 0).toNumber();
                    if (object.Receiveruin != null)
                        if ($util.Long)
                            (message.Receiveruin = $util.Long.fromValue(object.Receiveruin)).unsigned = false;
                        else if (typeof object.Receiveruin === "string")
                            message.Receiveruin = parseInt(object.Receiveruin, 10);
                        else if (typeof object.Receiveruin === "number")
                            message.Receiveruin = object.Receiveruin;
                        else if (typeof object.Receiveruin === "object")
                            message.Receiveruin = new $util.LongBits(object.Receiveruin.low >>> 0, object.Receiveruin.high >>> 0).toNumber();
                    if (object.Stmessagetitle != null)
                        if (typeof object.Stmessagetitle === "string")
                            $util.base64.decode(object.Stmessagetitle, message.Stmessagetitle = $util.newBuffer($util.base64.length(object.Stmessagetitle)), 0);
                        else if (object.Stmessagetitle.length)
                            message.Stmessagetitle = object.Stmessagetitle;
                    if (object.Stmessagesubtitle != null)
                        if (typeof object.Stmessagesubtitle === "string")
                            $util.base64.decode(object.Stmessagesubtitle, message.Stmessagesubtitle = $util.newBuffer($util.base64.length(object.Stmessagesubtitle)), 0);
                        else if (object.Stmessagesubtitle.length)
                            message.Stmessagesubtitle = object.Stmessagesubtitle;
                    if (object.Stmessagemessage != null)
                        if (typeof object.Stmessagemessage === "string")
                            $util.base64.decode(object.Stmessagemessage, message.Stmessagemessage = $util.newBuffer($util.base64.length(object.Stmessagemessage)), 0);
                        else if (object.Stmessagemessage.length)
                            message.Stmessagemessage = object.Stmessagemessage;
                    if (object.Stmessagegiftpicid != null)
                        message.Stmessagegiftpicid = object.Stmessagegiftpicid | 0;
                    if (object.Stmessagecomefrom != null)
                        if (typeof object.Stmessagecomefrom === "string")
                            $util.base64.decode(object.Stmessagecomefrom, message.Stmessagecomefrom = $util.newBuffer($util.base64.length(object.Stmessagecomefrom)), 0);
                        else if (object.Stmessagecomefrom.length)
                            message.Stmessagecomefrom = object.Stmessagecomefrom;
                    if (object.Stmessageexflag != null)
                        message.Stmessageexflag = object.Stmessageexflag | 0;
                    if (object.Toallgiftid != null)
                        if (typeof object.Toallgiftid === "string")
                            $util.base64.decode(object.Toallgiftid, message.Toallgiftid = $util.newBuffer($util.base64.length(object.Toallgiftid)), 0);
                        else if (object.Toallgiftid.length)
                            message.Toallgiftid = object.Toallgiftid;
                    if (object.Comefromlink != null)
                        if (typeof object.Comefromlink === "string")
                            $util.base64.decode(object.Comefromlink, message.Comefromlink = $util.newBuffer($util.base64.length(object.Comefromlink)), 0);
                        else if (object.Comefromlink.length)
                            message.Comefromlink = object.Comefromlink;
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    if (object.Receivername != null)
                        if (typeof object.Receivername === "string")
                            $util.base64.decode(object.Receivername, message.Receivername = $util.newBuffer($util.base64.length(object.Receivername)), 0);
                        else if (object.Receivername.length)
                            message.Receivername = object.Receivername;
                    if (object.Receiverpic != null)
                        if (typeof object.Receiverpic === "string")
                            $util.base64.decode(object.Receiverpic, message.Receiverpic = $util.newBuffer($util.base64.length(object.Receiverpic)), 0);
                        else if (object.Receiverpic.length)
                            message.Receiverpic = object.Receiverpic;
                    if (object.Stmessagegifturl != null)
                        if (typeof object.Stmessagegifturl === "string")
                            $util.base64.decode(object.Stmessagegifturl, message.Stmessagegifturl = $util.newBuffer($util.base64.length(object.Stmessagegifturl)), 0);
                        else if (object.Stmessagegifturl.length)
                            message.Stmessagegifturl = object.Stmessagegifturl;
                    return message;
                };

                /**
                 * Creates a plain object from a DeliverGiftMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.DeliverGiftMsg} message DeliverGiftMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeliverGiftMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Graytipcontent = "";
                        else {
                            object.Graytipcontent = [];
                            if (options.bytes !== Array)
                                object.Graytipcontent = $util.newBuffer(object.Graytipcontent);
                        }
                        object.Animationpackageid = 0;
                        if (options.bytes === String)
                            object.Animationpackageurla = "";
                        else {
                            object.Animationpackageurla = [];
                            if (options.bytes !== Array)
                                object.Animationpackageurla = $util.newBuffer(object.Animationpackageurla);
                        }
                        if (options.bytes === String)
                            object.Animationpackageurli = "";
                        else {
                            object.Animationpackageurli = [];
                            if (options.bytes !== Array)
                                object.Animationpackageurli = $util.newBuffer(object.Animationpackageurli);
                        }
                        if (options.bytes === String)
                            object.Remindbrief = "";
                        else {
                            object.Remindbrief = [];
                            if (options.bytes !== Array)
                                object.Remindbrief = $util.newBuffer(object.Remindbrief);
                        }
                        object.Giftid = 0;
                        object.Giftcount = 0;
                        if (options.bytes === String)
                            object.Animationbrief = "";
                        else {
                            object.Animationbrief = [];
                            if (options.bytes !== Array)
                                object.Animationbrief = $util.newBuffer(object.Animationbrief);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Senderuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Senderuin = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Receiveruin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Receiveruin = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.Stmessagetitle = "";
                        else {
                            object.Stmessagetitle = [];
                            if (options.bytes !== Array)
                                object.Stmessagetitle = $util.newBuffer(object.Stmessagetitle);
                        }
                        if (options.bytes === String)
                            object.Stmessagesubtitle = "";
                        else {
                            object.Stmessagesubtitle = [];
                            if (options.bytes !== Array)
                                object.Stmessagesubtitle = $util.newBuffer(object.Stmessagesubtitle);
                        }
                        if (options.bytes === String)
                            object.Stmessagemessage = "";
                        else {
                            object.Stmessagemessage = [];
                            if (options.bytes !== Array)
                                object.Stmessagemessage = $util.newBuffer(object.Stmessagemessage);
                        }
                        object.Stmessagegiftpicid = 0;
                        if (options.bytes === String)
                            object.Stmessagecomefrom = "";
                        else {
                            object.Stmessagecomefrom = [];
                            if (options.bytes !== Array)
                                object.Stmessagecomefrom = $util.newBuffer(object.Stmessagecomefrom);
                        }
                        object.Stmessageexflag = 0;
                        if (options.bytes === String)
                            object.Toallgiftid = "";
                        else {
                            object.Toallgiftid = [];
                            if (options.bytes !== Array)
                                object.Toallgiftid = $util.newBuffer(object.Toallgiftid);
                        }
                        if (options.bytes === String)
                            object.Comefromlink = "";
                        else {
                            object.Comefromlink = [];
                            if (options.bytes !== Array)
                                object.Comefromlink = $util.newBuffer(object.Comefromlink);
                        }
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                        if (options.bytes === String)
                            object.Receivername = "";
                        else {
                            object.Receivername = [];
                            if (options.bytes !== Array)
                                object.Receivername = $util.newBuffer(object.Receivername);
                        }
                        if (options.bytes === String)
                            object.Receiverpic = "";
                        else {
                            object.Receiverpic = [];
                            if (options.bytes !== Array)
                                object.Receiverpic = $util.newBuffer(object.Receiverpic);
                        }
                        if (options.bytes === String)
                            object.Stmessagegifturl = "";
                        else {
                            object.Stmessagegifturl = [];
                            if (options.bytes !== Array)
                                object.Stmessagegifturl = $util.newBuffer(object.Stmessagegifturl);
                        }
                    }
                    if (message.Graytipcontent != null && message.hasOwnProperty("Graytipcontent"))
                        object.Graytipcontent = options.bytes === String ? $util.base64.encode(message.Graytipcontent, 0, message.Graytipcontent.length) : options.bytes === Array ? Array.prototype.slice.call(message.Graytipcontent) : message.Graytipcontent;
                    if (message.Animationpackageid != null && message.hasOwnProperty("Animationpackageid"))
                        object.Animationpackageid = message.Animationpackageid;
                    if (message.Animationpackageurla != null && message.hasOwnProperty("Animationpackageurla"))
                        object.Animationpackageurla = options.bytes === String ? $util.base64.encode(message.Animationpackageurla, 0, message.Animationpackageurla.length) : options.bytes === Array ? Array.prototype.slice.call(message.Animationpackageurla) : message.Animationpackageurla;
                    if (message.Animationpackageurli != null && message.hasOwnProperty("Animationpackageurli"))
                        object.Animationpackageurli = options.bytes === String ? $util.base64.encode(message.Animationpackageurli, 0, message.Animationpackageurli.length) : options.bytes === Array ? Array.prototype.slice.call(message.Animationpackageurli) : message.Animationpackageurli;
                    if (message.Remindbrief != null && message.hasOwnProperty("Remindbrief"))
                        object.Remindbrief = options.bytes === String ? $util.base64.encode(message.Remindbrief, 0, message.Remindbrief.length) : options.bytes === Array ? Array.prototype.slice.call(message.Remindbrief) : message.Remindbrief;
                    if (message.Giftid != null && message.hasOwnProperty("Giftid"))
                        object.Giftid = message.Giftid;
                    if (message.Giftcount != null && message.hasOwnProperty("Giftcount"))
                        object.Giftcount = message.Giftcount;
                    if (message.Animationbrief != null && message.hasOwnProperty("Animationbrief"))
                        object.Animationbrief = options.bytes === String ? $util.base64.encode(message.Animationbrief, 0, message.Animationbrief.length) : options.bytes === Array ? Array.prototype.slice.call(message.Animationbrief) : message.Animationbrief;
                    if (message.Senderuin != null && message.hasOwnProperty("Senderuin"))
                        if (typeof message.Senderuin === "number")
                            object.Senderuin = options.longs === String ? String(message.Senderuin) : message.Senderuin;
                        else
                            object.Senderuin = options.longs === String ? $util.Long.prototype.toString.call(message.Senderuin) : options.longs === Number ? new $util.LongBits(message.Senderuin.low >>> 0, message.Senderuin.high >>> 0).toNumber() : message.Senderuin;
                    if (message.Receiveruin != null && message.hasOwnProperty("Receiveruin"))
                        if (typeof message.Receiveruin === "number")
                            object.Receiveruin = options.longs === String ? String(message.Receiveruin) : message.Receiveruin;
                        else
                            object.Receiveruin = options.longs === String ? $util.Long.prototype.toString.call(message.Receiveruin) : options.longs === Number ? new $util.LongBits(message.Receiveruin.low >>> 0, message.Receiveruin.high >>> 0).toNumber() : message.Receiveruin;
                    if (message.Stmessagetitle != null && message.hasOwnProperty("Stmessagetitle"))
                        object.Stmessagetitle = options.bytes === String ? $util.base64.encode(message.Stmessagetitle, 0, message.Stmessagetitle.length) : options.bytes === Array ? Array.prototype.slice.call(message.Stmessagetitle) : message.Stmessagetitle;
                    if (message.Stmessagesubtitle != null && message.hasOwnProperty("Stmessagesubtitle"))
                        object.Stmessagesubtitle = options.bytes === String ? $util.base64.encode(message.Stmessagesubtitle, 0, message.Stmessagesubtitle.length) : options.bytes === Array ? Array.prototype.slice.call(message.Stmessagesubtitle) : message.Stmessagesubtitle;
                    if (message.Stmessagemessage != null && message.hasOwnProperty("Stmessagemessage"))
                        object.Stmessagemessage = options.bytes === String ? $util.base64.encode(message.Stmessagemessage, 0, message.Stmessagemessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.Stmessagemessage) : message.Stmessagemessage;
                    if (message.Stmessagegiftpicid != null && message.hasOwnProperty("Stmessagegiftpicid"))
                        object.Stmessagegiftpicid = message.Stmessagegiftpicid;
                    if (message.Stmessagecomefrom != null && message.hasOwnProperty("Stmessagecomefrom"))
                        object.Stmessagecomefrom = options.bytes === String ? $util.base64.encode(message.Stmessagecomefrom, 0, message.Stmessagecomefrom.length) : options.bytes === Array ? Array.prototype.slice.call(message.Stmessagecomefrom) : message.Stmessagecomefrom;
                    if (message.Stmessageexflag != null && message.hasOwnProperty("Stmessageexflag"))
                        object.Stmessageexflag = message.Stmessageexflag;
                    if (message.Toallgiftid != null && message.hasOwnProperty("Toallgiftid"))
                        object.Toallgiftid = options.bytes === String ? $util.base64.encode(message.Toallgiftid, 0, message.Toallgiftid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Toallgiftid) : message.Toallgiftid;
                    if (message.Comefromlink != null && message.hasOwnProperty("Comefromlink"))
                        object.Comefromlink = options.bytes === String ? $util.base64.encode(message.Comefromlink, 0, message.Comefromlink.length) : options.bytes === Array ? Array.prototype.slice.call(message.Comefromlink) : message.Comefromlink;
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    if (message.Receivername != null && message.hasOwnProperty("Receivername"))
                        object.Receivername = options.bytes === String ? $util.base64.encode(message.Receivername, 0, message.Receivername.length) : options.bytes === Array ? Array.prototype.slice.call(message.Receivername) : message.Receivername;
                    if (message.Receiverpic != null && message.hasOwnProperty("Receiverpic"))
                        object.Receiverpic = options.bytes === String ? $util.base64.encode(message.Receiverpic, 0, message.Receiverpic.length) : options.bytes === Array ? Array.prototype.slice.call(message.Receiverpic) : message.Receiverpic;
                    if (message.Stmessagegifturl != null && message.hasOwnProperty("Stmessagegifturl"))
                        object.Stmessagegifturl = options.bytes === String ? $util.base64.encode(message.Stmessagegifturl, 0, message.Stmessagegifturl.length) : options.bytes === Array ? Array.prototype.slice.call(message.Stmessagegifturl) : message.Stmessagegifturl;
                    return object;
                };

                /**
                 * Converts this DeliverGiftMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.DeliverGiftMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeliverGiftMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeliverGiftMsg;
            })();

            ImMsgBody.BitappMsg = (function() {

                /**
                 * Properties of a BitappMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IBitappMsg
                 * @property {Uint8Array|null} [Buff] BitappMsg Buff
                 */

                /**
                 * Constructs a new BitappMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a BitappMsg.
                 * @implements IBitappMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IBitappMsg=} [properties] Properties to set
                 */
                function BitappMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BitappMsg Buff.
                 * @member {Uint8Array} Buff
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @instance
                 */
                BitappMsg.prototype.Buff = $util.newBuffer([]);

                /**
                 * Creates a new BitappMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBitappMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.BitappMsg} BitappMsg instance
                 */
                BitappMsg.create = function create(properties) {
                    return new BitappMsg(properties);
                };

                /**
                 * Encodes the specified BitappMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.BitappMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBitappMsg} message BitappMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BitappMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Buff != null && Object.hasOwnProperty.call(message, "Buff"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Buff);
                    return writer;
                };

                /**
                 * Encodes the specified BitappMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.BitappMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBitappMsg} message BitappMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BitappMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BitappMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.BitappMsg} BitappMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BitappMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.BitappMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Buff = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BitappMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.BitappMsg} BitappMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BitappMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BitappMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BitappMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Buff != null && message.hasOwnProperty("Buff"))
                        if (!(message.Buff && typeof message.Buff.length === "number" || $util.isString(message.Buff)))
                            return "Buff: buffer expected";
                    return null;
                };

                /**
                 * Creates a BitappMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.BitappMsg} BitappMsg
                 */
                BitappMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.BitappMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.BitappMsg();
                    if (object.Buff != null)
                        if (typeof object.Buff === "string")
                            $util.base64.decode(object.Buff, message.Buff = $util.newBuffer($util.base64.length(object.Buff)), 0);
                        else if (object.Buff.length)
                            message.Buff = object.Buff;
                    return message;
                };

                /**
                 * Creates a plain object from a BitappMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.BitappMsg} message BitappMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BitappMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.Buff = "";
                        else {
                            object.Buff = [];
                            if (options.bytes !== Array)
                                object.Buff = $util.newBuffer(object.Buff);
                        }
                    if (message.Buff != null && message.hasOwnProperty("Buff"))
                        object.Buff = options.bytes === String ? $util.base64.encode(message.Buff, 0, message.Buff.length) : options.bytes === Array ? Array.prototype.slice.call(message.Buff) : message.Buff;
                    return object;
                };

                /**
                 * Converts this BitappMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.BitappMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BitappMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BitappMsg;
            })();

            ImMsgBody.OpenQqData = (function() {

                /**
                 * Properties of an OpenQqData.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IOpenQqData
                 * @property {Uint8Array|null} [CarQqData] OpenQqData CarQqData
                 */

                /**
                 * Constructs a new OpenQqData.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an OpenQqData.
                 * @implements IOpenQqData
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IOpenQqData=} [properties] Properties to set
                 */
                function OpenQqData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OpenQqData CarQqData.
                 * @member {Uint8Array} CarQqData
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @instance
                 */
                OpenQqData.prototype.CarQqData = $util.newBuffer([]);

                /**
                 * Creates a new OpenQqData instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IOpenQqData=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.OpenQqData} OpenQqData instance
                 */
                OpenQqData.create = function create(properties) {
                    return new OpenQqData(properties);
                };

                /**
                 * Encodes the specified OpenQqData message. Does not implicitly {@link Msg.MsgField.ImMsgBody.OpenQqData.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IOpenQqData} message OpenQqData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenQqData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.CarQqData != null && Object.hasOwnProperty.call(message, "CarQqData"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.CarQqData);
                    return writer;
                };

                /**
                 * Encodes the specified OpenQqData message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.OpenQqData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IOpenQqData} message OpenQqData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenQqData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OpenQqData message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.OpenQqData} OpenQqData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenQqData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.OpenQqData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.CarQqData = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OpenQqData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.OpenQqData} OpenQqData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenQqData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OpenQqData message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OpenQqData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.CarQqData != null && message.hasOwnProperty("CarQqData"))
                        if (!(message.CarQqData && typeof message.CarQqData.length === "number" || $util.isString(message.CarQqData)))
                            return "CarQqData: buffer expected";
                    return null;
                };

                /**
                 * Creates an OpenQqData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.OpenQqData} OpenQqData
                 */
                OpenQqData.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.OpenQqData)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.OpenQqData();
                    if (object.CarQqData != null)
                        if (typeof object.CarQqData === "string")
                            $util.base64.decode(object.CarQqData, message.CarQqData = $util.newBuffer($util.base64.length(object.CarQqData)), 0);
                        else if (object.CarQqData.length)
                            message.CarQqData = object.CarQqData;
                    return message;
                };

                /**
                 * Creates a plain object from an OpenQqData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.OpenQqData} message OpenQqData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OpenQqData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.CarQqData = "";
                        else {
                            object.CarQqData = [];
                            if (options.bytes !== Array)
                                object.CarQqData = $util.newBuffer(object.CarQqData);
                        }
                    if (message.CarQqData != null && message.hasOwnProperty("CarQqData"))
                        object.CarQqData = options.bytes === String ? $util.base64.encode(message.CarQqData, 0, message.CarQqData.length) : options.bytes === Array ? Array.prototype.slice.call(message.CarQqData) : message.CarQqData;
                    return object;
                };

                /**
                 * Converts this OpenQqData to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.OpenQqData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OpenQqData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return OpenQqData;
            })();

            ImMsgBody.ApolloMsg = (function() {

                /**
                 * Properties of an ApolloMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IApolloMsg
                 * @property {number|null} [Actionid] ApolloMsg Actionid
                 * @property {Uint8Array|null} [Actionname] ApolloMsg Actionname
                 * @property {Uint8Array|null} [Actiontext] ApolloMsg Actiontext
                 * @property {number|null} [Flag] ApolloMsg Flag
                 * @property {number|null} [Peeruin] ApolloMsg Peeruin
                 * @property {number|null} [Senderts] ApolloMsg Senderts
                 * @property {number|null} [Peerts] ApolloMsg Peerts
                 * @property {number|null} [Int32senderstatus] ApolloMsg Int32senderstatus
                 * @property {number|null} [Int32peerstatus] ApolloMsg Int32peerstatus
                 * @property {number|null} [Diytextid] ApolloMsg Diytextid
                 * @property {Uint8Array|null} [Diytextcontent] ApolloMsg Diytextcontent
                 * @property {Uint8Array|null} [Inputtext] ApolloMsg Inputtext
                 * @property {Uint8Array|null} [Pbreserve] ApolloMsg Pbreserve
                 */

                /**
                 * Constructs a new ApolloMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an ApolloMsg.
                 * @implements IApolloMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IApolloMsg=} [properties] Properties to set
                 */
                function ApolloMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ApolloMsg Actionid.
                 * @member {number} Actionid
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Actionid = 0;

                /**
                 * ApolloMsg Actionname.
                 * @member {Uint8Array} Actionname
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Actionname = $util.newBuffer([]);

                /**
                 * ApolloMsg Actiontext.
                 * @member {Uint8Array} Actiontext
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Actiontext = $util.newBuffer([]);

                /**
                 * ApolloMsg Flag.
                 * @member {number} Flag
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Flag = 0;

                /**
                 * ApolloMsg Peeruin.
                 * @member {number} Peeruin
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Peeruin = 0;

                /**
                 * ApolloMsg Senderts.
                 * @member {number} Senderts
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Senderts = 0;

                /**
                 * ApolloMsg Peerts.
                 * @member {number} Peerts
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Peerts = 0;

                /**
                 * ApolloMsg Int32senderstatus.
                 * @member {number} Int32senderstatus
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Int32senderstatus = 0;

                /**
                 * ApolloMsg Int32peerstatus.
                 * @member {number} Int32peerstatus
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Int32peerstatus = 0;

                /**
                 * ApolloMsg Diytextid.
                 * @member {number} Diytextid
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Diytextid = 0;

                /**
                 * ApolloMsg Diytextcontent.
                 * @member {Uint8Array} Diytextcontent
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Diytextcontent = $util.newBuffer([]);

                /**
                 * ApolloMsg Inputtext.
                 * @member {Uint8Array} Inputtext
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Inputtext = $util.newBuffer([]);

                /**
                 * ApolloMsg Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 */
                ApolloMsg.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * Creates a new ApolloMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IApolloMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.ApolloMsg} ApolloMsg instance
                 */
                ApolloMsg.create = function create(properties) {
                    return new ApolloMsg(properties);
                };

                /**
                 * Encodes the specified ApolloMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.ApolloMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IApolloMsg} message ApolloMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApolloMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Actionid != null && Object.hasOwnProperty.call(message, "Actionid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Actionid);
                    if (message.Actionname != null && Object.hasOwnProperty.call(message, "Actionname"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Actionname);
                    if (message.Actiontext != null && Object.hasOwnProperty.call(message, "Actiontext"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Actiontext);
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Flag);
                    if (message.Peeruin != null && Object.hasOwnProperty.call(message, "Peeruin"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Peeruin);
                    if (message.Senderts != null && Object.hasOwnProperty.call(message, "Senderts"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Senderts);
                    if (message.Peerts != null && Object.hasOwnProperty.call(message, "Peerts"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Peerts);
                    if (message.Int32senderstatus != null && Object.hasOwnProperty.call(message, "Int32senderstatus"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Int32senderstatus);
                    if (message.Int32peerstatus != null && Object.hasOwnProperty.call(message, "Int32peerstatus"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Int32peerstatus);
                    if (message.Diytextid != null && Object.hasOwnProperty.call(message, "Diytextid"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Diytextid);
                    if (message.Diytextcontent != null && Object.hasOwnProperty.call(message, "Diytextcontent"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Diytextcontent);
                    if (message.Inputtext != null && Object.hasOwnProperty.call(message, "Inputtext"))
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.Inputtext);
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.Pbreserve);
                    return writer;
                };

                /**
                 * Encodes the specified ApolloMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.ApolloMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IApolloMsg} message ApolloMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApolloMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ApolloMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.ApolloMsg} ApolloMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApolloMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.ApolloMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Actionid = reader.int32();
                            break;
                        case 2:
                            message.Actionname = reader.bytes();
                            break;
                        case 3:
                            message.Actiontext = reader.bytes();
                            break;
                        case 4:
                            message.Flag = reader.int32();
                            break;
                        case 5:
                            message.Peeruin = reader.int32();
                            break;
                        case 6:
                            message.Senderts = reader.int32();
                            break;
                        case 7:
                            message.Peerts = reader.int32();
                            break;
                        case 8:
                            message.Int32senderstatus = reader.int32();
                            break;
                        case 9:
                            message.Int32peerstatus = reader.int32();
                            break;
                        case 10:
                            message.Diytextid = reader.int32();
                            break;
                        case 11:
                            message.Diytextcontent = reader.bytes();
                            break;
                        case 12:
                            message.Inputtext = reader.bytes();
                            break;
                        case 13:
                            message.Pbreserve = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ApolloMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.ApolloMsg} ApolloMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApolloMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ApolloMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ApolloMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Actionid != null && message.hasOwnProperty("Actionid"))
                        if (!$util.isInteger(message.Actionid))
                            return "Actionid: integer expected";
                    if (message.Actionname != null && message.hasOwnProperty("Actionname"))
                        if (!(message.Actionname && typeof message.Actionname.length === "number" || $util.isString(message.Actionname)))
                            return "Actionname: buffer expected";
                    if (message.Actiontext != null && message.hasOwnProperty("Actiontext"))
                        if (!(message.Actiontext && typeof message.Actiontext.length === "number" || $util.isString(message.Actiontext)))
                            return "Actiontext: buffer expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!$util.isInteger(message.Flag))
                            return "Flag: integer expected";
                    if (message.Peeruin != null && message.hasOwnProperty("Peeruin"))
                        if (!$util.isInteger(message.Peeruin))
                            return "Peeruin: integer expected";
                    if (message.Senderts != null && message.hasOwnProperty("Senderts"))
                        if (!$util.isInteger(message.Senderts))
                            return "Senderts: integer expected";
                    if (message.Peerts != null && message.hasOwnProperty("Peerts"))
                        if (!$util.isInteger(message.Peerts))
                            return "Peerts: integer expected";
                    if (message.Int32senderstatus != null && message.hasOwnProperty("Int32senderstatus"))
                        if (!$util.isInteger(message.Int32senderstatus))
                            return "Int32senderstatus: integer expected";
                    if (message.Int32peerstatus != null && message.hasOwnProperty("Int32peerstatus"))
                        if (!$util.isInteger(message.Int32peerstatus))
                            return "Int32peerstatus: integer expected";
                    if (message.Diytextid != null && message.hasOwnProperty("Diytextid"))
                        if (!$util.isInteger(message.Diytextid))
                            return "Diytextid: integer expected";
                    if (message.Diytextcontent != null && message.hasOwnProperty("Diytextcontent"))
                        if (!(message.Diytextcontent && typeof message.Diytextcontent.length === "number" || $util.isString(message.Diytextcontent)))
                            return "Diytextcontent: buffer expected";
                    if (message.Inputtext != null && message.hasOwnProperty("Inputtext"))
                        if (!(message.Inputtext && typeof message.Inputtext.length === "number" || $util.isString(message.Inputtext)))
                            return "Inputtext: buffer expected";
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    return null;
                };

                /**
                 * Creates an ApolloMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.ApolloMsg} ApolloMsg
                 */
                ApolloMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.ApolloMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.ApolloMsg();
                    if (object.Actionid != null)
                        message.Actionid = object.Actionid | 0;
                    if (object.Actionname != null)
                        if (typeof object.Actionname === "string")
                            $util.base64.decode(object.Actionname, message.Actionname = $util.newBuffer($util.base64.length(object.Actionname)), 0);
                        else if (object.Actionname.length)
                            message.Actionname = object.Actionname;
                    if (object.Actiontext != null)
                        if (typeof object.Actiontext === "string")
                            $util.base64.decode(object.Actiontext, message.Actiontext = $util.newBuffer($util.base64.length(object.Actiontext)), 0);
                        else if (object.Actiontext.length)
                            message.Actiontext = object.Actiontext;
                    if (object.Flag != null)
                        message.Flag = object.Flag | 0;
                    if (object.Peeruin != null)
                        message.Peeruin = object.Peeruin | 0;
                    if (object.Senderts != null)
                        message.Senderts = object.Senderts | 0;
                    if (object.Peerts != null)
                        message.Peerts = object.Peerts | 0;
                    if (object.Int32senderstatus != null)
                        message.Int32senderstatus = object.Int32senderstatus | 0;
                    if (object.Int32peerstatus != null)
                        message.Int32peerstatus = object.Int32peerstatus | 0;
                    if (object.Diytextid != null)
                        message.Diytextid = object.Diytextid | 0;
                    if (object.Diytextcontent != null)
                        if (typeof object.Diytextcontent === "string")
                            $util.base64.decode(object.Diytextcontent, message.Diytextcontent = $util.newBuffer($util.base64.length(object.Diytextcontent)), 0);
                        else if (object.Diytextcontent.length)
                            message.Diytextcontent = object.Diytextcontent;
                    if (object.Inputtext != null)
                        if (typeof object.Inputtext === "string")
                            $util.base64.decode(object.Inputtext, message.Inputtext = $util.newBuffer($util.base64.length(object.Inputtext)), 0);
                        else if (object.Inputtext.length)
                            message.Inputtext = object.Inputtext;
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    return message;
                };

                /**
                 * Creates a plain object from an ApolloMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ApolloMsg} message ApolloMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ApolloMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Actionid = 0;
                        if (options.bytes === String)
                            object.Actionname = "";
                        else {
                            object.Actionname = [];
                            if (options.bytes !== Array)
                                object.Actionname = $util.newBuffer(object.Actionname);
                        }
                        if (options.bytes === String)
                            object.Actiontext = "";
                        else {
                            object.Actiontext = [];
                            if (options.bytes !== Array)
                                object.Actiontext = $util.newBuffer(object.Actiontext);
                        }
                        object.Flag = 0;
                        object.Peeruin = 0;
                        object.Senderts = 0;
                        object.Peerts = 0;
                        object.Int32senderstatus = 0;
                        object.Int32peerstatus = 0;
                        object.Diytextid = 0;
                        if (options.bytes === String)
                            object.Diytextcontent = "";
                        else {
                            object.Diytextcontent = [];
                            if (options.bytes !== Array)
                                object.Diytextcontent = $util.newBuffer(object.Diytextcontent);
                        }
                        if (options.bytes === String)
                            object.Inputtext = "";
                        else {
                            object.Inputtext = [];
                            if (options.bytes !== Array)
                                object.Inputtext = $util.newBuffer(object.Inputtext);
                        }
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                    }
                    if (message.Actionid != null && message.hasOwnProperty("Actionid"))
                        object.Actionid = message.Actionid;
                    if (message.Actionname != null && message.hasOwnProperty("Actionname"))
                        object.Actionname = options.bytes === String ? $util.base64.encode(message.Actionname, 0, message.Actionname.length) : options.bytes === Array ? Array.prototype.slice.call(message.Actionname) : message.Actionname;
                    if (message.Actiontext != null && message.hasOwnProperty("Actiontext"))
                        object.Actiontext = options.bytes === String ? $util.base64.encode(message.Actiontext, 0, message.Actiontext.length) : options.bytes === Array ? Array.prototype.slice.call(message.Actiontext) : message.Actiontext;
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = message.Flag;
                    if (message.Peeruin != null && message.hasOwnProperty("Peeruin"))
                        object.Peeruin = message.Peeruin;
                    if (message.Senderts != null && message.hasOwnProperty("Senderts"))
                        object.Senderts = message.Senderts;
                    if (message.Peerts != null && message.hasOwnProperty("Peerts"))
                        object.Peerts = message.Peerts;
                    if (message.Int32senderstatus != null && message.hasOwnProperty("Int32senderstatus"))
                        object.Int32senderstatus = message.Int32senderstatus;
                    if (message.Int32peerstatus != null && message.hasOwnProperty("Int32peerstatus"))
                        object.Int32peerstatus = message.Int32peerstatus;
                    if (message.Diytextid != null && message.hasOwnProperty("Diytextid"))
                        object.Diytextid = message.Diytextid;
                    if (message.Diytextcontent != null && message.hasOwnProperty("Diytextcontent"))
                        object.Diytextcontent = options.bytes === String ? $util.base64.encode(message.Diytextcontent, 0, message.Diytextcontent.length) : options.bytes === Array ? Array.prototype.slice.call(message.Diytextcontent) : message.Diytextcontent;
                    if (message.Inputtext != null && message.hasOwnProperty("Inputtext"))
                        object.Inputtext = options.bytes === String ? $util.base64.encode(message.Inputtext, 0, message.Inputtext.length) : options.bytes === Array ? Array.prototype.slice.call(message.Inputtext) : message.Inputtext;
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    return object;
                };

                /**
                 * Converts this ApolloMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.ApolloMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ApolloMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ApolloMsg;
            })();

            ImMsgBody.GroupPubAccInfo = (function() {

                /**
                 * Properties of a GroupPubAccInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IGroupPubAccInfo
                 * @property {number|Long|null} [PubAccount] GroupPubAccInfo PubAccount
                 */

                /**
                 * Constructs a new GroupPubAccInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a GroupPubAccInfo.
                 * @implements IGroupPubAccInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IGroupPubAccInfo=} [properties] Properties to set
                 */
                function GroupPubAccInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GroupPubAccInfo PubAccount.
                 * @member {number|Long} PubAccount
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @instance
                 */
                GroupPubAccInfo.prototype.PubAccount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new GroupPubAccInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupPubAccInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.GroupPubAccInfo} GroupPubAccInfo instance
                 */
                GroupPubAccInfo.create = function create(properties) {
                    return new GroupPubAccInfo(properties);
                };

                /**
                 * Encodes the specified GroupPubAccInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupPubAccInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupPubAccInfo} message GroupPubAccInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupPubAccInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.PubAccount != null && Object.hasOwnProperty.call(message, "PubAccount"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.PubAccount);
                    return writer;
                };

                /**
                 * Encodes the specified GroupPubAccInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupPubAccInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupPubAccInfo} message GroupPubAccInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupPubAccInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GroupPubAccInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.GroupPubAccInfo} GroupPubAccInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupPubAccInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.PubAccount = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GroupPubAccInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.GroupPubAccInfo} GroupPubAccInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupPubAccInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GroupPubAccInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GroupPubAccInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.PubAccount != null && message.hasOwnProperty("PubAccount"))
                        if (!$util.isInteger(message.PubAccount) && !(message.PubAccount && $util.isInteger(message.PubAccount.low) && $util.isInteger(message.PubAccount.high)))
                            return "PubAccount: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a GroupPubAccInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.GroupPubAccInfo} GroupPubAccInfo
                 */
                GroupPubAccInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo();
                    if (object.PubAccount != null)
                        if ($util.Long)
                            (message.PubAccount = $util.Long.fromValue(object.PubAccount)).unsigned = false;
                        else if (typeof object.PubAccount === "string")
                            message.PubAccount = parseInt(object.PubAccount, 10);
                        else if (typeof object.PubAccount === "number")
                            message.PubAccount = object.PubAccount;
                        else if (typeof object.PubAccount === "object")
                            message.PubAccount = new $util.LongBits(object.PubAccount.low >>> 0, object.PubAccount.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a GroupPubAccInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.GroupPubAccInfo} message GroupPubAccInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GroupPubAccInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.PubAccount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.PubAccount = options.longs === String ? "0" : 0;
                    if (message.PubAccount != null && message.hasOwnProperty("PubAccount"))
                        if (typeof message.PubAccount === "number")
                            object.PubAccount = options.longs === String ? String(message.PubAccount) : message.PubAccount;
                        else
                            object.PubAccount = options.longs === String ? $util.Long.prototype.toString.call(message.PubAccount) : options.longs === Number ? new $util.LongBits(message.PubAccount.low >>> 0, message.PubAccount.high >>> 0).toNumber() : message.PubAccount;
                    return object;
                };

                /**
                 * Converts this GroupPubAccInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.GroupPubAccInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GroupPubAccInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GroupPubAccInfo;
            })();

            ImMsgBody.BlessMsg = (function() {

                /**
                 * Properties of a BlessMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IBlessMsg
                 * @property {number|null} [Type] BlessMsg Type
                 * @property {number|null} [ExFlag] BlessMsg ExFlag
                 */

                /**
                 * Constructs a new BlessMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a BlessMsg.
                 * @implements IBlessMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IBlessMsg=} [properties] Properties to set
                 */
                function BlessMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BlessMsg Type.
                 * @member {number} Type
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @instance
                 */
                BlessMsg.prototype.Type = 0;

                /**
                 * BlessMsg ExFlag.
                 * @member {number} ExFlag
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @instance
                 */
                BlessMsg.prototype.ExFlag = 0;

                /**
                 * Creates a new BlessMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBlessMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.BlessMsg} BlessMsg instance
                 */
                BlessMsg.create = function create(properties) {
                    return new BlessMsg(properties);
                };

                /**
                 * Encodes the specified BlessMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.BlessMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBlessMsg} message BlessMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlessMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
                    if (message.ExFlag != null && Object.hasOwnProperty.call(message, "ExFlag"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ExFlag);
                    return writer;
                };

                /**
                 * Encodes the specified BlessMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.BlessMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IBlessMsg} message BlessMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlessMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BlessMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.BlessMsg} BlessMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlessMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.BlessMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Type = reader.int32();
                            break;
                        case 2:
                            message.ExFlag = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BlessMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.BlessMsg} BlessMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlessMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BlessMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlessMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        if (!$util.isInteger(message.Type))
                            return "Type: integer expected";
                    if (message.ExFlag != null && message.hasOwnProperty("ExFlag"))
                        if (!$util.isInteger(message.ExFlag))
                            return "ExFlag: integer expected";
                    return null;
                };

                /**
                 * Creates a BlessMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.BlessMsg} BlessMsg
                 */
                BlessMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.BlessMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.BlessMsg();
                    if (object.Type != null)
                        message.Type = object.Type | 0;
                    if (object.ExFlag != null)
                        message.ExFlag = object.ExFlag | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a BlessMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.BlessMsg} message BlessMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BlessMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Type = 0;
                        object.ExFlag = 0;
                    }
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    if (message.ExFlag != null && message.hasOwnProperty("ExFlag"))
                        object.ExFlag = message.ExFlag;
                    return object;
                };

                /**
                 * Converts this BlessMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.BlessMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BlessMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BlessMsg;
            })();

            ImMsgBody.SrcMsg = (function() {

                /**
                 * Properties of a SrcMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ISrcMsg
                 * @property {Array.<number>|null} [Origseqs] SrcMsg Origseqs
                 * @property {number|Long|null} [Senderuin] SrcMsg Senderuin
                 * @property {number|null} [Time] SrcMsg Time
                 * @property {number|null} [Flag] SrcMsg Flag
                 * @property {Array.<Msg.MsgField.ImMsgBody.IElem>|null} [Elems] SrcMsg Elems
                 * @property {number|null} [Type] SrcMsg Type
                 * @property {Uint8Array|null} [Richmsg] SrcMsg Richmsg
                 * @property {Uint8Array|null} [Pbreserve] SrcMsg Pbreserve
                 * @property {Uint8Array|null} [Srcmsg] SrcMsg Srcmsg
                 * @property {number|Long|null} [Touin] SrcMsg Touin
                 * @property {Uint8Array|null} [Troopname] SrcMsg Troopname
                 */

                /**
                 * Constructs a new SrcMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a SrcMsg.
                 * @implements ISrcMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ISrcMsg=} [properties] Properties to set
                 */
                function SrcMsg(properties) {
                    this.Origseqs = [];
                    this.Elems = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SrcMsg Origseqs.
                 * @member {Array.<number>} Origseqs
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Origseqs = $util.emptyArray;

                /**
                 * SrcMsg Senderuin.
                 * @member {number|Long} Senderuin
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Senderuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SrcMsg Time.
                 * @member {number} Time
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Time = 0;

                /**
                 * SrcMsg Flag.
                 * @member {number} Flag
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Flag = 0;

                /**
                 * SrcMsg Elems.
                 * @member {Array.<Msg.MsgField.ImMsgBody.IElem>} Elems
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Elems = $util.emptyArray;

                /**
                 * SrcMsg Type.
                 * @member {number} Type
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Type = 0;

                /**
                 * SrcMsg Richmsg.
                 * @member {Uint8Array} Richmsg
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Richmsg = $util.newBuffer([]);

                /**
                 * SrcMsg Pbreserve.
                 * @member {Uint8Array} Pbreserve
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Pbreserve = $util.newBuffer([]);

                /**
                 * SrcMsg Srcmsg.
                 * @member {Uint8Array} Srcmsg
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Srcmsg = $util.newBuffer([]);

                /**
                 * SrcMsg Touin.
                 * @member {number|Long} Touin
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SrcMsg Troopname.
                 * @member {Uint8Array} Troopname
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 */
                SrcMsg.prototype.Troopname = $util.newBuffer([]);

                /**
                 * Creates a new SrcMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISrcMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.SrcMsg} SrcMsg instance
                 */
                SrcMsg.create = function create(properties) {
                    return new SrcMsg(properties);
                };

                /**
                 * Encodes the specified SrcMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.SrcMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISrcMsg} message SrcMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SrcMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Origseqs != null && message.Origseqs.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.Origseqs.length; ++i)
                            writer.int32(message.Origseqs[i]);
                        writer.ldelim();
                    }
                    if (message.Senderuin != null && Object.hasOwnProperty.call(message, "Senderuin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Senderuin);
                    if (message.Time != null && Object.hasOwnProperty.call(message, "Time"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Time);
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Flag);
                    if (message.Elems != null && message.Elems.length)
                        for (var i = 0; i < message.Elems.length; ++i)
                            $root.Msg.MsgField.ImMsgBody.Elem.encode(message.Elems[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Type);
                    if (message.Richmsg != null && Object.hasOwnProperty.call(message, "Richmsg"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Richmsg);
                    if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Pbreserve);
                    if (message.Srcmsg != null && Object.hasOwnProperty.call(message, "Srcmsg"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.Srcmsg);
                    if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int64(message.Touin);
                    if (message.Troopname != null && Object.hasOwnProperty.call(message, "Troopname"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Troopname);
                    return writer;
                };

                /**
                 * Encodes the specified SrcMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.SrcMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ISrcMsg} message SrcMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SrcMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SrcMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.SrcMsg} SrcMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SrcMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.SrcMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.Origseqs && message.Origseqs.length))
                                message.Origseqs = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.Origseqs.push(reader.int32());
                            } else
                                message.Origseqs.push(reader.int32());
                            break;
                        case 2:
                            message.Senderuin = reader.int64();
                            break;
                        case 3:
                            message.Time = reader.int32();
                            break;
                        case 4:
                            message.Flag = reader.int32();
                            break;
                        case 5:
                            if (!(message.Elems && message.Elems.length))
                                message.Elems = [];
                            message.Elems.push($root.Msg.MsgField.ImMsgBody.Elem.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.Type = reader.int32();
                            break;
                        case 7:
                            message.Richmsg = reader.bytes();
                            break;
                        case 8:
                            message.Pbreserve = reader.bytes();
                            break;
                        case 9:
                            message.Srcmsg = reader.bytes();
                            break;
                        case 10:
                            message.Touin = reader.int64();
                            break;
                        case 11:
                            message.Troopname = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SrcMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.SrcMsg} SrcMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SrcMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SrcMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SrcMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Origseqs != null && message.hasOwnProperty("Origseqs")) {
                        if (!Array.isArray(message.Origseqs))
                            return "Origseqs: array expected";
                        for (var i = 0; i < message.Origseqs.length; ++i)
                            if (!$util.isInteger(message.Origseqs[i]))
                                return "Origseqs: integer[] expected";
                    }
                    if (message.Senderuin != null && message.hasOwnProperty("Senderuin"))
                        if (!$util.isInteger(message.Senderuin) && !(message.Senderuin && $util.isInteger(message.Senderuin.low) && $util.isInteger(message.Senderuin.high)))
                            return "Senderuin: integer|Long expected";
                    if (message.Time != null && message.hasOwnProperty("Time"))
                        if (!$util.isInteger(message.Time))
                            return "Time: integer expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!$util.isInteger(message.Flag))
                            return "Flag: integer expected";
                    if (message.Elems != null && message.hasOwnProperty("Elems")) {
                        if (!Array.isArray(message.Elems))
                            return "Elems: array expected";
                        for (var i = 0; i < message.Elems.length; ++i) {
                            var error = $root.Msg.MsgField.ImMsgBody.Elem.verify(message.Elems[i]);
                            if (error)
                                return "Elems." + error;
                        }
                    }
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        if (!$util.isInteger(message.Type))
                            return "Type: integer expected";
                    if (message.Richmsg != null && message.hasOwnProperty("Richmsg"))
                        if (!(message.Richmsg && typeof message.Richmsg.length === "number" || $util.isString(message.Richmsg)))
                            return "Richmsg: buffer expected";
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                            return "Pbreserve: buffer expected";
                    if (message.Srcmsg != null && message.hasOwnProperty("Srcmsg"))
                        if (!(message.Srcmsg && typeof message.Srcmsg.length === "number" || $util.isString(message.Srcmsg)))
                            return "Srcmsg: buffer expected";
                    if (message.Touin != null && message.hasOwnProperty("Touin"))
                        if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                            return "Touin: integer|Long expected";
                    if (message.Troopname != null && message.hasOwnProperty("Troopname"))
                        if (!(message.Troopname && typeof message.Troopname.length === "number" || $util.isString(message.Troopname)))
                            return "Troopname: buffer expected";
                    return null;
                };

                /**
                 * Creates a SrcMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.SrcMsg} SrcMsg
                 */
                SrcMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.SrcMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.SrcMsg();
                    if (object.Origseqs) {
                        if (!Array.isArray(object.Origseqs))
                            throw TypeError(".Msg.MsgField.ImMsgBody.SrcMsg.Origseqs: array expected");
                        message.Origseqs = [];
                        for (var i = 0; i < object.Origseqs.length; ++i)
                            message.Origseqs[i] = object.Origseqs[i] | 0;
                    }
                    if (object.Senderuin != null)
                        if ($util.Long)
                            (message.Senderuin = $util.Long.fromValue(object.Senderuin)).unsigned = false;
                        else if (typeof object.Senderuin === "string")
                            message.Senderuin = parseInt(object.Senderuin, 10);
                        else if (typeof object.Senderuin === "number")
                            message.Senderuin = object.Senderuin;
                        else if (typeof object.Senderuin === "object")
                            message.Senderuin = new $util.LongBits(object.Senderuin.low >>> 0, object.Senderuin.high >>> 0).toNumber();
                    if (object.Time != null)
                        message.Time = object.Time | 0;
                    if (object.Flag != null)
                        message.Flag = object.Flag | 0;
                    if (object.Elems) {
                        if (!Array.isArray(object.Elems))
                            throw TypeError(".Msg.MsgField.ImMsgBody.SrcMsg.Elems: array expected");
                        message.Elems = [];
                        for (var i = 0; i < object.Elems.length; ++i) {
                            if (typeof object.Elems[i] !== "object")
                                throw TypeError(".Msg.MsgField.ImMsgBody.SrcMsg.Elems: object expected");
                            message.Elems[i] = $root.Msg.MsgField.ImMsgBody.Elem.fromObject(object.Elems[i]);
                        }
                    }
                    if (object.Type != null)
                        message.Type = object.Type | 0;
                    if (object.Richmsg != null)
                        if (typeof object.Richmsg === "string")
                            $util.base64.decode(object.Richmsg, message.Richmsg = $util.newBuffer($util.base64.length(object.Richmsg)), 0);
                        else if (object.Richmsg.length)
                            message.Richmsg = object.Richmsg;
                    if (object.Pbreserve != null)
                        if (typeof object.Pbreserve === "string")
                            $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                        else if (object.Pbreserve.length)
                            message.Pbreserve = object.Pbreserve;
                    if (object.Srcmsg != null)
                        if (typeof object.Srcmsg === "string")
                            $util.base64.decode(object.Srcmsg, message.Srcmsg = $util.newBuffer($util.base64.length(object.Srcmsg)), 0);
                        else if (object.Srcmsg.length)
                            message.Srcmsg = object.Srcmsg;
                    if (object.Touin != null)
                        if ($util.Long)
                            (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                        else if (typeof object.Touin === "string")
                            message.Touin = parseInt(object.Touin, 10);
                        else if (typeof object.Touin === "number")
                            message.Touin = object.Touin;
                        else if (typeof object.Touin === "object")
                            message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                    if (object.Troopname != null)
                        if (typeof object.Troopname === "string")
                            $util.base64.decode(object.Troopname, message.Troopname = $util.newBuffer($util.base64.length(object.Troopname)), 0);
                        else if (object.Troopname.length)
                            message.Troopname = object.Troopname;
                    return message;
                };

                /**
                 * Creates a plain object from a SrcMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.SrcMsg} message SrcMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SrcMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.Origseqs = [];
                        object.Elems = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Senderuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Senderuin = options.longs === String ? "0" : 0;
                        object.Time = 0;
                        object.Flag = 0;
                        object.Type = 0;
                        if (options.bytes === String)
                            object.Richmsg = "";
                        else {
                            object.Richmsg = [];
                            if (options.bytes !== Array)
                                object.Richmsg = $util.newBuffer(object.Richmsg);
                        }
                        if (options.bytes === String)
                            object.Pbreserve = "";
                        else {
                            object.Pbreserve = [];
                            if (options.bytes !== Array)
                                object.Pbreserve = $util.newBuffer(object.Pbreserve);
                        }
                        if (options.bytes === String)
                            object.Srcmsg = "";
                        else {
                            object.Srcmsg = [];
                            if (options.bytes !== Array)
                                object.Srcmsg = $util.newBuffer(object.Srcmsg);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Touin = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.Troopname = "";
                        else {
                            object.Troopname = [];
                            if (options.bytes !== Array)
                                object.Troopname = $util.newBuffer(object.Troopname);
                        }
                    }
                    if (message.Origseqs && message.Origseqs.length) {
                        object.Origseqs = [];
                        for (var j = 0; j < message.Origseqs.length; ++j)
                            object.Origseqs[j] = message.Origseqs[j];
                    }
                    if (message.Senderuin != null && message.hasOwnProperty("Senderuin"))
                        if (typeof message.Senderuin === "number")
                            object.Senderuin = options.longs === String ? String(message.Senderuin) : message.Senderuin;
                        else
                            object.Senderuin = options.longs === String ? $util.Long.prototype.toString.call(message.Senderuin) : options.longs === Number ? new $util.LongBits(message.Senderuin.low >>> 0, message.Senderuin.high >>> 0).toNumber() : message.Senderuin;
                    if (message.Time != null && message.hasOwnProperty("Time"))
                        object.Time = message.Time;
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = message.Flag;
                    if (message.Elems && message.Elems.length) {
                        object.Elems = [];
                        for (var j = 0; j < message.Elems.length; ++j)
                            object.Elems[j] = $root.Msg.MsgField.ImMsgBody.Elem.toObject(message.Elems[j], options);
                    }
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    if (message.Richmsg != null && message.hasOwnProperty("Richmsg"))
                        object.Richmsg = options.bytes === String ? $util.base64.encode(message.Richmsg, 0, message.Richmsg.length) : options.bytes === Array ? Array.prototype.slice.call(message.Richmsg) : message.Richmsg;
                    if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                        object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                    if (message.Srcmsg != null && message.hasOwnProperty("Srcmsg"))
                        object.Srcmsg = options.bytes === String ? $util.base64.encode(message.Srcmsg, 0, message.Srcmsg.length) : options.bytes === Array ? Array.prototype.slice.call(message.Srcmsg) : message.Srcmsg;
                    if (message.Touin != null && message.hasOwnProperty("Touin"))
                        if (typeof message.Touin === "number")
                            object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                        else
                            object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                    if (message.Troopname != null && message.hasOwnProperty("Troopname"))
                        object.Troopname = options.bytes === String ? $util.base64.encode(message.Troopname, 0, message.Troopname.length) : options.bytes === Array ? Array.prototype.slice.call(message.Troopname) : message.Troopname;
                    return object;
                };

                /**
                 * Converts this SrcMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.SrcMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SrcMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SrcMsg;
            })();

            ImMsgBody.LolaMsg = (function() {

                /**
                 * Properties of a LolaMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ILolaMsg
                 * @property {Uint8Array|null} [Msgresid] LolaMsg Msgresid
                 * @property {Uint8Array|null} [Encodecontent] LolaMsg Encodecontent
                 * @property {Uint8Array|null} [Longmsgurl] LolaMsg Longmsgurl
                 * @property {Uint8Array|null} [Downloadkey] LolaMsg Downloadkey
                 */

                /**
                 * Constructs a new LolaMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a LolaMsg.
                 * @implements ILolaMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ILolaMsg=} [properties] Properties to set
                 */
                function LolaMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LolaMsg Msgresid.
                 * @member {Uint8Array} Msgresid
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @instance
                 */
                LolaMsg.prototype.Msgresid = $util.newBuffer([]);

                /**
                 * LolaMsg Encodecontent.
                 * @member {Uint8Array} Encodecontent
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @instance
                 */
                LolaMsg.prototype.Encodecontent = $util.newBuffer([]);

                /**
                 * LolaMsg Longmsgurl.
                 * @member {Uint8Array} Longmsgurl
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @instance
                 */
                LolaMsg.prototype.Longmsgurl = $util.newBuffer([]);

                /**
                 * LolaMsg Downloadkey.
                 * @member {Uint8Array} Downloadkey
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @instance
                 */
                LolaMsg.prototype.Downloadkey = $util.newBuffer([]);

                /**
                 * Creates a new LolaMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILolaMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.LolaMsg} LolaMsg instance
                 */
                LolaMsg.create = function create(properties) {
                    return new LolaMsg(properties);
                };

                /**
                 * Encodes the specified LolaMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.LolaMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILolaMsg} message LolaMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LolaMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Msgresid != null && Object.hasOwnProperty.call(message, "Msgresid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Msgresid);
                    if (message.Encodecontent != null && Object.hasOwnProperty.call(message, "Encodecontent"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Encodecontent);
                    if (message.Longmsgurl != null && Object.hasOwnProperty.call(message, "Longmsgurl"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Longmsgurl);
                    if (message.Downloadkey != null && Object.hasOwnProperty.call(message, "Downloadkey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Downloadkey);
                    return writer;
                };

                /**
                 * Encodes the specified LolaMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.LolaMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILolaMsg} message LolaMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LolaMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LolaMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.LolaMsg} LolaMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LolaMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.LolaMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Msgresid = reader.bytes();
                            break;
                        case 2:
                            message.Encodecontent = reader.bytes();
                            break;
                        case 3:
                            message.Longmsgurl = reader.bytes();
                            break;
                        case 4:
                            message.Downloadkey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LolaMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.LolaMsg} LolaMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LolaMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LolaMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LolaMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Msgresid != null && message.hasOwnProperty("Msgresid"))
                        if (!(message.Msgresid && typeof message.Msgresid.length === "number" || $util.isString(message.Msgresid)))
                            return "Msgresid: buffer expected";
                    if (message.Encodecontent != null && message.hasOwnProperty("Encodecontent"))
                        if (!(message.Encodecontent && typeof message.Encodecontent.length === "number" || $util.isString(message.Encodecontent)))
                            return "Encodecontent: buffer expected";
                    if (message.Longmsgurl != null && message.hasOwnProperty("Longmsgurl"))
                        if (!(message.Longmsgurl && typeof message.Longmsgurl.length === "number" || $util.isString(message.Longmsgurl)))
                            return "Longmsgurl: buffer expected";
                    if (message.Downloadkey != null && message.hasOwnProperty("Downloadkey"))
                        if (!(message.Downloadkey && typeof message.Downloadkey.length === "number" || $util.isString(message.Downloadkey)))
                            return "Downloadkey: buffer expected";
                    return null;
                };

                /**
                 * Creates a LolaMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.LolaMsg} LolaMsg
                 */
                LolaMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.LolaMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.LolaMsg();
                    if (object.Msgresid != null)
                        if (typeof object.Msgresid === "string")
                            $util.base64.decode(object.Msgresid, message.Msgresid = $util.newBuffer($util.base64.length(object.Msgresid)), 0);
                        else if (object.Msgresid.length)
                            message.Msgresid = object.Msgresid;
                    if (object.Encodecontent != null)
                        if (typeof object.Encodecontent === "string")
                            $util.base64.decode(object.Encodecontent, message.Encodecontent = $util.newBuffer($util.base64.length(object.Encodecontent)), 0);
                        else if (object.Encodecontent.length)
                            message.Encodecontent = object.Encodecontent;
                    if (object.Longmsgurl != null)
                        if (typeof object.Longmsgurl === "string")
                            $util.base64.decode(object.Longmsgurl, message.Longmsgurl = $util.newBuffer($util.base64.length(object.Longmsgurl)), 0);
                        else if (object.Longmsgurl.length)
                            message.Longmsgurl = object.Longmsgurl;
                    if (object.Downloadkey != null)
                        if (typeof object.Downloadkey === "string")
                            $util.base64.decode(object.Downloadkey, message.Downloadkey = $util.newBuffer($util.base64.length(object.Downloadkey)), 0);
                        else if (object.Downloadkey.length)
                            message.Downloadkey = object.Downloadkey;
                    return message;
                };

                /**
                 * Creates a plain object from a LolaMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.LolaMsg} message LolaMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LolaMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Msgresid = "";
                        else {
                            object.Msgresid = [];
                            if (options.bytes !== Array)
                                object.Msgresid = $util.newBuffer(object.Msgresid);
                        }
                        if (options.bytes === String)
                            object.Encodecontent = "";
                        else {
                            object.Encodecontent = [];
                            if (options.bytes !== Array)
                                object.Encodecontent = $util.newBuffer(object.Encodecontent);
                        }
                        if (options.bytes === String)
                            object.Longmsgurl = "";
                        else {
                            object.Longmsgurl = [];
                            if (options.bytes !== Array)
                                object.Longmsgurl = $util.newBuffer(object.Longmsgurl);
                        }
                        if (options.bytes === String)
                            object.Downloadkey = "";
                        else {
                            object.Downloadkey = [];
                            if (options.bytes !== Array)
                                object.Downloadkey = $util.newBuffer(object.Downloadkey);
                        }
                    }
                    if (message.Msgresid != null && message.hasOwnProperty("Msgresid"))
                        object.Msgresid = options.bytes === String ? $util.base64.encode(message.Msgresid, 0, message.Msgresid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Msgresid) : message.Msgresid;
                    if (message.Encodecontent != null && message.hasOwnProperty("Encodecontent"))
                        object.Encodecontent = options.bytes === String ? $util.base64.encode(message.Encodecontent, 0, message.Encodecontent.length) : options.bytes === Array ? Array.prototype.slice.call(message.Encodecontent) : message.Encodecontent;
                    if (message.Longmsgurl != null && message.hasOwnProperty("Longmsgurl"))
                        object.Longmsgurl = options.bytes === String ? $util.base64.encode(message.Longmsgurl, 0, message.Longmsgurl.length) : options.bytes === Array ? Array.prototype.slice.call(message.Longmsgurl) : message.Longmsgurl;
                    if (message.Downloadkey != null && message.hasOwnProperty("Downloadkey"))
                        object.Downloadkey = options.bytes === String ? $util.base64.encode(message.Downloadkey, 0, message.Downloadkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.Downloadkey) : message.Downloadkey;
                    return object;
                };

                /**
                 * Converts this LolaMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.LolaMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LolaMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LolaMsg;
            })();

            ImMsgBody.GroupBusinessMsg = (function() {

                /**
                 * Properties of a GroupBusinessMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IGroupBusinessMsg
                 * @property {number|null} [Flags] GroupBusinessMsg Flags
                 * @property {Uint8Array|null} [Headurl] GroupBusinessMsg Headurl
                 * @property {Uint8Array|null} [Headclkurl] GroupBusinessMsg Headclkurl
                 * @property {Uint8Array|null} [Nick] GroupBusinessMsg Nick
                 * @property {Uint8Array|null} [Nickcolor] GroupBusinessMsg Nickcolor
                 * @property {Uint8Array|null} [Rank] GroupBusinessMsg Rank
                 * @property {Uint8Array|null} [Rankcolor] GroupBusinessMsg Rankcolor
                 * @property {Uint8Array|null} [Rankbgcolor] GroupBusinessMsg Rankbgcolor
                 */

                /**
                 * Constructs a new GroupBusinessMsg.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a GroupBusinessMsg.
                 * @implements IGroupBusinessMsg
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IGroupBusinessMsg=} [properties] Properties to set
                 */
                function GroupBusinessMsg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GroupBusinessMsg Flags.
                 * @member {number} Flags
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Flags = 0;

                /**
                 * GroupBusinessMsg Headurl.
                 * @member {Uint8Array} Headurl
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Headurl = $util.newBuffer([]);

                /**
                 * GroupBusinessMsg Headclkurl.
                 * @member {Uint8Array} Headclkurl
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Headclkurl = $util.newBuffer([]);

                /**
                 * GroupBusinessMsg Nick.
                 * @member {Uint8Array} Nick
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Nick = $util.newBuffer([]);

                /**
                 * GroupBusinessMsg Nickcolor.
                 * @member {Uint8Array} Nickcolor
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Nickcolor = $util.newBuffer([]);

                /**
                 * GroupBusinessMsg Rank.
                 * @member {Uint8Array} Rank
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Rank = $util.newBuffer([]);

                /**
                 * GroupBusinessMsg Rankcolor.
                 * @member {Uint8Array} Rankcolor
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Rankcolor = $util.newBuffer([]);

                /**
                 * GroupBusinessMsg Rankbgcolor.
                 * @member {Uint8Array} Rankbgcolor
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 */
                GroupBusinessMsg.prototype.Rankbgcolor = $util.newBuffer([]);

                /**
                 * Creates a new GroupBusinessMsg instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupBusinessMsg=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.GroupBusinessMsg} GroupBusinessMsg instance
                 */
                GroupBusinessMsg.create = function create(properties) {
                    return new GroupBusinessMsg(properties);
                };

                /**
                 * Encodes the specified GroupBusinessMsg message. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupBusinessMsg.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupBusinessMsg} message GroupBusinessMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupBusinessMsg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Flags != null && Object.hasOwnProperty.call(message, "Flags"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Flags);
                    if (message.Headurl != null && Object.hasOwnProperty.call(message, "Headurl"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Headurl);
                    if (message.Headclkurl != null && Object.hasOwnProperty.call(message, "Headclkurl"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Headclkurl);
                    if (message.Nick != null && Object.hasOwnProperty.call(message, "Nick"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Nick);
                    if (message.Nickcolor != null && Object.hasOwnProperty.call(message, "Nickcolor"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Nickcolor);
                    if (message.Rank != null && Object.hasOwnProperty.call(message, "Rank"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.Rank);
                    if (message.Rankcolor != null && Object.hasOwnProperty.call(message, "Rankcolor"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Rankcolor);
                    if (message.Rankbgcolor != null && Object.hasOwnProperty.call(message, "Rankbgcolor"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Rankbgcolor);
                    return writer;
                };

                /**
                 * Encodes the specified GroupBusinessMsg message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupBusinessMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupBusinessMsg} message GroupBusinessMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupBusinessMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GroupBusinessMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.GroupBusinessMsg} GroupBusinessMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupBusinessMsg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Flags = reader.int32();
                            break;
                        case 2:
                            message.Headurl = reader.bytes();
                            break;
                        case 3:
                            message.Headclkurl = reader.bytes();
                            break;
                        case 4:
                            message.Nick = reader.bytes();
                            break;
                        case 5:
                            message.Nickcolor = reader.bytes();
                            break;
                        case 6:
                            message.Rank = reader.bytes();
                            break;
                        case 7:
                            message.Rankcolor = reader.bytes();
                            break;
                        case 8:
                            message.Rankbgcolor = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GroupBusinessMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.GroupBusinessMsg} GroupBusinessMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupBusinessMsg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GroupBusinessMsg message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GroupBusinessMsg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        if (!$util.isInteger(message.Flags))
                            return "Flags: integer expected";
                    if (message.Headurl != null && message.hasOwnProperty("Headurl"))
                        if (!(message.Headurl && typeof message.Headurl.length === "number" || $util.isString(message.Headurl)))
                            return "Headurl: buffer expected";
                    if (message.Headclkurl != null && message.hasOwnProperty("Headclkurl"))
                        if (!(message.Headclkurl && typeof message.Headclkurl.length === "number" || $util.isString(message.Headclkurl)))
                            return "Headclkurl: buffer expected";
                    if (message.Nick != null && message.hasOwnProperty("Nick"))
                        if (!(message.Nick && typeof message.Nick.length === "number" || $util.isString(message.Nick)))
                            return "Nick: buffer expected";
                    if (message.Nickcolor != null && message.hasOwnProperty("Nickcolor"))
                        if (!(message.Nickcolor && typeof message.Nickcolor.length === "number" || $util.isString(message.Nickcolor)))
                            return "Nickcolor: buffer expected";
                    if (message.Rank != null && message.hasOwnProperty("Rank"))
                        if (!(message.Rank && typeof message.Rank.length === "number" || $util.isString(message.Rank)))
                            return "Rank: buffer expected";
                    if (message.Rankcolor != null && message.hasOwnProperty("Rankcolor"))
                        if (!(message.Rankcolor && typeof message.Rankcolor.length === "number" || $util.isString(message.Rankcolor)))
                            return "Rankcolor: buffer expected";
                    if (message.Rankbgcolor != null && message.hasOwnProperty("Rankbgcolor"))
                        if (!(message.Rankbgcolor && typeof message.Rankbgcolor.length === "number" || $util.isString(message.Rankbgcolor)))
                            return "Rankbgcolor: buffer expected";
                    return null;
                };

                /**
                 * Creates a GroupBusinessMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.GroupBusinessMsg} GroupBusinessMsg
                 */
                GroupBusinessMsg.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg();
                    if (object.Flags != null)
                        message.Flags = object.Flags | 0;
                    if (object.Headurl != null)
                        if (typeof object.Headurl === "string")
                            $util.base64.decode(object.Headurl, message.Headurl = $util.newBuffer($util.base64.length(object.Headurl)), 0);
                        else if (object.Headurl.length)
                            message.Headurl = object.Headurl;
                    if (object.Headclkurl != null)
                        if (typeof object.Headclkurl === "string")
                            $util.base64.decode(object.Headclkurl, message.Headclkurl = $util.newBuffer($util.base64.length(object.Headclkurl)), 0);
                        else if (object.Headclkurl.length)
                            message.Headclkurl = object.Headclkurl;
                    if (object.Nick != null)
                        if (typeof object.Nick === "string")
                            $util.base64.decode(object.Nick, message.Nick = $util.newBuffer($util.base64.length(object.Nick)), 0);
                        else if (object.Nick.length)
                            message.Nick = object.Nick;
                    if (object.Nickcolor != null)
                        if (typeof object.Nickcolor === "string")
                            $util.base64.decode(object.Nickcolor, message.Nickcolor = $util.newBuffer($util.base64.length(object.Nickcolor)), 0);
                        else if (object.Nickcolor.length)
                            message.Nickcolor = object.Nickcolor;
                    if (object.Rank != null)
                        if (typeof object.Rank === "string")
                            $util.base64.decode(object.Rank, message.Rank = $util.newBuffer($util.base64.length(object.Rank)), 0);
                        else if (object.Rank.length)
                            message.Rank = object.Rank;
                    if (object.Rankcolor != null)
                        if (typeof object.Rankcolor === "string")
                            $util.base64.decode(object.Rankcolor, message.Rankcolor = $util.newBuffer($util.base64.length(object.Rankcolor)), 0);
                        else if (object.Rankcolor.length)
                            message.Rankcolor = object.Rankcolor;
                    if (object.Rankbgcolor != null)
                        if (typeof object.Rankbgcolor === "string")
                            $util.base64.decode(object.Rankbgcolor, message.Rankbgcolor = $util.newBuffer($util.base64.length(object.Rankbgcolor)), 0);
                        else if (object.Rankbgcolor.length)
                            message.Rankbgcolor = object.Rankbgcolor;
                    return message;
                };

                /**
                 * Creates a plain object from a GroupBusinessMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.GroupBusinessMsg} message GroupBusinessMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GroupBusinessMsg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Flags = 0;
                        if (options.bytes === String)
                            object.Headurl = "";
                        else {
                            object.Headurl = [];
                            if (options.bytes !== Array)
                                object.Headurl = $util.newBuffer(object.Headurl);
                        }
                        if (options.bytes === String)
                            object.Headclkurl = "";
                        else {
                            object.Headclkurl = [];
                            if (options.bytes !== Array)
                                object.Headclkurl = $util.newBuffer(object.Headclkurl);
                        }
                        if (options.bytes === String)
                            object.Nick = "";
                        else {
                            object.Nick = [];
                            if (options.bytes !== Array)
                                object.Nick = $util.newBuffer(object.Nick);
                        }
                        if (options.bytes === String)
                            object.Nickcolor = "";
                        else {
                            object.Nickcolor = [];
                            if (options.bytes !== Array)
                                object.Nickcolor = $util.newBuffer(object.Nickcolor);
                        }
                        if (options.bytes === String)
                            object.Rank = "";
                        else {
                            object.Rank = [];
                            if (options.bytes !== Array)
                                object.Rank = $util.newBuffer(object.Rank);
                        }
                        if (options.bytes === String)
                            object.Rankcolor = "";
                        else {
                            object.Rankcolor = [];
                            if (options.bytes !== Array)
                                object.Rankcolor = $util.newBuffer(object.Rankcolor);
                        }
                        if (options.bytes === String)
                            object.Rankbgcolor = "";
                        else {
                            object.Rankbgcolor = [];
                            if (options.bytes !== Array)
                                object.Rankbgcolor = $util.newBuffer(object.Rankbgcolor);
                        }
                    }
                    if (message.Flags != null && message.hasOwnProperty("Flags"))
                        object.Flags = message.Flags;
                    if (message.Headurl != null && message.hasOwnProperty("Headurl"))
                        object.Headurl = options.bytes === String ? $util.base64.encode(message.Headurl, 0, message.Headurl.length) : options.bytes === Array ? Array.prototype.slice.call(message.Headurl) : message.Headurl;
                    if (message.Headclkurl != null && message.hasOwnProperty("Headclkurl"))
                        object.Headclkurl = options.bytes === String ? $util.base64.encode(message.Headclkurl, 0, message.Headclkurl.length) : options.bytes === Array ? Array.prototype.slice.call(message.Headclkurl) : message.Headclkurl;
                    if (message.Nick != null && message.hasOwnProperty("Nick"))
                        object.Nick = options.bytes === String ? $util.base64.encode(message.Nick, 0, message.Nick.length) : options.bytes === Array ? Array.prototype.slice.call(message.Nick) : message.Nick;
                    if (message.Nickcolor != null && message.hasOwnProperty("Nickcolor"))
                        object.Nickcolor = options.bytes === String ? $util.base64.encode(message.Nickcolor, 0, message.Nickcolor.length) : options.bytes === Array ? Array.prototype.slice.call(message.Nickcolor) : message.Nickcolor;
                    if (message.Rank != null && message.hasOwnProperty("Rank"))
                        object.Rank = options.bytes === String ? $util.base64.encode(message.Rank, 0, message.Rank.length) : options.bytes === Array ? Array.prototype.slice.call(message.Rank) : message.Rank;
                    if (message.Rankcolor != null && message.hasOwnProperty("Rankcolor"))
                        object.Rankcolor = options.bytes === String ? $util.base64.encode(message.Rankcolor, 0, message.Rankcolor.length) : options.bytes === Array ? Array.prototype.slice.call(message.Rankcolor) : message.Rankcolor;
                    if (message.Rankbgcolor != null && message.hasOwnProperty("Rankbgcolor"))
                        object.Rankbgcolor = options.bytes === String ? $util.base64.encode(message.Rankbgcolor, 0, message.Rankbgcolor.length) : options.bytes === Array ? Array.prototype.slice.call(message.Rankbgcolor) : message.Rankbgcolor;
                    return object;
                };

                /**
                 * Converts this GroupBusinessMsg to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.GroupBusinessMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GroupBusinessMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GroupBusinessMsg;
            })();

            ImMsgBody.MsgWorkflowNotify = (function() {

                /**
                 * Properties of a MsgWorkflowNotify.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IMsgWorkflowNotify
                 * @property {Uint8Array|null} [Extmsg] MsgWorkflowNotify Extmsg
                 * @property {number|Long|null} [Createuin] MsgWorkflowNotify Createuin
                 */

                /**
                 * Constructs a new MsgWorkflowNotify.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a MsgWorkflowNotify.
                 * @implements IMsgWorkflowNotify
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IMsgWorkflowNotify=} [properties] Properties to set
                 */
                function MsgWorkflowNotify(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgWorkflowNotify Extmsg.
                 * @member {Uint8Array} Extmsg
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @instance
                 */
                MsgWorkflowNotify.prototype.Extmsg = $util.newBuffer([]);

                /**
                 * MsgWorkflowNotify Createuin.
                 * @member {number|Long} Createuin
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @instance
                 */
                MsgWorkflowNotify.prototype.Createuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new MsgWorkflowNotify instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMsgWorkflowNotify=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.MsgWorkflowNotify} MsgWorkflowNotify instance
                 */
                MsgWorkflowNotify.create = function create(properties) {
                    return new MsgWorkflowNotify(properties);
                };

                /**
                 * Encodes the specified MsgWorkflowNotify message. Does not implicitly {@link Msg.MsgField.ImMsgBody.MsgWorkflowNotify.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMsgWorkflowNotify} message MsgWorkflowNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWorkflowNotify.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Extmsg != null && Object.hasOwnProperty.call(message, "Extmsg"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Extmsg);
                    if (message.Createuin != null && Object.hasOwnProperty.call(message, "Createuin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Createuin);
                    return writer;
                };

                /**
                 * Encodes the specified MsgWorkflowNotify message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.MsgWorkflowNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMsgWorkflowNotify} message MsgWorkflowNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgWorkflowNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgWorkflowNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.MsgWorkflowNotify} MsgWorkflowNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWorkflowNotify.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Extmsg = reader.bytes();
                            break;
                        case 2:
                            message.Createuin = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgWorkflowNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.MsgWorkflowNotify} MsgWorkflowNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgWorkflowNotify.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgWorkflowNotify message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgWorkflowNotify.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Extmsg != null && message.hasOwnProperty("Extmsg"))
                        if (!(message.Extmsg && typeof message.Extmsg.length === "number" || $util.isString(message.Extmsg)))
                            return "Extmsg: buffer expected";
                    if (message.Createuin != null && message.hasOwnProperty("Createuin"))
                        if (!$util.isInteger(message.Createuin) && !(message.Createuin && $util.isInteger(message.Createuin.low) && $util.isInteger(message.Createuin.high)))
                            return "Createuin: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a MsgWorkflowNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.MsgWorkflowNotify} MsgWorkflowNotify
                 */
                MsgWorkflowNotify.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify();
                    if (object.Extmsg != null)
                        if (typeof object.Extmsg === "string")
                            $util.base64.decode(object.Extmsg, message.Extmsg = $util.newBuffer($util.base64.length(object.Extmsg)), 0);
                        else if (object.Extmsg.length)
                            message.Extmsg = object.Extmsg;
                    if (object.Createuin != null)
                        if ($util.Long)
                            (message.Createuin = $util.Long.fromValue(object.Createuin)).unsigned = false;
                        else if (typeof object.Createuin === "string")
                            message.Createuin = parseInt(object.Createuin, 10);
                        else if (typeof object.Createuin === "number")
                            message.Createuin = object.Createuin;
                        else if (typeof object.Createuin === "object")
                            message.Createuin = new $util.LongBits(object.Createuin.low >>> 0, object.Createuin.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a MsgWorkflowNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.MsgWorkflowNotify} message MsgWorkflowNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgWorkflowNotify.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Extmsg = "";
                        else {
                            object.Extmsg = [];
                            if (options.bytes !== Array)
                                object.Extmsg = $util.newBuffer(object.Extmsg);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Createuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Createuin = options.longs === String ? "0" : 0;
                    }
                    if (message.Extmsg != null && message.hasOwnProperty("Extmsg"))
                        object.Extmsg = options.bytes === String ? $util.base64.encode(message.Extmsg, 0, message.Extmsg.length) : options.bytes === Array ? Array.prototype.slice.call(message.Extmsg) : message.Extmsg;
                    if (message.Createuin != null && message.hasOwnProperty("Createuin"))
                        if (typeof message.Createuin === "number")
                            object.Createuin = options.longs === String ? String(message.Createuin) : message.Createuin;
                        else
                            object.Createuin = options.longs === String ? $util.Long.prototype.toString.call(message.Createuin) : options.longs === Number ? new $util.LongBits(message.Createuin.low >>> 0, message.Createuin.high >>> 0).toNumber() : message.Createuin;
                    return object;
                };

                /**
                 * Converts this MsgWorkflowNotify to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.MsgWorkflowNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgWorkflowNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MsgWorkflowNotify;
            })();

            ImMsgBody.PatElem = (function() {

                /**
                 * Properties of a PatElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IPatElem
                 * @property {number|null} [Pattype] PatElem Pattype
                 * @property {number|null} [Patcount] PatElem Patcount
                 */

                /**
                 * Constructs a new PatElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a PatElem.
                 * @implements IPatElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IPatElem=} [properties] Properties to set
                 */
                function PatElem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PatElem Pattype.
                 * @member {number} Pattype
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @instance
                 */
                PatElem.prototype.Pattype = 0;

                /**
                 * PatElem Patcount.
                 * @member {number} Patcount
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @instance
                 */
                PatElem.prototype.Patcount = 0;

                /**
                 * Creates a new PatElem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPatElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.PatElem} PatElem instance
                 */
                PatElem.create = function create(properties) {
                    return new PatElem(properties);
                };

                /**
                 * Encodes the specified PatElem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.PatElem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPatElem} message PatElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatElem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Pattype != null && Object.hasOwnProperty.call(message, "Pattype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Pattype);
                    if (message.Patcount != null && Object.hasOwnProperty.call(message, "Patcount"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Patcount);
                    return writer;
                };

                /**
                 * Encodes the specified PatElem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.PatElem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IPatElem} message PatElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatElem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PatElem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.PatElem} PatElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatElem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.PatElem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Pattype = reader.int32();
                            break;
                        case 2:
                            message.Patcount = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PatElem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.PatElem} PatElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatElem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PatElem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PatElem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Pattype != null && message.hasOwnProperty("Pattype"))
                        if (!$util.isInteger(message.Pattype))
                            return "Pattype: integer expected";
                    if (message.Patcount != null && message.hasOwnProperty("Patcount"))
                        if (!$util.isInteger(message.Patcount))
                            return "Patcount: integer expected";
                    return null;
                };

                /**
                 * Creates a PatElem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.PatElem} PatElem
                 */
                PatElem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.PatElem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.PatElem();
                    if (object.Pattype != null)
                        message.Pattype = object.Pattype | 0;
                    if (object.Patcount != null)
                        message.Patcount = object.Patcount | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a PatElem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.PatElem} message PatElem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PatElem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Pattype = 0;
                        object.Patcount = 0;
                    }
                    if (message.Pattype != null && message.hasOwnProperty("Pattype"))
                        object.Pattype = message.Pattype;
                    if (message.Patcount != null && message.hasOwnProperty("Patcount"))
                        object.Patcount = message.Patcount;
                    return object;
                };

                /**
                 * Converts this PatElem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.PatElem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PatElem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PatElem;
            })();

            ImMsgBody.GroupPostElem = (function() {

                /**
                 * Properties of a GroupPostElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IGroupPostElem
                 * @property {number|null} [TransType] GroupPostElem TransType
                 * @property {Uint8Array|null} [TransMsg] GroupPostElem TransMsg
                 */

                /**
                 * Constructs a new GroupPostElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a GroupPostElem.
                 * @implements IGroupPostElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IGroupPostElem=} [properties] Properties to set
                 */
                function GroupPostElem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GroupPostElem TransType.
                 * @member {number} TransType
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @instance
                 */
                GroupPostElem.prototype.TransType = 0;

                /**
                 * GroupPostElem TransMsg.
                 * @member {Uint8Array} TransMsg
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @instance
                 */
                GroupPostElem.prototype.TransMsg = $util.newBuffer([]);

                /**
                 * Creates a new GroupPostElem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupPostElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.GroupPostElem} GroupPostElem instance
                 */
                GroupPostElem.create = function create(properties) {
                    return new GroupPostElem(properties);
                };

                /**
                 * Encodes the specified GroupPostElem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupPostElem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupPostElem} message GroupPostElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupPostElem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.TransType != null && Object.hasOwnProperty.call(message, "TransType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.TransType);
                    if (message.TransMsg != null && Object.hasOwnProperty.call(message, "TransMsg"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.TransMsg);
                    return writer;
                };

                /**
                 * Encodes the specified GroupPostElem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.GroupPostElem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IGroupPostElem} message GroupPostElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroupPostElem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GroupPostElem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.GroupPostElem} GroupPostElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupPostElem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.GroupPostElem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.TransType = reader.int32();
                            break;
                        case 2:
                            message.TransMsg = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GroupPostElem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.GroupPostElem} GroupPostElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroupPostElem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GroupPostElem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GroupPostElem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.TransType != null && message.hasOwnProperty("TransType"))
                        if (!$util.isInteger(message.TransType))
                            return "TransType: integer expected";
                    if (message.TransMsg != null && message.hasOwnProperty("TransMsg"))
                        if (!(message.TransMsg && typeof message.TransMsg.length === "number" || $util.isString(message.TransMsg)))
                            return "TransMsg: buffer expected";
                    return null;
                };

                /**
                 * Creates a GroupPostElem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.GroupPostElem} GroupPostElem
                 */
                GroupPostElem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.GroupPostElem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.GroupPostElem();
                    if (object.TransType != null)
                        message.TransType = object.TransType | 0;
                    if (object.TransMsg != null)
                        if (typeof object.TransMsg === "string")
                            $util.base64.decode(object.TransMsg, message.TransMsg = $util.newBuffer($util.base64.length(object.TransMsg)), 0);
                        else if (object.TransMsg.length)
                            message.TransMsg = object.TransMsg;
                    return message;
                };

                /**
                 * Creates a plain object from a GroupPostElem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.GroupPostElem} message GroupPostElem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GroupPostElem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.TransType = 0;
                        if (options.bytes === String)
                            object.TransMsg = "";
                        else {
                            object.TransMsg = [];
                            if (options.bytes !== Array)
                                object.TransMsg = $util.newBuffer(object.TransMsg);
                        }
                    }
                    if (message.TransType != null && message.hasOwnProperty("TransType"))
                        object.TransType = message.TransType;
                    if (message.TransMsg != null && message.hasOwnProperty("TransMsg"))
                        object.TransMsg = options.bytes === String ? $util.base64.encode(message.TransMsg, 0, message.TransMsg.length) : options.bytes === Array ? Array.prototype.slice.call(message.TransMsg) : message.TransMsg;
                    return object;
                };

                /**
                 * Converts this GroupPostElem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.GroupPostElem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GroupPostElem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GroupPostElem;
            })();

            ImMsgBody.LightApp = (function() {

                /**
                 * Properties of a LightApp.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ILightApp
                 * @property {Uint8Array|null} [Data] LightApp Data
                 * @property {Uint8Array|null} [MsgResId] LightApp MsgResId
                 */

                /**
                 * Constructs a new LightApp.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a LightApp.
                 * @implements ILightApp
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ILightApp=} [properties] Properties to set
                 */
                function LightApp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LightApp Data.
                 * @member {Uint8Array} Data
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @instance
                 */
                LightApp.prototype.Data = $util.newBuffer([]);

                /**
                 * LightApp MsgResId.
                 * @member {Uint8Array} MsgResId
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @instance
                 */
                LightApp.prototype.MsgResId = $util.newBuffer([]);

                /**
                 * Creates a new LightApp instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILightApp=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.LightApp} LightApp instance
                 */
                LightApp.create = function create(properties) {
                    return new LightApp(properties);
                };

                /**
                 * Encodes the specified LightApp message. Does not implicitly {@link Msg.MsgField.ImMsgBody.LightApp.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILightApp} message LightApp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LightApp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Data != null && Object.hasOwnProperty.call(message, "Data"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Data);
                    if (message.MsgResId != null && Object.hasOwnProperty.call(message, "MsgResId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.MsgResId);
                    return writer;
                };

                /**
                 * Encodes the specified LightApp message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.LightApp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ILightApp} message LightApp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LightApp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LightApp message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.LightApp} LightApp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LightApp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.LightApp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Data = reader.bytes();
                            break;
                        case 2:
                            message.MsgResId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LightApp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.LightApp} LightApp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LightApp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LightApp message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LightApp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Data != null && message.hasOwnProperty("Data"))
                        if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                            return "Data: buffer expected";
                    if (message.MsgResId != null && message.hasOwnProperty("MsgResId"))
                        if (!(message.MsgResId && typeof message.MsgResId.length === "number" || $util.isString(message.MsgResId)))
                            return "MsgResId: buffer expected";
                    return null;
                };

                /**
                 * Creates a LightApp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.LightApp} LightApp
                 */
                LightApp.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.LightApp)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.LightApp();
                    if (object.Data != null)
                        if (typeof object.Data === "string")
                            $util.base64.decode(object.Data, message.Data = $util.newBuffer($util.base64.length(object.Data)), 0);
                        else if (object.Data.length)
                            message.Data = object.Data;
                    if (object.MsgResId != null)
                        if (typeof object.MsgResId === "string")
                            $util.base64.decode(object.MsgResId, message.MsgResId = $util.newBuffer($util.base64.length(object.MsgResId)), 0);
                        else if (object.MsgResId.length)
                            message.MsgResId = object.MsgResId;
                    return message;
                };

                /**
                 * Creates a plain object from a LightApp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.LightApp} message LightApp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LightApp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Data = "";
                        else {
                            object.Data = [];
                            if (options.bytes !== Array)
                                object.Data = $util.newBuffer(object.Data);
                        }
                        if (options.bytes === String)
                            object.MsgResId = "";
                        else {
                            object.MsgResId = [];
                            if (options.bytes !== Array)
                                object.MsgResId = $util.newBuffer(object.MsgResId);
                        }
                    }
                    if (message.Data != null && message.hasOwnProperty("Data"))
                        object.Data = options.bytes === String ? $util.base64.encode(message.Data, 0, message.Data.length) : options.bytes === Array ? Array.prototype.slice.call(message.Data) : message.Data;
                    if (message.MsgResId != null && message.hasOwnProperty("MsgResId"))
                        object.MsgResId = options.bytes === String ? $util.base64.encode(message.MsgResId, 0, message.MsgResId.length) : options.bytes === Array ? Array.prototype.slice.call(message.MsgResId) : message.MsgResId;
                    return object;
                };

                /**
                 * Converts this LightApp to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.LightApp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LightApp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LightApp;
            })();

            ImMsgBody.EimInfo = (function() {

                /**
                 * Properties of an EimInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IEimInfo
                 * @property {number|Long|null} [RootId] EimInfo RootId
                 * @property {number|null} [Flag] EimInfo Flag
                 */

                /**
                 * Constructs a new EimInfo.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an EimInfo.
                 * @implements IEimInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IEimInfo=} [properties] Properties to set
                 */
                function EimInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EimInfo RootId.
                 * @member {number|Long} RootId
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @instance
                 */
                EimInfo.prototype.RootId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * EimInfo Flag.
                 * @member {number} Flag
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @instance
                 */
                EimInfo.prototype.Flag = 0;

                /**
                 * Creates a new EimInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IEimInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.EimInfo} EimInfo instance
                 */
                EimInfo.create = function create(properties) {
                    return new EimInfo(properties);
                };

                /**
                 * Encodes the specified EimInfo message. Does not implicitly {@link Msg.MsgField.ImMsgBody.EimInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IEimInfo} message EimInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EimInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.RootId != null && Object.hasOwnProperty.call(message, "RootId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.RootId);
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Flag);
                    return writer;
                };

                /**
                 * Encodes the specified EimInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.EimInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IEimInfo} message EimInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EimInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EimInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.EimInfo} EimInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EimInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.EimInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.RootId = reader.int64();
                            break;
                        case 2:
                            message.Flag = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EimInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.EimInfo} EimInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EimInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EimInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EimInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.RootId != null && message.hasOwnProperty("RootId"))
                        if (!$util.isInteger(message.RootId) && !(message.RootId && $util.isInteger(message.RootId.low) && $util.isInteger(message.RootId.high)))
                            return "RootId: integer|Long expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!$util.isInteger(message.Flag))
                            return "Flag: integer expected";
                    return null;
                };

                /**
                 * Creates an EimInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.EimInfo} EimInfo
                 */
                EimInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.EimInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.EimInfo();
                    if (object.RootId != null)
                        if ($util.Long)
                            (message.RootId = $util.Long.fromValue(object.RootId)).unsigned = false;
                        else if (typeof object.RootId === "string")
                            message.RootId = parseInt(object.RootId, 10);
                        else if (typeof object.RootId === "number")
                            message.RootId = object.RootId;
                        else if (typeof object.RootId === "object")
                            message.RootId = new $util.LongBits(object.RootId.low >>> 0, object.RootId.high >>> 0).toNumber();
                    if (object.Flag != null)
                        message.Flag = object.Flag | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an EimInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.EimInfo} message EimInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EimInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.RootId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.RootId = options.longs === String ? "0" : 0;
                        object.Flag = 0;
                    }
                    if (message.RootId != null && message.hasOwnProperty("RootId"))
                        if (typeof message.RootId === "number")
                            object.RootId = options.longs === String ? String(message.RootId) : message.RootId;
                        else
                            object.RootId = options.longs === String ? $util.Long.prototype.toString.call(message.RootId) : options.longs === Number ? new $util.LongBits(message.RootId.low >>> 0, message.RootId.high >>> 0).toNumber() : message.RootId;
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = message.Flag;
                    return object;
                };

                /**
                 * Converts this EimInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.EimInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EimInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EimInfo;
            })();

            ImMsgBody.CommonElem = (function() {

                /**
                 * Properties of a CommonElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface ICommonElem
                 * @property {number|null} [Servicetype] CommonElem Servicetype
                 * @property {Uint8Array|null} [Pbelem] CommonElem Pbelem
                 * @property {number|null} [Businesstype] CommonElem Businesstype
                 */

                /**
                 * Constructs a new CommonElem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a CommonElem.
                 * @implements ICommonElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.ICommonElem=} [properties] Properties to set
                 */
                function CommonElem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommonElem Servicetype.
                 * @member {number} Servicetype
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @instance
                 */
                CommonElem.prototype.Servicetype = 0;

                /**
                 * CommonElem Pbelem.
                 * @member {Uint8Array} Pbelem
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @instance
                 */
                CommonElem.prototype.Pbelem = $util.newBuffer([]);

                /**
                 * CommonElem Businesstype.
                 * @member {number} Businesstype
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @instance
                 */
                CommonElem.prototype.Businesstype = 0;

                /**
                 * Creates a new CommonElem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICommonElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.CommonElem} CommonElem instance
                 */
                CommonElem.create = function create(properties) {
                    return new CommonElem(properties);
                };

                /**
                 * Encodes the specified CommonElem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.CommonElem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICommonElem} message CommonElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommonElem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Servicetype != null && Object.hasOwnProperty.call(message, "Servicetype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Servicetype);
                    if (message.Pbelem != null && Object.hasOwnProperty.call(message, "Pbelem"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Pbelem);
                    if (message.Businesstype != null && Object.hasOwnProperty.call(message, "Businesstype"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Businesstype);
                    return writer;
                };

                /**
                 * Encodes the specified CommonElem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.CommonElem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.ICommonElem} message CommonElem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommonElem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommonElem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.CommonElem} CommonElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommonElem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.CommonElem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Servicetype = reader.int32();
                            break;
                        case 2:
                            message.Pbelem = reader.bytes();
                            break;
                        case 3:
                            message.Businesstype = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommonElem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.CommonElem} CommonElem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommonElem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommonElem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommonElem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Servicetype != null && message.hasOwnProperty("Servicetype"))
                        if (!$util.isInteger(message.Servicetype))
                            return "Servicetype: integer expected";
                    if (message.Pbelem != null && message.hasOwnProperty("Pbelem"))
                        if (!(message.Pbelem && typeof message.Pbelem.length === "number" || $util.isString(message.Pbelem)))
                            return "Pbelem: buffer expected";
                    if (message.Businesstype != null && message.hasOwnProperty("Businesstype"))
                        if (!$util.isInteger(message.Businesstype))
                            return "Businesstype: integer expected";
                    return null;
                };

                /**
                 * Creates a CommonElem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.CommonElem} CommonElem
                 */
                CommonElem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.CommonElem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.CommonElem();
                    if (object.Servicetype != null)
                        message.Servicetype = object.Servicetype | 0;
                    if (object.Pbelem != null)
                        if (typeof object.Pbelem === "string")
                            $util.base64.decode(object.Pbelem, message.Pbelem = $util.newBuffer($util.base64.length(object.Pbelem)), 0);
                        else if (object.Pbelem.length)
                            message.Pbelem = object.Pbelem;
                    if (object.Businesstype != null)
                        message.Businesstype = object.Businesstype | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a CommonElem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.CommonElem} message CommonElem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommonElem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Servicetype = 0;
                        if (options.bytes === String)
                            object.Pbelem = "";
                        else {
                            object.Pbelem = [];
                            if (options.bytes !== Array)
                                object.Pbelem = $util.newBuffer(object.Pbelem);
                        }
                        object.Businesstype = 0;
                    }
                    if (message.Servicetype != null && message.hasOwnProperty("Servicetype"))
                        object.Servicetype = message.Servicetype;
                    if (message.Pbelem != null && message.hasOwnProperty("Pbelem"))
                        object.Pbelem = options.bytes === String ? $util.base64.encode(message.Pbelem, 0, message.Pbelem.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbelem) : message.Pbelem;
                    if (message.Businesstype != null && message.hasOwnProperty("Businesstype"))
                        object.Businesstype = message.Businesstype;
                    return object;
                };

                /**
                 * Converts this CommonElem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.CommonElem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommonElem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CommonElem;
            })();

            ImMsgBody.Elem = (function() {

                /**
                 * Properties of an Elem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IElem
                 * @property {Msg.MsgField.ImMsgBody.IText|null} [Text] Elem Text
                 * @property {Msg.MsgField.ImMsgBody.IFace|null} [Face] Elem Face
                 * @property {Msg.MsgField.ImMsgBody.IOnlineImage|null} [OnlineImage] Elem OnlineImage
                 * @property {Msg.MsgField.ImMsgBody.INotOnlineImage|null} [NotOnlineImage] Elem NotOnlineImage
                 * @property {Msg.MsgField.ImMsgBody.ITransElemInfo|null} [TransElemInfo] Elem TransElemInfo
                 * @property {Msg.MsgField.ImMsgBody.IMarketFace|null} [MarketFace] Elem MarketFace
                 * @property {Msg.MsgField.ImMsgBody.IElemFlags|null} [ElemFlags] Elem ElemFlags
                 * @property {Msg.MsgField.ImMsgBody.ICustomFace|null} [CustomFace] Elem CustomFace
                 * @property {Msg.MsgField.ImMsgBody.IElemFlags2|null} [ElemFlags2] Elem ElemFlags2
                 * @property {Msg.MsgField.ImMsgBody.IFunFace|null} [FunFace] Elem FunFace
                 * @property {Msg.MsgField.ImMsgBody.ISecretFileMsg|null} [SecretFileMsg] Elem SecretFileMsg
                 * @property {Msg.MsgField.ImMsgBody.IRichMsg|null} [RichMsg] Elem RichMsg
                 * @property {Msg.MsgField.ImMsgBody.IGroupFile|null} [GroupFile] Elem GroupFile
                 * @property {Msg.MsgField.ImMsgBody.IPubGroup|null} [PubGroup] Elem PubGroup
                 * @property {Msg.MsgField.ImMsgBody.IMarketTrans|null} [MarketTrans] Elem MarketTrans
                 * @property {Msg.MsgField.ImMsgBody.IExtraInfo|null} [ExtraInfo] Elem ExtraInfo
                 * @property {Msg.MsgField.ImMsgBody.IShakeWindow|null} [ShakeWindow] Elem ShakeWindow
                 * @property {Msg.MsgField.ImMsgBody.IPubAccount|null} [PubAccount] Elem PubAccount
                 * @property {Msg.MsgField.ImMsgBody.IVideoFile|null} [VideoFile] Elem VideoFile
                 * @property {Msg.MsgField.ImMsgBody.ITipsInfo|null} [TipsInfo] Elem TipsInfo
                 * @property {Msg.MsgField.ImMsgBody.IAnonGroupMsg|null} [AnonGroupMsg] Elem AnonGroupMsg
                 * @property {Msg.MsgField.ImMsgBody.IQqLiveOld|null} [QqLiveOld] Elem QqLiveOld
                 * @property {Msg.MsgField.ImMsgBody.ILifeOnline|null} [LifeOnline] Elem LifeOnline
                 * @property {Msg.MsgField.ImMsgBody.IQQWalletMsg|null} [QQWalletMsg] Elem QQWalletMsg
                 * @property {Msg.MsgField.ImMsgBody.ICrmElem|null} [CrmElem] Elem CrmElem
                 * @property {Msg.MsgField.ImMsgBody.IConferenceTipsInfo|null} [ConferenceTipsInfo] Elem ConferenceTipsInfo
                 * @property {Msg.MsgField.ImMsgBody.IRedbagInfo|null} [RedbagInfo] Elem RedbagInfo
                 * @property {Msg.MsgField.ImMsgBody.ILowVersionTips|null} [LowVersionTips] Elem LowVersionTips
                 * @property {Uint8Array|null} [BankcodeCtrlInfo] Elem BankcodeCtrlInfo
                 * @property {Msg.MsgField.ImMsgBody.INearByMsg|null} [NearByMsg] Elem NearByMsg
                 * @property {Msg.MsgField.ImMsgBody.ICustomElem|null} [CustomElem] Elem CustomElem
                 * @property {Msg.MsgField.ImMsgBody.ILocationInfo|null} [LocationInfo] Elem LocationInfo
                 * @property {Msg.MsgField.ImMsgBody.IPubAccInfo|null} [PubAccInfo] Elem PubAccInfo
                 * @property {Msg.MsgField.ImMsgBody.ISmallEmoji|null} [SmallEmoji] Elem SmallEmoji
                 * @property {Msg.MsgField.ImMsgBody.IFsjMsgElem|null} [FsjMsgElem] Elem FsjMsgElem
                 * @property {Msg.MsgField.ImMsgBody.IArkApp|null} [ArkApp] Elem ArkApp
                 * @property {Msg.MsgField.ImMsgBody.IGeneralFlags|null} [GeneralFlags] Elem GeneralFlags
                 * @property {Msg.MsgField.ImMsgBody.IHcFlashPic|null} [HcFlashPic] Elem HcFlashPic
                 * @property {Msg.MsgField.ImMsgBody.IDeliverGiftMsg|null} [DeliverGiftMsg] Elem DeliverGiftMsg
                 * @property {Msg.MsgField.ImMsgBody.IBitappMsg|null} [BitappMsg] Elem BitappMsg
                 * @property {Msg.MsgField.ImMsgBody.IOpenQqData|null} [OpenQqData] Elem OpenQqData
                 * @property {Msg.MsgField.ImMsgBody.IApolloMsg|null} [ApolloMsg] Elem ApolloMsg
                 * @property {Msg.MsgField.ImMsgBody.IGroupPubAccInfo|null} [GroupPubAccInfo] Elem GroupPubAccInfo
                 * @property {Msg.MsgField.ImMsgBody.IBlessMsg|null} [BlessMsg] Elem BlessMsg
                 * @property {Msg.MsgField.ImMsgBody.ISrcMsg|null} [SrcMsg] Elem SrcMsg
                 * @property {Msg.MsgField.ImMsgBody.ILolaMsg|null} [LolaMsg] Elem LolaMsg
                 * @property {Msg.MsgField.ImMsgBody.IGroupBusinessMsg|null} [GroupBusinessMsg] Elem GroupBusinessMsg
                 * @property {Msg.MsgField.ImMsgBody.IMsgWorkflowNotify|null} [MsgWorkflowNotify] Elem MsgWorkflowNotify
                 * @property {Msg.MsgField.ImMsgBody.IPatElem|null} [PatElem] Elem PatElem
                 * @property {Msg.MsgField.ImMsgBody.IGroupPostElem|null} [GroupPostElem] Elem GroupPostElem
                 * @property {Msg.MsgField.ImMsgBody.ILightApp|null} [LightApp] Elem LightApp
                 * @property {Msg.MsgField.ImMsgBody.IEimInfo|null} [EimInfo] Elem EimInfo
                 * @property {Msg.MsgField.ImMsgBody.ICommonElem|null} [CommonElem] Elem CommonElem
                 */

                /**
                 * Constructs a new Elem.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents an Elem.
                 * @implements IElem
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IElem=} [properties] Properties to set
                 */
                function Elem(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Elem Text.
                 * @member {Msg.MsgField.ImMsgBody.IText|null|undefined} Text
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.Text = null;

                /**
                 * Elem Face.
                 * @member {Msg.MsgField.ImMsgBody.IFace|null|undefined} Face
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.Face = null;

                /**
                 * Elem OnlineImage.
                 * @member {Msg.MsgField.ImMsgBody.IOnlineImage|null|undefined} OnlineImage
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.OnlineImage = null;

                /**
                 * Elem NotOnlineImage.
                 * @member {Msg.MsgField.ImMsgBody.INotOnlineImage|null|undefined} NotOnlineImage
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.NotOnlineImage = null;

                /**
                 * Elem TransElemInfo.
                 * @member {Msg.MsgField.ImMsgBody.ITransElemInfo|null|undefined} TransElemInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.TransElemInfo = null;

                /**
                 * Elem MarketFace.
                 * @member {Msg.MsgField.ImMsgBody.IMarketFace|null|undefined} MarketFace
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.MarketFace = null;

                /**
                 * Elem ElemFlags.
                 * @member {Msg.MsgField.ImMsgBody.IElemFlags|null|undefined} ElemFlags
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.ElemFlags = null;

                /**
                 * Elem CustomFace.
                 * @member {Msg.MsgField.ImMsgBody.ICustomFace|null|undefined} CustomFace
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.CustomFace = null;

                /**
                 * Elem ElemFlags2.
                 * @member {Msg.MsgField.ImMsgBody.IElemFlags2|null|undefined} ElemFlags2
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.ElemFlags2 = null;

                /**
                 * Elem FunFace.
                 * @member {Msg.MsgField.ImMsgBody.IFunFace|null|undefined} FunFace
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.FunFace = null;

                /**
                 * Elem SecretFileMsg.
                 * @member {Msg.MsgField.ImMsgBody.ISecretFileMsg|null|undefined} SecretFileMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.SecretFileMsg = null;

                /**
                 * Elem RichMsg.
                 * @member {Msg.MsgField.ImMsgBody.IRichMsg|null|undefined} RichMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.RichMsg = null;

                /**
                 * Elem GroupFile.
                 * @member {Msg.MsgField.ImMsgBody.IGroupFile|null|undefined} GroupFile
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.GroupFile = null;

                /**
                 * Elem PubGroup.
                 * @member {Msg.MsgField.ImMsgBody.IPubGroup|null|undefined} PubGroup
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.PubGroup = null;

                /**
                 * Elem MarketTrans.
                 * @member {Msg.MsgField.ImMsgBody.IMarketTrans|null|undefined} MarketTrans
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.MarketTrans = null;

                /**
                 * Elem ExtraInfo.
                 * @member {Msg.MsgField.ImMsgBody.IExtraInfo|null|undefined} ExtraInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.ExtraInfo = null;

                /**
                 * Elem ShakeWindow.
                 * @member {Msg.MsgField.ImMsgBody.IShakeWindow|null|undefined} ShakeWindow
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.ShakeWindow = null;

                /**
                 * Elem PubAccount.
                 * @member {Msg.MsgField.ImMsgBody.IPubAccount|null|undefined} PubAccount
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.PubAccount = null;

                /**
                 * Elem VideoFile.
                 * @member {Msg.MsgField.ImMsgBody.IVideoFile|null|undefined} VideoFile
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.VideoFile = null;

                /**
                 * Elem TipsInfo.
                 * @member {Msg.MsgField.ImMsgBody.ITipsInfo|null|undefined} TipsInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.TipsInfo = null;

                /**
                 * Elem AnonGroupMsg.
                 * @member {Msg.MsgField.ImMsgBody.IAnonGroupMsg|null|undefined} AnonGroupMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.AnonGroupMsg = null;

                /**
                 * Elem QqLiveOld.
                 * @member {Msg.MsgField.ImMsgBody.IQqLiveOld|null|undefined} QqLiveOld
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.QqLiveOld = null;

                /**
                 * Elem LifeOnline.
                 * @member {Msg.MsgField.ImMsgBody.ILifeOnline|null|undefined} LifeOnline
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.LifeOnline = null;

                /**
                 * Elem QQWalletMsg.
                 * @member {Msg.MsgField.ImMsgBody.IQQWalletMsg|null|undefined} QQWalletMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.QQWalletMsg = null;

                /**
                 * Elem CrmElem.
                 * @member {Msg.MsgField.ImMsgBody.ICrmElem|null|undefined} CrmElem
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.CrmElem = null;

                /**
                 * Elem ConferenceTipsInfo.
                 * @member {Msg.MsgField.ImMsgBody.IConferenceTipsInfo|null|undefined} ConferenceTipsInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.ConferenceTipsInfo = null;

                /**
                 * Elem RedbagInfo.
                 * @member {Msg.MsgField.ImMsgBody.IRedbagInfo|null|undefined} RedbagInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.RedbagInfo = null;

                /**
                 * Elem LowVersionTips.
                 * @member {Msg.MsgField.ImMsgBody.ILowVersionTips|null|undefined} LowVersionTips
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.LowVersionTips = null;

                /**
                 * Elem BankcodeCtrlInfo.
                 * @member {Uint8Array} BankcodeCtrlInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.BankcodeCtrlInfo = $util.newBuffer([]);

                /**
                 * Elem NearByMsg.
                 * @member {Msg.MsgField.ImMsgBody.INearByMsg|null|undefined} NearByMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.NearByMsg = null;

                /**
                 * Elem CustomElem.
                 * @member {Msg.MsgField.ImMsgBody.ICustomElem|null|undefined} CustomElem
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.CustomElem = null;

                /**
                 * Elem LocationInfo.
                 * @member {Msg.MsgField.ImMsgBody.ILocationInfo|null|undefined} LocationInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.LocationInfo = null;

                /**
                 * Elem PubAccInfo.
                 * @member {Msg.MsgField.ImMsgBody.IPubAccInfo|null|undefined} PubAccInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.PubAccInfo = null;

                /**
                 * Elem SmallEmoji.
                 * @member {Msg.MsgField.ImMsgBody.ISmallEmoji|null|undefined} SmallEmoji
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.SmallEmoji = null;

                /**
                 * Elem FsjMsgElem.
                 * @member {Msg.MsgField.ImMsgBody.IFsjMsgElem|null|undefined} FsjMsgElem
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.FsjMsgElem = null;

                /**
                 * Elem ArkApp.
                 * @member {Msg.MsgField.ImMsgBody.IArkApp|null|undefined} ArkApp
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.ArkApp = null;

                /**
                 * Elem GeneralFlags.
                 * @member {Msg.MsgField.ImMsgBody.IGeneralFlags|null|undefined} GeneralFlags
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.GeneralFlags = null;

                /**
                 * Elem HcFlashPic.
                 * @member {Msg.MsgField.ImMsgBody.IHcFlashPic|null|undefined} HcFlashPic
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.HcFlashPic = null;

                /**
                 * Elem DeliverGiftMsg.
                 * @member {Msg.MsgField.ImMsgBody.IDeliverGiftMsg|null|undefined} DeliverGiftMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.DeliverGiftMsg = null;

                /**
                 * Elem BitappMsg.
                 * @member {Msg.MsgField.ImMsgBody.IBitappMsg|null|undefined} BitappMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.BitappMsg = null;

                /**
                 * Elem OpenQqData.
                 * @member {Msg.MsgField.ImMsgBody.IOpenQqData|null|undefined} OpenQqData
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.OpenQqData = null;

                /**
                 * Elem ApolloMsg.
                 * @member {Msg.MsgField.ImMsgBody.IApolloMsg|null|undefined} ApolloMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.ApolloMsg = null;

                /**
                 * Elem GroupPubAccInfo.
                 * @member {Msg.MsgField.ImMsgBody.IGroupPubAccInfo|null|undefined} GroupPubAccInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.GroupPubAccInfo = null;

                /**
                 * Elem BlessMsg.
                 * @member {Msg.MsgField.ImMsgBody.IBlessMsg|null|undefined} BlessMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.BlessMsg = null;

                /**
                 * Elem SrcMsg.
                 * @member {Msg.MsgField.ImMsgBody.ISrcMsg|null|undefined} SrcMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.SrcMsg = null;

                /**
                 * Elem LolaMsg.
                 * @member {Msg.MsgField.ImMsgBody.ILolaMsg|null|undefined} LolaMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.LolaMsg = null;

                /**
                 * Elem GroupBusinessMsg.
                 * @member {Msg.MsgField.ImMsgBody.IGroupBusinessMsg|null|undefined} GroupBusinessMsg
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.GroupBusinessMsg = null;

                /**
                 * Elem MsgWorkflowNotify.
                 * @member {Msg.MsgField.ImMsgBody.IMsgWorkflowNotify|null|undefined} MsgWorkflowNotify
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.MsgWorkflowNotify = null;

                /**
                 * Elem PatElem.
                 * @member {Msg.MsgField.ImMsgBody.IPatElem|null|undefined} PatElem
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.PatElem = null;

                /**
                 * Elem GroupPostElem.
                 * @member {Msg.MsgField.ImMsgBody.IGroupPostElem|null|undefined} GroupPostElem
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.GroupPostElem = null;

                /**
                 * Elem LightApp.
                 * @member {Msg.MsgField.ImMsgBody.ILightApp|null|undefined} LightApp
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.LightApp = null;

                /**
                 * Elem EimInfo.
                 * @member {Msg.MsgField.ImMsgBody.IEimInfo|null|undefined} EimInfo
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.EimInfo = null;

                /**
                 * Elem CommonElem.
                 * @member {Msg.MsgField.ImMsgBody.ICommonElem|null|undefined} CommonElem
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 */
                Elem.prototype.CommonElem = null;

                /**
                 * Creates a new Elem instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElem=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.Elem} Elem instance
                 */
                Elem.create = function create(properties) {
                    return new Elem(properties);
                };

                /**
                 * Encodes the specified Elem message. Does not implicitly {@link Msg.MsgField.ImMsgBody.Elem.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElem} message Elem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Elem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Text != null && Object.hasOwnProperty.call(message, "Text"))
                        $root.Msg.MsgField.ImMsgBody.Text.encode(message.Text, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.Face != null && Object.hasOwnProperty.call(message, "Face"))
                        $root.Msg.MsgField.ImMsgBody.Face.encode(message.Face, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.OnlineImage != null && Object.hasOwnProperty.call(message, "OnlineImage"))
                        $root.Msg.MsgField.ImMsgBody.OnlineImage.encode(message.OnlineImage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.NotOnlineImage != null && Object.hasOwnProperty.call(message, "NotOnlineImage"))
                        $root.Msg.MsgField.ImMsgBody.NotOnlineImage.encode(message.NotOnlineImage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.TransElemInfo != null && Object.hasOwnProperty.call(message, "TransElemInfo"))
                        $root.Msg.MsgField.ImMsgBody.TransElemInfo.encode(message.TransElemInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.MarketFace != null && Object.hasOwnProperty.call(message, "MarketFace"))
                        $root.Msg.MsgField.ImMsgBody.MarketFace.encode(message.MarketFace, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.ElemFlags != null && Object.hasOwnProperty.call(message, "ElemFlags"))
                        $root.Msg.MsgField.ImMsgBody.ElemFlags.encode(message.ElemFlags, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.CustomFace != null && Object.hasOwnProperty.call(message, "CustomFace"))
                        $root.Msg.MsgField.ImMsgBody.CustomFace.encode(message.CustomFace, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.ElemFlags2 != null && Object.hasOwnProperty.call(message, "ElemFlags2"))
                        $root.Msg.MsgField.ImMsgBody.ElemFlags2.encode(message.ElemFlags2, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.FunFace != null && Object.hasOwnProperty.call(message, "FunFace"))
                        $root.Msg.MsgField.ImMsgBody.FunFace.encode(message.FunFace, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.SecretFileMsg != null && Object.hasOwnProperty.call(message, "SecretFileMsg"))
                        $root.Msg.MsgField.ImMsgBody.SecretFileMsg.encode(message.SecretFileMsg, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.RichMsg != null && Object.hasOwnProperty.call(message, "RichMsg"))
                        $root.Msg.MsgField.ImMsgBody.RichMsg.encode(message.RichMsg, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.GroupFile != null && Object.hasOwnProperty.call(message, "GroupFile"))
                        $root.Msg.MsgField.ImMsgBody.GroupFile.encode(message.GroupFile, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.PubGroup != null && Object.hasOwnProperty.call(message, "PubGroup"))
                        $root.Msg.MsgField.ImMsgBody.PubGroup.encode(message.PubGroup, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.MarketTrans != null && Object.hasOwnProperty.call(message, "MarketTrans"))
                        $root.Msg.MsgField.ImMsgBody.MarketTrans.encode(message.MarketTrans, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.ExtraInfo != null && Object.hasOwnProperty.call(message, "ExtraInfo"))
                        $root.Msg.MsgField.ImMsgBody.ExtraInfo.encode(message.ExtraInfo, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.ShakeWindow != null && Object.hasOwnProperty.call(message, "ShakeWindow"))
                        $root.Msg.MsgField.ImMsgBody.ShakeWindow.encode(message.ShakeWindow, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.PubAccount != null && Object.hasOwnProperty.call(message, "PubAccount"))
                        $root.Msg.MsgField.ImMsgBody.PubAccount.encode(message.PubAccount, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.VideoFile != null && Object.hasOwnProperty.call(message, "VideoFile"))
                        $root.Msg.MsgField.ImMsgBody.VideoFile.encode(message.VideoFile, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.TipsInfo != null && Object.hasOwnProperty.call(message, "TipsInfo"))
                        $root.Msg.MsgField.ImMsgBody.TipsInfo.encode(message.TipsInfo, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.AnonGroupMsg != null && Object.hasOwnProperty.call(message, "AnonGroupMsg"))
                        $root.Msg.MsgField.ImMsgBody.AnonGroupMsg.encode(message.AnonGroupMsg, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    if (message.QqLiveOld != null && Object.hasOwnProperty.call(message, "QqLiveOld"))
                        $root.Msg.MsgField.ImMsgBody.QqLiveOld.encode(message.QqLiveOld, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                    if (message.LifeOnline != null && Object.hasOwnProperty.call(message, "LifeOnline"))
                        $root.Msg.MsgField.ImMsgBody.LifeOnline.encode(message.LifeOnline, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                    if (message.QQWalletMsg != null && Object.hasOwnProperty.call(message, "QQWalletMsg"))
                        $root.Msg.MsgField.ImMsgBody.QQWalletMsg.encode(message.QQWalletMsg, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                    if (message.CrmElem != null && Object.hasOwnProperty.call(message, "CrmElem"))
                        $root.Msg.MsgField.ImMsgBody.CrmElem.encode(message.CrmElem, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                    if (message.ConferenceTipsInfo != null && Object.hasOwnProperty.call(message, "ConferenceTipsInfo"))
                        $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo.encode(message.ConferenceTipsInfo, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                    if (message.RedbagInfo != null && Object.hasOwnProperty.call(message, "RedbagInfo"))
                        $root.Msg.MsgField.ImMsgBody.RedbagInfo.encode(message.RedbagInfo, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                    if (message.LowVersionTips != null && Object.hasOwnProperty.call(message, "LowVersionTips"))
                        $root.Msg.MsgField.ImMsgBody.LowVersionTips.encode(message.LowVersionTips, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
                    if (message.BankcodeCtrlInfo != null && Object.hasOwnProperty.call(message, "BankcodeCtrlInfo"))
                        writer.uint32(/* id 29, wireType 2 =*/234).bytes(message.BankcodeCtrlInfo);
                    if (message.NearByMsg != null && Object.hasOwnProperty.call(message, "NearByMsg"))
                        $root.Msg.MsgField.ImMsgBody.NearByMsg.encode(message.NearByMsg, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                    if (message.CustomElem != null && Object.hasOwnProperty.call(message, "CustomElem"))
                        $root.Msg.MsgField.ImMsgBody.CustomElem.encode(message.CustomElem, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                    if (message.LocationInfo != null && Object.hasOwnProperty.call(message, "LocationInfo"))
                        $root.Msg.MsgField.ImMsgBody.LocationInfo.encode(message.LocationInfo, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                    if (message.PubAccInfo != null && Object.hasOwnProperty.call(message, "PubAccInfo"))
                        $root.Msg.MsgField.ImMsgBody.PubAccInfo.encode(message.PubAccInfo, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
                    if (message.SmallEmoji != null && Object.hasOwnProperty.call(message, "SmallEmoji"))
                        $root.Msg.MsgField.ImMsgBody.SmallEmoji.encode(message.SmallEmoji, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                    if (message.FsjMsgElem != null && Object.hasOwnProperty.call(message, "FsjMsgElem"))
                        $root.Msg.MsgField.ImMsgBody.FsjMsgElem.encode(message.FsjMsgElem, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
                    if (message.ArkApp != null && Object.hasOwnProperty.call(message, "ArkApp"))
                        $root.Msg.MsgField.ImMsgBody.ArkApp.encode(message.ArkApp, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
                    if (message.GeneralFlags != null && Object.hasOwnProperty.call(message, "GeneralFlags"))
                        $root.Msg.MsgField.ImMsgBody.GeneralFlags.encode(message.GeneralFlags, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
                    if (message.HcFlashPic != null && Object.hasOwnProperty.call(message, "HcFlashPic"))
                        $root.Msg.MsgField.ImMsgBody.HcFlashPic.encode(message.HcFlashPic, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
                    if (message.DeliverGiftMsg != null && Object.hasOwnProperty.call(message, "DeliverGiftMsg"))
                        $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg.encode(message.DeliverGiftMsg, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
                    if (message.BitappMsg != null && Object.hasOwnProperty.call(message, "BitappMsg"))
                        $root.Msg.MsgField.ImMsgBody.BitappMsg.encode(message.BitappMsg, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                    if (message.OpenQqData != null && Object.hasOwnProperty.call(message, "OpenQqData"))
                        $root.Msg.MsgField.ImMsgBody.OpenQqData.encode(message.OpenQqData, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                    if (message.ApolloMsg != null && Object.hasOwnProperty.call(message, "ApolloMsg"))
                        $root.Msg.MsgField.ImMsgBody.ApolloMsg.encode(message.ApolloMsg, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
                    if (message.GroupPubAccInfo != null && Object.hasOwnProperty.call(message, "GroupPubAccInfo"))
                        $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo.encode(message.GroupPubAccInfo, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
                    if (message.BlessMsg != null && Object.hasOwnProperty.call(message, "BlessMsg"))
                        $root.Msg.MsgField.ImMsgBody.BlessMsg.encode(message.BlessMsg, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
                    if (message.SrcMsg != null && Object.hasOwnProperty.call(message, "SrcMsg"))
                        $root.Msg.MsgField.ImMsgBody.SrcMsg.encode(message.SrcMsg, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
                    if (message.LolaMsg != null && Object.hasOwnProperty.call(message, "LolaMsg"))
                        $root.Msg.MsgField.ImMsgBody.LolaMsg.encode(message.LolaMsg, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
                    if (message.GroupBusinessMsg != null && Object.hasOwnProperty.call(message, "GroupBusinessMsg"))
                        $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg.encode(message.GroupBusinessMsg, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
                    if (message.MsgWorkflowNotify != null && Object.hasOwnProperty.call(message, "MsgWorkflowNotify"))
                        $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify.encode(message.MsgWorkflowNotify, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
                    if (message.PatElem != null && Object.hasOwnProperty.call(message, "PatElem"))
                        $root.Msg.MsgField.ImMsgBody.PatElem.encode(message.PatElem, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
                    if (message.GroupPostElem != null && Object.hasOwnProperty.call(message, "GroupPostElem"))
                        $root.Msg.MsgField.ImMsgBody.GroupPostElem.encode(message.GroupPostElem, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                    if (message.LightApp != null && Object.hasOwnProperty.call(message, "LightApp"))
                        $root.Msg.MsgField.ImMsgBody.LightApp.encode(message.LightApp, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
                    if (message.EimInfo != null && Object.hasOwnProperty.call(message, "EimInfo"))
                        $root.Msg.MsgField.ImMsgBody.EimInfo.encode(message.EimInfo, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
                    if (message.CommonElem != null && Object.hasOwnProperty.call(message, "CommonElem"))
                        $root.Msg.MsgField.ImMsgBody.CommonElem.encode(message.CommonElem, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Elem message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.Elem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IElem} message Elem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Elem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Elem message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.Elem} Elem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Elem.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.Elem();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Text = $root.Msg.MsgField.ImMsgBody.Text.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.Face = $root.Msg.MsgField.ImMsgBody.Face.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.OnlineImage = $root.Msg.MsgField.ImMsgBody.OnlineImage.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.NotOnlineImage = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.TransElemInfo = $root.Msg.MsgField.ImMsgBody.TransElemInfo.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.MarketFace = $root.Msg.MsgField.ImMsgBody.MarketFace.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.ElemFlags = $root.Msg.MsgField.ImMsgBody.ElemFlags.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.CustomFace = $root.Msg.MsgField.ImMsgBody.CustomFace.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.ElemFlags2 = $root.Msg.MsgField.ImMsgBody.ElemFlags2.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.FunFace = $root.Msg.MsgField.ImMsgBody.FunFace.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.SecretFileMsg = $root.Msg.MsgField.ImMsgBody.SecretFileMsg.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.RichMsg = $root.Msg.MsgField.ImMsgBody.RichMsg.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.GroupFile = $root.Msg.MsgField.ImMsgBody.GroupFile.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.PubGroup = $root.Msg.MsgField.ImMsgBody.PubGroup.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.MarketTrans = $root.Msg.MsgField.ImMsgBody.MarketTrans.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.ExtraInfo = $root.Msg.MsgField.ImMsgBody.ExtraInfo.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.ShakeWindow = $root.Msg.MsgField.ImMsgBody.ShakeWindow.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.PubAccount = $root.Msg.MsgField.ImMsgBody.PubAccount.decode(reader, reader.uint32());
                            break;
                        case 19:
                            message.VideoFile = $root.Msg.MsgField.ImMsgBody.VideoFile.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.TipsInfo = $root.Msg.MsgField.ImMsgBody.TipsInfo.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.AnonGroupMsg = $root.Msg.MsgField.ImMsgBody.AnonGroupMsg.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.QqLiveOld = $root.Msg.MsgField.ImMsgBody.QqLiveOld.decode(reader, reader.uint32());
                            break;
                        case 23:
                            message.LifeOnline = $root.Msg.MsgField.ImMsgBody.LifeOnline.decode(reader, reader.uint32());
                            break;
                        case 24:
                            message.QQWalletMsg = $root.Msg.MsgField.ImMsgBody.QQWalletMsg.decode(reader, reader.uint32());
                            break;
                        case 25:
                            message.CrmElem = $root.Msg.MsgField.ImMsgBody.CrmElem.decode(reader, reader.uint32());
                            break;
                        case 26:
                            message.ConferenceTipsInfo = $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo.decode(reader, reader.uint32());
                            break;
                        case 27:
                            message.RedbagInfo = $root.Msg.MsgField.ImMsgBody.RedbagInfo.decode(reader, reader.uint32());
                            break;
                        case 28:
                            message.LowVersionTips = $root.Msg.MsgField.ImMsgBody.LowVersionTips.decode(reader, reader.uint32());
                            break;
                        case 29:
                            message.BankcodeCtrlInfo = reader.bytes();
                            break;
                        case 30:
                            message.NearByMsg = $root.Msg.MsgField.ImMsgBody.NearByMsg.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.CustomElem = $root.Msg.MsgField.ImMsgBody.CustomElem.decode(reader, reader.uint32());
                            break;
                        case 32:
                            message.LocationInfo = $root.Msg.MsgField.ImMsgBody.LocationInfo.decode(reader, reader.uint32());
                            break;
                        case 33:
                            message.PubAccInfo = $root.Msg.MsgField.ImMsgBody.PubAccInfo.decode(reader, reader.uint32());
                            break;
                        case 34:
                            message.SmallEmoji = $root.Msg.MsgField.ImMsgBody.SmallEmoji.decode(reader, reader.uint32());
                            break;
                        case 35:
                            message.FsjMsgElem = $root.Msg.MsgField.ImMsgBody.FsjMsgElem.decode(reader, reader.uint32());
                            break;
                        case 36:
                            message.ArkApp = $root.Msg.MsgField.ImMsgBody.ArkApp.decode(reader, reader.uint32());
                            break;
                        case 37:
                            message.GeneralFlags = $root.Msg.MsgField.ImMsgBody.GeneralFlags.decode(reader, reader.uint32());
                            break;
                        case 38:
                            message.HcFlashPic = $root.Msg.MsgField.ImMsgBody.HcFlashPic.decode(reader, reader.uint32());
                            break;
                        case 39:
                            message.DeliverGiftMsg = $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.BitappMsg = $root.Msg.MsgField.ImMsgBody.BitappMsg.decode(reader, reader.uint32());
                            break;
                        case 41:
                            message.OpenQqData = $root.Msg.MsgField.ImMsgBody.OpenQqData.decode(reader, reader.uint32());
                            break;
                        case 42:
                            message.ApolloMsg = $root.Msg.MsgField.ImMsgBody.ApolloMsg.decode(reader, reader.uint32());
                            break;
                        case 43:
                            message.GroupPubAccInfo = $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo.decode(reader, reader.uint32());
                            break;
                        case 44:
                            message.BlessMsg = $root.Msg.MsgField.ImMsgBody.BlessMsg.decode(reader, reader.uint32());
                            break;
                        case 45:
                            message.SrcMsg = $root.Msg.MsgField.ImMsgBody.SrcMsg.decode(reader, reader.uint32());
                            break;
                        case 46:
                            message.LolaMsg = $root.Msg.MsgField.ImMsgBody.LolaMsg.decode(reader, reader.uint32());
                            break;
                        case 47:
                            message.GroupBusinessMsg = $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg.decode(reader, reader.uint32());
                            break;
                        case 48:
                            message.MsgWorkflowNotify = $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify.decode(reader, reader.uint32());
                            break;
                        case 49:
                            message.PatElem = $root.Msg.MsgField.ImMsgBody.PatElem.decode(reader, reader.uint32());
                            break;
                        case 50:
                            message.GroupPostElem = $root.Msg.MsgField.ImMsgBody.GroupPostElem.decode(reader, reader.uint32());
                            break;
                        case 51:
                            message.LightApp = $root.Msg.MsgField.ImMsgBody.LightApp.decode(reader, reader.uint32());
                            break;
                        case 52:
                            message.EimInfo = $root.Msg.MsgField.ImMsgBody.EimInfo.decode(reader, reader.uint32());
                            break;
                        case 53:
                            message.CommonElem = $root.Msg.MsgField.ImMsgBody.CommonElem.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Elem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.Elem} Elem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Elem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Elem message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Elem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Text != null && message.hasOwnProperty("Text")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Text.verify(message.Text);
                        if (error)
                            return "Text." + error;
                    }
                    if (message.Face != null && message.hasOwnProperty("Face")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Face.verify(message.Face);
                        if (error)
                            return "Face." + error;
                    }
                    if (message.OnlineImage != null && message.hasOwnProperty("OnlineImage")) {
                        var error = $root.Msg.MsgField.ImMsgBody.OnlineImage.verify(message.OnlineImage);
                        if (error)
                            return "OnlineImage." + error;
                    }
                    if (message.NotOnlineImage != null && message.hasOwnProperty("NotOnlineImage")) {
                        var error = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.verify(message.NotOnlineImage);
                        if (error)
                            return "NotOnlineImage." + error;
                    }
                    if (message.TransElemInfo != null && message.hasOwnProperty("TransElemInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.TransElemInfo.verify(message.TransElemInfo);
                        if (error)
                            return "TransElemInfo." + error;
                    }
                    if (message.MarketFace != null && message.hasOwnProperty("MarketFace")) {
                        var error = $root.Msg.MsgField.ImMsgBody.MarketFace.verify(message.MarketFace);
                        if (error)
                            return "MarketFace." + error;
                    }
                    if (message.ElemFlags != null && message.hasOwnProperty("ElemFlags")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ElemFlags.verify(message.ElemFlags);
                        if (error)
                            return "ElemFlags." + error;
                    }
                    if (message.CustomFace != null && message.hasOwnProperty("CustomFace")) {
                        var error = $root.Msg.MsgField.ImMsgBody.CustomFace.verify(message.CustomFace);
                        if (error)
                            return "CustomFace." + error;
                    }
                    if (message.ElemFlags2 != null && message.hasOwnProperty("ElemFlags2")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ElemFlags2.verify(message.ElemFlags2);
                        if (error)
                            return "ElemFlags2." + error;
                    }
                    if (message.FunFace != null && message.hasOwnProperty("FunFace")) {
                        var error = $root.Msg.MsgField.ImMsgBody.FunFace.verify(message.FunFace);
                        if (error)
                            return "FunFace." + error;
                    }
                    if (message.SecretFileMsg != null && message.hasOwnProperty("SecretFileMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.SecretFileMsg.verify(message.SecretFileMsg);
                        if (error)
                            return "SecretFileMsg." + error;
                    }
                    if (message.RichMsg != null && message.hasOwnProperty("RichMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.RichMsg.verify(message.RichMsg);
                        if (error)
                            return "RichMsg." + error;
                    }
                    if (message.GroupFile != null && message.hasOwnProperty("GroupFile")) {
                        var error = $root.Msg.MsgField.ImMsgBody.GroupFile.verify(message.GroupFile);
                        if (error)
                            return "GroupFile." + error;
                    }
                    if (message.PubGroup != null && message.hasOwnProperty("PubGroup")) {
                        var error = $root.Msg.MsgField.ImMsgBody.PubGroup.verify(message.PubGroup);
                        if (error)
                            return "PubGroup." + error;
                    }
                    if (message.MarketTrans != null && message.hasOwnProperty("MarketTrans")) {
                        var error = $root.Msg.MsgField.ImMsgBody.MarketTrans.verify(message.MarketTrans);
                        if (error)
                            return "MarketTrans." + error;
                    }
                    if (message.ExtraInfo != null && message.hasOwnProperty("ExtraInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ExtraInfo.verify(message.ExtraInfo);
                        if (error)
                            return "ExtraInfo." + error;
                    }
                    if (message.ShakeWindow != null && message.hasOwnProperty("ShakeWindow")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ShakeWindow.verify(message.ShakeWindow);
                        if (error)
                            return "ShakeWindow." + error;
                    }
                    if (message.PubAccount != null && message.hasOwnProperty("PubAccount")) {
                        var error = $root.Msg.MsgField.ImMsgBody.PubAccount.verify(message.PubAccount);
                        if (error)
                            return "PubAccount." + error;
                    }
                    if (message.VideoFile != null && message.hasOwnProperty("VideoFile")) {
                        var error = $root.Msg.MsgField.ImMsgBody.VideoFile.verify(message.VideoFile);
                        if (error)
                            return "VideoFile." + error;
                    }
                    if (message.TipsInfo != null && message.hasOwnProperty("TipsInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.TipsInfo.verify(message.TipsInfo);
                        if (error)
                            return "TipsInfo." + error;
                    }
                    if (message.AnonGroupMsg != null && message.hasOwnProperty("AnonGroupMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.AnonGroupMsg.verify(message.AnonGroupMsg);
                        if (error)
                            return "AnonGroupMsg." + error;
                    }
                    if (message.QqLiveOld != null && message.hasOwnProperty("QqLiveOld")) {
                        var error = $root.Msg.MsgField.ImMsgBody.QqLiveOld.verify(message.QqLiveOld);
                        if (error)
                            return "QqLiveOld." + error;
                    }
                    if (message.LifeOnline != null && message.hasOwnProperty("LifeOnline")) {
                        var error = $root.Msg.MsgField.ImMsgBody.LifeOnline.verify(message.LifeOnline);
                        if (error)
                            return "LifeOnline." + error;
                    }
                    if (message.QQWalletMsg != null && message.hasOwnProperty("QQWalletMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.QQWalletMsg.verify(message.QQWalletMsg);
                        if (error)
                            return "QQWalletMsg." + error;
                    }
                    if (message.CrmElem != null && message.hasOwnProperty("CrmElem")) {
                        var error = $root.Msg.MsgField.ImMsgBody.CrmElem.verify(message.CrmElem);
                        if (error)
                            return "CrmElem." + error;
                    }
                    if (message.ConferenceTipsInfo != null && message.hasOwnProperty("ConferenceTipsInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo.verify(message.ConferenceTipsInfo);
                        if (error)
                            return "ConferenceTipsInfo." + error;
                    }
                    if (message.RedbagInfo != null && message.hasOwnProperty("RedbagInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.RedbagInfo.verify(message.RedbagInfo);
                        if (error)
                            return "RedbagInfo." + error;
                    }
                    if (message.LowVersionTips != null && message.hasOwnProperty("LowVersionTips")) {
                        var error = $root.Msg.MsgField.ImMsgBody.LowVersionTips.verify(message.LowVersionTips);
                        if (error)
                            return "LowVersionTips." + error;
                    }
                    if (message.BankcodeCtrlInfo != null && message.hasOwnProperty("BankcodeCtrlInfo"))
                        if (!(message.BankcodeCtrlInfo && typeof message.BankcodeCtrlInfo.length === "number" || $util.isString(message.BankcodeCtrlInfo)))
                            return "BankcodeCtrlInfo: buffer expected";
                    if (message.NearByMsg != null && message.hasOwnProperty("NearByMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.NearByMsg.verify(message.NearByMsg);
                        if (error)
                            return "NearByMsg." + error;
                    }
                    if (message.CustomElem != null && message.hasOwnProperty("CustomElem")) {
                        var error = $root.Msg.MsgField.ImMsgBody.CustomElem.verify(message.CustomElem);
                        if (error)
                            return "CustomElem." + error;
                    }
                    if (message.LocationInfo != null && message.hasOwnProperty("LocationInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.LocationInfo.verify(message.LocationInfo);
                        if (error)
                            return "LocationInfo." + error;
                    }
                    if (message.PubAccInfo != null && message.hasOwnProperty("PubAccInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.PubAccInfo.verify(message.PubAccInfo);
                        if (error)
                            return "PubAccInfo." + error;
                    }
                    if (message.SmallEmoji != null && message.hasOwnProperty("SmallEmoji")) {
                        var error = $root.Msg.MsgField.ImMsgBody.SmallEmoji.verify(message.SmallEmoji);
                        if (error)
                            return "SmallEmoji." + error;
                    }
                    if (message.FsjMsgElem != null && message.hasOwnProperty("FsjMsgElem")) {
                        var error = $root.Msg.MsgField.ImMsgBody.FsjMsgElem.verify(message.FsjMsgElem);
                        if (error)
                            return "FsjMsgElem." + error;
                    }
                    if (message.ArkApp != null && message.hasOwnProperty("ArkApp")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ArkApp.verify(message.ArkApp);
                        if (error)
                            return "ArkApp." + error;
                    }
                    if (message.GeneralFlags != null && message.hasOwnProperty("GeneralFlags")) {
                        var error = $root.Msg.MsgField.ImMsgBody.GeneralFlags.verify(message.GeneralFlags);
                        if (error)
                            return "GeneralFlags." + error;
                    }
                    if (message.HcFlashPic != null && message.hasOwnProperty("HcFlashPic")) {
                        var error = $root.Msg.MsgField.ImMsgBody.HcFlashPic.verify(message.HcFlashPic);
                        if (error)
                            return "HcFlashPic." + error;
                    }
                    if (message.DeliverGiftMsg != null && message.hasOwnProperty("DeliverGiftMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg.verify(message.DeliverGiftMsg);
                        if (error)
                            return "DeliverGiftMsg." + error;
                    }
                    if (message.BitappMsg != null && message.hasOwnProperty("BitappMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.BitappMsg.verify(message.BitappMsg);
                        if (error)
                            return "BitappMsg." + error;
                    }
                    if (message.OpenQqData != null && message.hasOwnProperty("OpenQqData")) {
                        var error = $root.Msg.MsgField.ImMsgBody.OpenQqData.verify(message.OpenQqData);
                        if (error)
                            return "OpenQqData." + error;
                    }
                    if (message.ApolloMsg != null && message.hasOwnProperty("ApolloMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.ApolloMsg.verify(message.ApolloMsg);
                        if (error)
                            return "ApolloMsg." + error;
                    }
                    if (message.GroupPubAccInfo != null && message.hasOwnProperty("GroupPubAccInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo.verify(message.GroupPubAccInfo);
                        if (error)
                            return "GroupPubAccInfo." + error;
                    }
                    if (message.BlessMsg != null && message.hasOwnProperty("BlessMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.BlessMsg.verify(message.BlessMsg);
                        if (error)
                            return "BlessMsg." + error;
                    }
                    if (message.SrcMsg != null && message.hasOwnProperty("SrcMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.SrcMsg.verify(message.SrcMsg);
                        if (error)
                            return "SrcMsg." + error;
                    }
                    if (message.LolaMsg != null && message.hasOwnProperty("LolaMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.LolaMsg.verify(message.LolaMsg);
                        if (error)
                            return "LolaMsg." + error;
                    }
                    if (message.GroupBusinessMsg != null && message.hasOwnProperty("GroupBusinessMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg.verify(message.GroupBusinessMsg);
                        if (error)
                            return "GroupBusinessMsg." + error;
                    }
                    if (message.MsgWorkflowNotify != null && message.hasOwnProperty("MsgWorkflowNotify")) {
                        var error = $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify.verify(message.MsgWorkflowNotify);
                        if (error)
                            return "MsgWorkflowNotify." + error;
                    }
                    if (message.PatElem != null && message.hasOwnProperty("PatElem")) {
                        var error = $root.Msg.MsgField.ImMsgBody.PatElem.verify(message.PatElem);
                        if (error)
                            return "PatElem." + error;
                    }
                    if (message.GroupPostElem != null && message.hasOwnProperty("GroupPostElem")) {
                        var error = $root.Msg.MsgField.ImMsgBody.GroupPostElem.verify(message.GroupPostElem);
                        if (error)
                            return "GroupPostElem." + error;
                    }
                    if (message.LightApp != null && message.hasOwnProperty("LightApp")) {
                        var error = $root.Msg.MsgField.ImMsgBody.LightApp.verify(message.LightApp);
                        if (error)
                            return "LightApp." + error;
                    }
                    if (message.EimInfo != null && message.hasOwnProperty("EimInfo")) {
                        var error = $root.Msg.MsgField.ImMsgBody.EimInfo.verify(message.EimInfo);
                        if (error)
                            return "EimInfo." + error;
                    }
                    if (message.CommonElem != null && message.hasOwnProperty("CommonElem")) {
                        var error = $root.Msg.MsgField.ImMsgBody.CommonElem.verify(message.CommonElem);
                        if (error)
                            return "CommonElem." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Elem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.Elem} Elem
                 */
                Elem.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.Elem)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.Elem();
                    if (object.Text != null) {
                        if (typeof object.Text !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.Text: object expected");
                        message.Text = $root.Msg.MsgField.ImMsgBody.Text.fromObject(object.Text);
                    }
                    if (object.Face != null) {
                        if (typeof object.Face !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.Face: object expected");
                        message.Face = $root.Msg.MsgField.ImMsgBody.Face.fromObject(object.Face);
                    }
                    if (object.OnlineImage != null) {
                        if (typeof object.OnlineImage !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.OnlineImage: object expected");
                        message.OnlineImage = $root.Msg.MsgField.ImMsgBody.OnlineImage.fromObject(object.OnlineImage);
                    }
                    if (object.NotOnlineImage != null) {
                        if (typeof object.NotOnlineImage !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.NotOnlineImage: object expected");
                        message.NotOnlineImage = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.fromObject(object.NotOnlineImage);
                    }
                    if (object.TransElemInfo != null) {
                        if (typeof object.TransElemInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.TransElemInfo: object expected");
                        message.TransElemInfo = $root.Msg.MsgField.ImMsgBody.TransElemInfo.fromObject(object.TransElemInfo);
                    }
                    if (object.MarketFace != null) {
                        if (typeof object.MarketFace !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.MarketFace: object expected");
                        message.MarketFace = $root.Msg.MsgField.ImMsgBody.MarketFace.fromObject(object.MarketFace);
                    }
                    if (object.ElemFlags != null) {
                        if (typeof object.ElemFlags !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.ElemFlags: object expected");
                        message.ElemFlags = $root.Msg.MsgField.ImMsgBody.ElemFlags.fromObject(object.ElemFlags);
                    }
                    if (object.CustomFace != null) {
                        if (typeof object.CustomFace !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.CustomFace: object expected");
                        message.CustomFace = $root.Msg.MsgField.ImMsgBody.CustomFace.fromObject(object.CustomFace);
                    }
                    if (object.ElemFlags2 != null) {
                        if (typeof object.ElemFlags2 !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.ElemFlags2: object expected");
                        message.ElemFlags2 = $root.Msg.MsgField.ImMsgBody.ElemFlags2.fromObject(object.ElemFlags2);
                    }
                    if (object.FunFace != null) {
                        if (typeof object.FunFace !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.FunFace: object expected");
                        message.FunFace = $root.Msg.MsgField.ImMsgBody.FunFace.fromObject(object.FunFace);
                    }
                    if (object.SecretFileMsg != null) {
                        if (typeof object.SecretFileMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.SecretFileMsg: object expected");
                        message.SecretFileMsg = $root.Msg.MsgField.ImMsgBody.SecretFileMsg.fromObject(object.SecretFileMsg);
                    }
                    if (object.RichMsg != null) {
                        if (typeof object.RichMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.RichMsg: object expected");
                        message.RichMsg = $root.Msg.MsgField.ImMsgBody.RichMsg.fromObject(object.RichMsg);
                    }
                    if (object.GroupFile != null) {
                        if (typeof object.GroupFile !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.GroupFile: object expected");
                        message.GroupFile = $root.Msg.MsgField.ImMsgBody.GroupFile.fromObject(object.GroupFile);
                    }
                    if (object.PubGroup != null) {
                        if (typeof object.PubGroup !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.PubGroup: object expected");
                        message.PubGroup = $root.Msg.MsgField.ImMsgBody.PubGroup.fromObject(object.PubGroup);
                    }
                    if (object.MarketTrans != null) {
                        if (typeof object.MarketTrans !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.MarketTrans: object expected");
                        message.MarketTrans = $root.Msg.MsgField.ImMsgBody.MarketTrans.fromObject(object.MarketTrans);
                    }
                    if (object.ExtraInfo != null) {
                        if (typeof object.ExtraInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.ExtraInfo: object expected");
                        message.ExtraInfo = $root.Msg.MsgField.ImMsgBody.ExtraInfo.fromObject(object.ExtraInfo);
                    }
                    if (object.ShakeWindow != null) {
                        if (typeof object.ShakeWindow !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.ShakeWindow: object expected");
                        message.ShakeWindow = $root.Msg.MsgField.ImMsgBody.ShakeWindow.fromObject(object.ShakeWindow);
                    }
                    if (object.PubAccount != null) {
                        if (typeof object.PubAccount !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.PubAccount: object expected");
                        message.PubAccount = $root.Msg.MsgField.ImMsgBody.PubAccount.fromObject(object.PubAccount);
                    }
                    if (object.VideoFile != null) {
                        if (typeof object.VideoFile !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.VideoFile: object expected");
                        message.VideoFile = $root.Msg.MsgField.ImMsgBody.VideoFile.fromObject(object.VideoFile);
                    }
                    if (object.TipsInfo != null) {
                        if (typeof object.TipsInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.TipsInfo: object expected");
                        message.TipsInfo = $root.Msg.MsgField.ImMsgBody.TipsInfo.fromObject(object.TipsInfo);
                    }
                    if (object.AnonGroupMsg != null) {
                        if (typeof object.AnonGroupMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.AnonGroupMsg: object expected");
                        message.AnonGroupMsg = $root.Msg.MsgField.ImMsgBody.AnonGroupMsg.fromObject(object.AnonGroupMsg);
                    }
                    if (object.QqLiveOld != null) {
                        if (typeof object.QqLiveOld !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.QqLiveOld: object expected");
                        message.QqLiveOld = $root.Msg.MsgField.ImMsgBody.QqLiveOld.fromObject(object.QqLiveOld);
                    }
                    if (object.LifeOnline != null) {
                        if (typeof object.LifeOnline !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.LifeOnline: object expected");
                        message.LifeOnline = $root.Msg.MsgField.ImMsgBody.LifeOnline.fromObject(object.LifeOnline);
                    }
                    if (object.QQWalletMsg != null) {
                        if (typeof object.QQWalletMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.QQWalletMsg: object expected");
                        message.QQWalletMsg = $root.Msg.MsgField.ImMsgBody.QQWalletMsg.fromObject(object.QQWalletMsg);
                    }
                    if (object.CrmElem != null) {
                        if (typeof object.CrmElem !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.CrmElem: object expected");
                        message.CrmElem = $root.Msg.MsgField.ImMsgBody.CrmElem.fromObject(object.CrmElem);
                    }
                    if (object.ConferenceTipsInfo != null) {
                        if (typeof object.ConferenceTipsInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.ConferenceTipsInfo: object expected");
                        message.ConferenceTipsInfo = $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo.fromObject(object.ConferenceTipsInfo);
                    }
                    if (object.RedbagInfo != null) {
                        if (typeof object.RedbagInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.RedbagInfo: object expected");
                        message.RedbagInfo = $root.Msg.MsgField.ImMsgBody.RedbagInfo.fromObject(object.RedbagInfo);
                    }
                    if (object.LowVersionTips != null) {
                        if (typeof object.LowVersionTips !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.LowVersionTips: object expected");
                        message.LowVersionTips = $root.Msg.MsgField.ImMsgBody.LowVersionTips.fromObject(object.LowVersionTips);
                    }
                    if (object.BankcodeCtrlInfo != null)
                        if (typeof object.BankcodeCtrlInfo === "string")
                            $util.base64.decode(object.BankcodeCtrlInfo, message.BankcodeCtrlInfo = $util.newBuffer($util.base64.length(object.BankcodeCtrlInfo)), 0);
                        else if (object.BankcodeCtrlInfo.length)
                            message.BankcodeCtrlInfo = object.BankcodeCtrlInfo;
                    if (object.NearByMsg != null) {
                        if (typeof object.NearByMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.NearByMsg: object expected");
                        message.NearByMsg = $root.Msg.MsgField.ImMsgBody.NearByMsg.fromObject(object.NearByMsg);
                    }
                    if (object.CustomElem != null) {
                        if (typeof object.CustomElem !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.CustomElem: object expected");
                        message.CustomElem = $root.Msg.MsgField.ImMsgBody.CustomElem.fromObject(object.CustomElem);
                    }
                    if (object.LocationInfo != null) {
                        if (typeof object.LocationInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.LocationInfo: object expected");
                        message.LocationInfo = $root.Msg.MsgField.ImMsgBody.LocationInfo.fromObject(object.LocationInfo);
                    }
                    if (object.PubAccInfo != null) {
                        if (typeof object.PubAccInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.PubAccInfo: object expected");
                        message.PubAccInfo = $root.Msg.MsgField.ImMsgBody.PubAccInfo.fromObject(object.PubAccInfo);
                    }
                    if (object.SmallEmoji != null) {
                        if (typeof object.SmallEmoji !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.SmallEmoji: object expected");
                        message.SmallEmoji = $root.Msg.MsgField.ImMsgBody.SmallEmoji.fromObject(object.SmallEmoji);
                    }
                    if (object.FsjMsgElem != null) {
                        if (typeof object.FsjMsgElem !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.FsjMsgElem: object expected");
                        message.FsjMsgElem = $root.Msg.MsgField.ImMsgBody.FsjMsgElem.fromObject(object.FsjMsgElem);
                    }
                    if (object.ArkApp != null) {
                        if (typeof object.ArkApp !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.ArkApp: object expected");
                        message.ArkApp = $root.Msg.MsgField.ImMsgBody.ArkApp.fromObject(object.ArkApp);
                    }
                    if (object.GeneralFlags != null) {
                        if (typeof object.GeneralFlags !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.GeneralFlags: object expected");
                        message.GeneralFlags = $root.Msg.MsgField.ImMsgBody.GeneralFlags.fromObject(object.GeneralFlags);
                    }
                    if (object.HcFlashPic != null) {
                        if (typeof object.HcFlashPic !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.HcFlashPic: object expected");
                        message.HcFlashPic = $root.Msg.MsgField.ImMsgBody.HcFlashPic.fromObject(object.HcFlashPic);
                    }
                    if (object.DeliverGiftMsg != null) {
                        if (typeof object.DeliverGiftMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.DeliverGiftMsg: object expected");
                        message.DeliverGiftMsg = $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg.fromObject(object.DeliverGiftMsg);
                    }
                    if (object.BitappMsg != null) {
                        if (typeof object.BitappMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.BitappMsg: object expected");
                        message.BitappMsg = $root.Msg.MsgField.ImMsgBody.BitappMsg.fromObject(object.BitappMsg);
                    }
                    if (object.OpenQqData != null) {
                        if (typeof object.OpenQqData !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.OpenQqData: object expected");
                        message.OpenQqData = $root.Msg.MsgField.ImMsgBody.OpenQqData.fromObject(object.OpenQqData);
                    }
                    if (object.ApolloMsg != null) {
                        if (typeof object.ApolloMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.ApolloMsg: object expected");
                        message.ApolloMsg = $root.Msg.MsgField.ImMsgBody.ApolloMsg.fromObject(object.ApolloMsg);
                    }
                    if (object.GroupPubAccInfo != null) {
                        if (typeof object.GroupPubAccInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.GroupPubAccInfo: object expected");
                        message.GroupPubAccInfo = $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo.fromObject(object.GroupPubAccInfo);
                    }
                    if (object.BlessMsg != null) {
                        if (typeof object.BlessMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.BlessMsg: object expected");
                        message.BlessMsg = $root.Msg.MsgField.ImMsgBody.BlessMsg.fromObject(object.BlessMsg);
                    }
                    if (object.SrcMsg != null) {
                        if (typeof object.SrcMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.SrcMsg: object expected");
                        message.SrcMsg = $root.Msg.MsgField.ImMsgBody.SrcMsg.fromObject(object.SrcMsg);
                    }
                    if (object.LolaMsg != null) {
                        if (typeof object.LolaMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.LolaMsg: object expected");
                        message.LolaMsg = $root.Msg.MsgField.ImMsgBody.LolaMsg.fromObject(object.LolaMsg);
                    }
                    if (object.GroupBusinessMsg != null) {
                        if (typeof object.GroupBusinessMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.GroupBusinessMsg: object expected");
                        message.GroupBusinessMsg = $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg.fromObject(object.GroupBusinessMsg);
                    }
                    if (object.MsgWorkflowNotify != null) {
                        if (typeof object.MsgWorkflowNotify !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.MsgWorkflowNotify: object expected");
                        message.MsgWorkflowNotify = $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify.fromObject(object.MsgWorkflowNotify);
                    }
                    if (object.PatElem != null) {
                        if (typeof object.PatElem !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.PatElem: object expected");
                        message.PatElem = $root.Msg.MsgField.ImMsgBody.PatElem.fromObject(object.PatElem);
                    }
                    if (object.GroupPostElem != null) {
                        if (typeof object.GroupPostElem !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.GroupPostElem: object expected");
                        message.GroupPostElem = $root.Msg.MsgField.ImMsgBody.GroupPostElem.fromObject(object.GroupPostElem);
                    }
                    if (object.LightApp != null) {
                        if (typeof object.LightApp !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.LightApp: object expected");
                        message.LightApp = $root.Msg.MsgField.ImMsgBody.LightApp.fromObject(object.LightApp);
                    }
                    if (object.EimInfo != null) {
                        if (typeof object.EimInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.EimInfo: object expected");
                        message.EimInfo = $root.Msg.MsgField.ImMsgBody.EimInfo.fromObject(object.EimInfo);
                    }
                    if (object.CommonElem != null) {
                        if (typeof object.CommonElem !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.Elem.CommonElem: object expected");
                        message.CommonElem = $root.Msg.MsgField.ImMsgBody.CommonElem.fromObject(object.CommonElem);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Elem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.Elem} message Elem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Elem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Text = null;
                        object.Face = null;
                        object.OnlineImage = null;
                        object.NotOnlineImage = null;
                        object.TransElemInfo = null;
                        object.MarketFace = null;
                        object.ElemFlags = null;
                        object.CustomFace = null;
                        object.ElemFlags2 = null;
                        object.FunFace = null;
                        object.SecretFileMsg = null;
                        object.RichMsg = null;
                        object.GroupFile = null;
                        object.PubGroup = null;
                        object.MarketTrans = null;
                        object.ExtraInfo = null;
                        object.ShakeWindow = null;
                        object.PubAccount = null;
                        object.VideoFile = null;
                        object.TipsInfo = null;
                        object.AnonGroupMsg = null;
                        object.QqLiveOld = null;
                        object.LifeOnline = null;
                        object.QQWalletMsg = null;
                        object.CrmElem = null;
                        object.ConferenceTipsInfo = null;
                        object.RedbagInfo = null;
                        object.LowVersionTips = null;
                        if (options.bytes === String)
                            object.BankcodeCtrlInfo = "";
                        else {
                            object.BankcodeCtrlInfo = [];
                            if (options.bytes !== Array)
                                object.BankcodeCtrlInfo = $util.newBuffer(object.BankcodeCtrlInfo);
                        }
                        object.NearByMsg = null;
                        object.CustomElem = null;
                        object.LocationInfo = null;
                        object.PubAccInfo = null;
                        object.SmallEmoji = null;
                        object.FsjMsgElem = null;
                        object.ArkApp = null;
                        object.GeneralFlags = null;
                        object.HcFlashPic = null;
                        object.DeliverGiftMsg = null;
                        object.BitappMsg = null;
                        object.OpenQqData = null;
                        object.ApolloMsg = null;
                        object.GroupPubAccInfo = null;
                        object.BlessMsg = null;
                        object.SrcMsg = null;
                        object.LolaMsg = null;
                        object.GroupBusinessMsg = null;
                        object.MsgWorkflowNotify = null;
                        object.PatElem = null;
                        object.GroupPostElem = null;
                        object.LightApp = null;
                        object.EimInfo = null;
                        object.CommonElem = null;
                    }
                    if (message.Text != null && message.hasOwnProperty("Text"))
                        object.Text = $root.Msg.MsgField.ImMsgBody.Text.toObject(message.Text, options);
                    if (message.Face != null && message.hasOwnProperty("Face"))
                        object.Face = $root.Msg.MsgField.ImMsgBody.Face.toObject(message.Face, options);
                    if (message.OnlineImage != null && message.hasOwnProperty("OnlineImage"))
                        object.OnlineImage = $root.Msg.MsgField.ImMsgBody.OnlineImage.toObject(message.OnlineImage, options);
                    if (message.NotOnlineImage != null && message.hasOwnProperty("NotOnlineImage"))
                        object.NotOnlineImage = $root.Msg.MsgField.ImMsgBody.NotOnlineImage.toObject(message.NotOnlineImage, options);
                    if (message.TransElemInfo != null && message.hasOwnProperty("TransElemInfo"))
                        object.TransElemInfo = $root.Msg.MsgField.ImMsgBody.TransElemInfo.toObject(message.TransElemInfo, options);
                    if (message.MarketFace != null && message.hasOwnProperty("MarketFace"))
                        object.MarketFace = $root.Msg.MsgField.ImMsgBody.MarketFace.toObject(message.MarketFace, options);
                    if (message.ElemFlags != null && message.hasOwnProperty("ElemFlags"))
                        object.ElemFlags = $root.Msg.MsgField.ImMsgBody.ElemFlags.toObject(message.ElemFlags, options);
                    if (message.CustomFace != null && message.hasOwnProperty("CustomFace"))
                        object.CustomFace = $root.Msg.MsgField.ImMsgBody.CustomFace.toObject(message.CustomFace, options);
                    if (message.ElemFlags2 != null && message.hasOwnProperty("ElemFlags2"))
                        object.ElemFlags2 = $root.Msg.MsgField.ImMsgBody.ElemFlags2.toObject(message.ElemFlags2, options);
                    if (message.FunFace != null && message.hasOwnProperty("FunFace"))
                        object.FunFace = $root.Msg.MsgField.ImMsgBody.FunFace.toObject(message.FunFace, options);
                    if (message.SecretFileMsg != null && message.hasOwnProperty("SecretFileMsg"))
                        object.SecretFileMsg = $root.Msg.MsgField.ImMsgBody.SecretFileMsg.toObject(message.SecretFileMsg, options);
                    if (message.RichMsg != null && message.hasOwnProperty("RichMsg"))
                        object.RichMsg = $root.Msg.MsgField.ImMsgBody.RichMsg.toObject(message.RichMsg, options);
                    if (message.GroupFile != null && message.hasOwnProperty("GroupFile"))
                        object.GroupFile = $root.Msg.MsgField.ImMsgBody.GroupFile.toObject(message.GroupFile, options);
                    if (message.PubGroup != null && message.hasOwnProperty("PubGroup"))
                        object.PubGroup = $root.Msg.MsgField.ImMsgBody.PubGroup.toObject(message.PubGroup, options);
                    if (message.MarketTrans != null && message.hasOwnProperty("MarketTrans"))
                        object.MarketTrans = $root.Msg.MsgField.ImMsgBody.MarketTrans.toObject(message.MarketTrans, options);
                    if (message.ExtraInfo != null && message.hasOwnProperty("ExtraInfo"))
                        object.ExtraInfo = $root.Msg.MsgField.ImMsgBody.ExtraInfo.toObject(message.ExtraInfo, options);
                    if (message.ShakeWindow != null && message.hasOwnProperty("ShakeWindow"))
                        object.ShakeWindow = $root.Msg.MsgField.ImMsgBody.ShakeWindow.toObject(message.ShakeWindow, options);
                    if (message.PubAccount != null && message.hasOwnProperty("PubAccount"))
                        object.PubAccount = $root.Msg.MsgField.ImMsgBody.PubAccount.toObject(message.PubAccount, options);
                    if (message.VideoFile != null && message.hasOwnProperty("VideoFile"))
                        object.VideoFile = $root.Msg.MsgField.ImMsgBody.VideoFile.toObject(message.VideoFile, options);
                    if (message.TipsInfo != null && message.hasOwnProperty("TipsInfo"))
                        object.TipsInfo = $root.Msg.MsgField.ImMsgBody.TipsInfo.toObject(message.TipsInfo, options);
                    if (message.AnonGroupMsg != null && message.hasOwnProperty("AnonGroupMsg"))
                        object.AnonGroupMsg = $root.Msg.MsgField.ImMsgBody.AnonGroupMsg.toObject(message.AnonGroupMsg, options);
                    if (message.QqLiveOld != null && message.hasOwnProperty("QqLiveOld"))
                        object.QqLiveOld = $root.Msg.MsgField.ImMsgBody.QqLiveOld.toObject(message.QqLiveOld, options);
                    if (message.LifeOnline != null && message.hasOwnProperty("LifeOnline"))
                        object.LifeOnline = $root.Msg.MsgField.ImMsgBody.LifeOnline.toObject(message.LifeOnline, options);
                    if (message.QQWalletMsg != null && message.hasOwnProperty("QQWalletMsg"))
                        object.QQWalletMsg = $root.Msg.MsgField.ImMsgBody.QQWalletMsg.toObject(message.QQWalletMsg, options);
                    if (message.CrmElem != null && message.hasOwnProperty("CrmElem"))
                        object.CrmElem = $root.Msg.MsgField.ImMsgBody.CrmElem.toObject(message.CrmElem, options);
                    if (message.ConferenceTipsInfo != null && message.hasOwnProperty("ConferenceTipsInfo"))
                        object.ConferenceTipsInfo = $root.Msg.MsgField.ImMsgBody.ConferenceTipsInfo.toObject(message.ConferenceTipsInfo, options);
                    if (message.RedbagInfo != null && message.hasOwnProperty("RedbagInfo"))
                        object.RedbagInfo = $root.Msg.MsgField.ImMsgBody.RedbagInfo.toObject(message.RedbagInfo, options);
                    if (message.LowVersionTips != null && message.hasOwnProperty("LowVersionTips"))
                        object.LowVersionTips = $root.Msg.MsgField.ImMsgBody.LowVersionTips.toObject(message.LowVersionTips, options);
                    if (message.BankcodeCtrlInfo != null && message.hasOwnProperty("BankcodeCtrlInfo"))
                        object.BankcodeCtrlInfo = options.bytes === String ? $util.base64.encode(message.BankcodeCtrlInfo, 0, message.BankcodeCtrlInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.BankcodeCtrlInfo) : message.BankcodeCtrlInfo;
                    if (message.NearByMsg != null && message.hasOwnProperty("NearByMsg"))
                        object.NearByMsg = $root.Msg.MsgField.ImMsgBody.NearByMsg.toObject(message.NearByMsg, options);
                    if (message.CustomElem != null && message.hasOwnProperty("CustomElem"))
                        object.CustomElem = $root.Msg.MsgField.ImMsgBody.CustomElem.toObject(message.CustomElem, options);
                    if (message.LocationInfo != null && message.hasOwnProperty("LocationInfo"))
                        object.LocationInfo = $root.Msg.MsgField.ImMsgBody.LocationInfo.toObject(message.LocationInfo, options);
                    if (message.PubAccInfo != null && message.hasOwnProperty("PubAccInfo"))
                        object.PubAccInfo = $root.Msg.MsgField.ImMsgBody.PubAccInfo.toObject(message.PubAccInfo, options);
                    if (message.SmallEmoji != null && message.hasOwnProperty("SmallEmoji"))
                        object.SmallEmoji = $root.Msg.MsgField.ImMsgBody.SmallEmoji.toObject(message.SmallEmoji, options);
                    if (message.FsjMsgElem != null && message.hasOwnProperty("FsjMsgElem"))
                        object.FsjMsgElem = $root.Msg.MsgField.ImMsgBody.FsjMsgElem.toObject(message.FsjMsgElem, options);
                    if (message.ArkApp != null && message.hasOwnProperty("ArkApp"))
                        object.ArkApp = $root.Msg.MsgField.ImMsgBody.ArkApp.toObject(message.ArkApp, options);
                    if (message.GeneralFlags != null && message.hasOwnProperty("GeneralFlags"))
                        object.GeneralFlags = $root.Msg.MsgField.ImMsgBody.GeneralFlags.toObject(message.GeneralFlags, options);
                    if (message.HcFlashPic != null && message.hasOwnProperty("HcFlashPic"))
                        object.HcFlashPic = $root.Msg.MsgField.ImMsgBody.HcFlashPic.toObject(message.HcFlashPic, options);
                    if (message.DeliverGiftMsg != null && message.hasOwnProperty("DeliverGiftMsg"))
                        object.DeliverGiftMsg = $root.Msg.MsgField.ImMsgBody.DeliverGiftMsg.toObject(message.DeliverGiftMsg, options);
                    if (message.BitappMsg != null && message.hasOwnProperty("BitappMsg"))
                        object.BitappMsg = $root.Msg.MsgField.ImMsgBody.BitappMsg.toObject(message.BitappMsg, options);
                    if (message.OpenQqData != null && message.hasOwnProperty("OpenQqData"))
                        object.OpenQqData = $root.Msg.MsgField.ImMsgBody.OpenQqData.toObject(message.OpenQqData, options);
                    if (message.ApolloMsg != null && message.hasOwnProperty("ApolloMsg"))
                        object.ApolloMsg = $root.Msg.MsgField.ImMsgBody.ApolloMsg.toObject(message.ApolloMsg, options);
                    if (message.GroupPubAccInfo != null && message.hasOwnProperty("GroupPubAccInfo"))
                        object.GroupPubAccInfo = $root.Msg.MsgField.ImMsgBody.GroupPubAccInfo.toObject(message.GroupPubAccInfo, options);
                    if (message.BlessMsg != null && message.hasOwnProperty("BlessMsg"))
                        object.BlessMsg = $root.Msg.MsgField.ImMsgBody.BlessMsg.toObject(message.BlessMsg, options);
                    if (message.SrcMsg != null && message.hasOwnProperty("SrcMsg"))
                        object.SrcMsg = $root.Msg.MsgField.ImMsgBody.SrcMsg.toObject(message.SrcMsg, options);
                    if (message.LolaMsg != null && message.hasOwnProperty("LolaMsg"))
                        object.LolaMsg = $root.Msg.MsgField.ImMsgBody.LolaMsg.toObject(message.LolaMsg, options);
                    if (message.GroupBusinessMsg != null && message.hasOwnProperty("GroupBusinessMsg"))
                        object.GroupBusinessMsg = $root.Msg.MsgField.ImMsgBody.GroupBusinessMsg.toObject(message.GroupBusinessMsg, options);
                    if (message.MsgWorkflowNotify != null && message.hasOwnProperty("MsgWorkflowNotify"))
                        object.MsgWorkflowNotify = $root.Msg.MsgField.ImMsgBody.MsgWorkflowNotify.toObject(message.MsgWorkflowNotify, options);
                    if (message.PatElem != null && message.hasOwnProperty("PatElem"))
                        object.PatElem = $root.Msg.MsgField.ImMsgBody.PatElem.toObject(message.PatElem, options);
                    if (message.GroupPostElem != null && message.hasOwnProperty("GroupPostElem"))
                        object.GroupPostElem = $root.Msg.MsgField.ImMsgBody.GroupPostElem.toObject(message.GroupPostElem, options);
                    if (message.LightApp != null && message.hasOwnProperty("LightApp"))
                        object.LightApp = $root.Msg.MsgField.ImMsgBody.LightApp.toObject(message.LightApp, options);
                    if (message.EimInfo != null && message.hasOwnProperty("EimInfo"))
                        object.EimInfo = $root.Msg.MsgField.ImMsgBody.EimInfo.toObject(message.EimInfo, options);
                    if (message.CommonElem != null && message.hasOwnProperty("CommonElem"))
                        object.CommonElem = $root.Msg.MsgField.ImMsgBody.CommonElem.toObject(message.CommonElem, options);
                    return object;
                };

                /**
                 * Converts this Elem to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.Elem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Elem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Elem;
            })();

            ImMsgBody.RichText = (function() {

                /**
                 * Properties of a RichText.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IRichText
                 * @property {Msg.MsgField.ImMsgBody.IAttribute|null} [Attribute] RichText Attribute
                 * @property {Array.<Msg.MsgField.ImMsgBody.IElem>|null} [MutableList] RichText MutableList
                 * @property {Msg.MsgField.ImMsgBody.INotOnlineFile|null} [NotOnlineFile] RichText NotOnlineFile
                 * @property {Msg.MsgField.ImMsgBody.IPtt|null} [Ptt] RichText Ptt
                 * @property {Msg.MsgField.ImMsgBody.ITmpPtt|null} [TmpPtt] RichText TmpPtt
                 * @property {Msg.MsgField.ImMsgBody.ITrans211TmpMsg|null} [Trans211TmpMsg] RichText Trans211TmpMsg
                 */

                /**
                 * Constructs a new RichText.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a RichText.
                 * @implements IRichText
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IRichText=} [properties] Properties to set
                 */
                function RichText(properties) {
                    this.MutableList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RichText Attribute.
                 * @member {Msg.MsgField.ImMsgBody.IAttribute|null|undefined} Attribute
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @instance
                 */
                RichText.prototype.Attribute = null;

                /**
                 * RichText MutableList.
                 * @member {Array.<Msg.MsgField.ImMsgBody.IElem>} MutableList
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @instance
                 */
                RichText.prototype.MutableList = $util.emptyArray;

                /**
                 * RichText NotOnlineFile.
                 * @member {Msg.MsgField.ImMsgBody.INotOnlineFile|null|undefined} NotOnlineFile
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @instance
                 */
                RichText.prototype.NotOnlineFile = null;

                /**
                 * RichText Ptt.
                 * @member {Msg.MsgField.ImMsgBody.IPtt|null|undefined} Ptt
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @instance
                 */
                RichText.prototype.Ptt = null;

                /**
                 * RichText TmpPtt.
                 * @member {Msg.MsgField.ImMsgBody.ITmpPtt|null|undefined} TmpPtt
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @instance
                 */
                RichText.prototype.TmpPtt = null;

                /**
                 * RichText Trans211TmpMsg.
                 * @member {Msg.MsgField.ImMsgBody.ITrans211TmpMsg|null|undefined} Trans211TmpMsg
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @instance
                 */
                RichText.prototype.Trans211TmpMsg = null;

                /**
                 * Creates a new RichText instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRichText=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.RichText} RichText instance
                 */
                RichText.create = function create(properties) {
                    return new RichText(properties);
                };

                /**
                 * Encodes the specified RichText message. Does not implicitly {@link Msg.MsgField.ImMsgBody.RichText.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRichText} message RichText message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichText.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Attribute != null && Object.hasOwnProperty.call(message, "Attribute"))
                        $root.Msg.MsgField.ImMsgBody.Attribute.encode(message.Attribute, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.MutableList != null && message.MutableList.length)
                        for (var i = 0; i < message.MutableList.length; ++i)
                            $root.Msg.MsgField.ImMsgBody.Elem.encode(message.MutableList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.NotOnlineFile != null && Object.hasOwnProperty.call(message, "NotOnlineFile"))
                        $root.Msg.MsgField.ImMsgBody.NotOnlineFile.encode(message.NotOnlineFile, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.Ptt != null && Object.hasOwnProperty.call(message, "Ptt"))
                        $root.Msg.MsgField.ImMsgBody.Ptt.encode(message.Ptt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.TmpPtt != null && Object.hasOwnProperty.call(message, "TmpPtt"))
                        $root.Msg.MsgField.ImMsgBody.TmpPtt.encode(message.TmpPtt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.Trans211TmpMsg != null && Object.hasOwnProperty.call(message, "Trans211TmpMsg"))
                        $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg.encode(message.Trans211TmpMsg, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RichText message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.RichText.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IRichText} message RichText message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RichText.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RichText message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.RichText} RichText
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichText.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.RichText();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Attribute = $root.Msg.MsgField.ImMsgBody.Attribute.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.MutableList && message.MutableList.length))
                                message.MutableList = [];
                            message.MutableList.push($root.Msg.MsgField.ImMsgBody.Elem.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.NotOnlineFile = $root.Msg.MsgField.ImMsgBody.NotOnlineFile.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.Ptt = $root.Msg.MsgField.ImMsgBody.Ptt.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.TmpPtt = $root.Msg.MsgField.ImMsgBody.TmpPtt.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.Trans211TmpMsg = $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RichText message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.RichText} RichText
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RichText.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RichText message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RichText.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Attribute != null && message.hasOwnProperty("Attribute")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Attribute.verify(message.Attribute);
                        if (error)
                            return "Attribute." + error;
                    }
                    if (message.MutableList != null && message.hasOwnProperty("MutableList")) {
                        if (!Array.isArray(message.MutableList))
                            return "MutableList: array expected";
                        for (var i = 0; i < message.MutableList.length; ++i) {
                            var error = $root.Msg.MsgField.ImMsgBody.Elem.verify(message.MutableList[i]);
                            if (error)
                                return "MutableList." + error;
                        }
                    }
                    if (message.NotOnlineFile != null && message.hasOwnProperty("NotOnlineFile")) {
                        var error = $root.Msg.MsgField.ImMsgBody.NotOnlineFile.verify(message.NotOnlineFile);
                        if (error)
                            return "NotOnlineFile." + error;
                    }
                    if (message.Ptt != null && message.hasOwnProperty("Ptt")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Ptt.verify(message.Ptt);
                        if (error)
                            return "Ptt." + error;
                    }
                    if (message.TmpPtt != null && message.hasOwnProperty("TmpPtt")) {
                        var error = $root.Msg.MsgField.ImMsgBody.TmpPtt.verify(message.TmpPtt);
                        if (error)
                            return "TmpPtt." + error;
                    }
                    if (message.Trans211TmpMsg != null && message.hasOwnProperty("Trans211TmpMsg")) {
                        var error = $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg.verify(message.Trans211TmpMsg);
                        if (error)
                            return "Trans211TmpMsg." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RichText message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.RichText} RichText
                 */
                RichText.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.RichText)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.RichText();
                    if (object.Attribute != null) {
                        if (typeof object.Attribute !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.RichText.Attribute: object expected");
                        message.Attribute = $root.Msg.MsgField.ImMsgBody.Attribute.fromObject(object.Attribute);
                    }
                    if (object.MutableList) {
                        if (!Array.isArray(object.MutableList))
                            throw TypeError(".Msg.MsgField.ImMsgBody.RichText.MutableList: array expected");
                        message.MutableList = [];
                        for (var i = 0; i < object.MutableList.length; ++i) {
                            if (typeof object.MutableList[i] !== "object")
                                throw TypeError(".Msg.MsgField.ImMsgBody.RichText.MutableList: object expected");
                            message.MutableList[i] = $root.Msg.MsgField.ImMsgBody.Elem.fromObject(object.MutableList[i]);
                        }
                    }
                    if (object.NotOnlineFile != null) {
                        if (typeof object.NotOnlineFile !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.RichText.NotOnlineFile: object expected");
                        message.NotOnlineFile = $root.Msg.MsgField.ImMsgBody.NotOnlineFile.fromObject(object.NotOnlineFile);
                    }
                    if (object.Ptt != null) {
                        if (typeof object.Ptt !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.RichText.Ptt: object expected");
                        message.Ptt = $root.Msg.MsgField.ImMsgBody.Ptt.fromObject(object.Ptt);
                    }
                    if (object.TmpPtt != null) {
                        if (typeof object.TmpPtt !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.RichText.TmpPtt: object expected");
                        message.TmpPtt = $root.Msg.MsgField.ImMsgBody.TmpPtt.fromObject(object.TmpPtt);
                    }
                    if (object.Trans211TmpMsg != null) {
                        if (typeof object.Trans211TmpMsg !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.RichText.Trans211TmpMsg: object expected");
                        message.Trans211TmpMsg = $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg.fromObject(object.Trans211TmpMsg);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RichText message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.RichText} message RichText
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RichText.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.MutableList = [];
                    if (options.defaults) {
                        object.Attribute = null;
                        object.NotOnlineFile = null;
                        object.Ptt = null;
                        object.TmpPtt = null;
                        object.Trans211TmpMsg = null;
                    }
                    if (message.Attribute != null && message.hasOwnProperty("Attribute"))
                        object.Attribute = $root.Msg.MsgField.ImMsgBody.Attribute.toObject(message.Attribute, options);
                    if (message.MutableList && message.MutableList.length) {
                        object.MutableList = [];
                        for (var j = 0; j < message.MutableList.length; ++j)
                            object.MutableList[j] = $root.Msg.MsgField.ImMsgBody.Elem.toObject(message.MutableList[j], options);
                    }
                    if (message.NotOnlineFile != null && message.hasOwnProperty("NotOnlineFile"))
                        object.NotOnlineFile = $root.Msg.MsgField.ImMsgBody.NotOnlineFile.toObject(message.NotOnlineFile, options);
                    if (message.Ptt != null && message.hasOwnProperty("Ptt"))
                        object.Ptt = $root.Msg.MsgField.ImMsgBody.Ptt.toObject(message.Ptt, options);
                    if (message.TmpPtt != null && message.hasOwnProperty("TmpPtt"))
                        object.TmpPtt = $root.Msg.MsgField.ImMsgBody.TmpPtt.toObject(message.TmpPtt, options);
                    if (message.Trans211TmpMsg != null && message.hasOwnProperty("Trans211TmpMsg"))
                        object.Trans211TmpMsg = $root.Msg.MsgField.ImMsgBody.Trans211TmpMsg.toObject(message.Trans211TmpMsg, options);
                    return object;
                };

                /**
                 * Converts this RichText to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.RichText
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RichText.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RichText;
            })();

            ImMsgBody.MsgBody = (function() {

                /**
                 * Properties of a MsgBody.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @interface IMsgBody
                 * @property {Msg.MsgField.ImMsgBody.IRichText|null} [RichText] MsgBody RichText
                 * @property {Uint8Array|null} [MsgContent] MsgBody MsgContent
                 * @property {Uint8Array|null} [MsgEncryptContent] MsgBody MsgEncryptContent
                 */

                /**
                 * Constructs a new MsgBody.
                 * @memberof Msg.MsgField.ImMsgBody
                 * @classdesc Represents a MsgBody.
                 * @implements IMsgBody
                 * @constructor
                 * @param {Msg.MsgField.ImMsgBody.IMsgBody=} [properties] Properties to set
                 */
                function MsgBody(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgBody RichText.
                 * @member {Msg.MsgField.ImMsgBody.IRichText|null|undefined} RichText
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @instance
                 */
                MsgBody.prototype.RichText = null;

                /**
                 * MsgBody MsgContent.
                 * @member {Uint8Array} MsgContent
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @instance
                 */
                MsgBody.prototype.MsgContent = $util.newBuffer([]);

                /**
                 * MsgBody MsgEncryptContent.
                 * @member {Uint8Array} MsgEncryptContent
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @instance
                 */
                MsgBody.prototype.MsgEncryptContent = $util.newBuffer([]);

                /**
                 * Creates a new MsgBody instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMsgBody=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgBody.MsgBody} MsgBody instance
                 */
                MsgBody.create = function create(properties) {
                    return new MsgBody(properties);
                };

                /**
                 * Encodes the specified MsgBody message. Does not implicitly {@link Msg.MsgField.ImMsgBody.MsgBody.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMsgBody} message MsgBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBody.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.RichText != null && Object.hasOwnProperty.call(message, "RichText"))
                        $root.Msg.MsgField.ImMsgBody.RichText.encode(message.RichText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.MsgContent != null && Object.hasOwnProperty.call(message, "MsgContent"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.MsgContent);
                    if (message.MsgEncryptContent != null && Object.hasOwnProperty.call(message, "MsgEncryptContent"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.MsgEncryptContent);
                    return writer;
                };

                /**
                 * Encodes the specified MsgBody message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgBody.MsgBody.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.IMsgBody} message MsgBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBody.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgBody message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgBody.MsgBody} MsgBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBody.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgBody.MsgBody();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.RichText = $root.Msg.MsgField.ImMsgBody.RichText.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.MsgContent = reader.bytes();
                            break;
                        case 3:
                            message.MsgEncryptContent = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgBody message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgBody.MsgBody} MsgBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBody.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgBody message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgBody.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.RichText != null && message.hasOwnProperty("RichText")) {
                        var error = $root.Msg.MsgField.ImMsgBody.RichText.verify(message.RichText);
                        if (error)
                            return "RichText." + error;
                    }
                    if (message.MsgContent != null && message.hasOwnProperty("MsgContent"))
                        if (!(message.MsgContent && typeof message.MsgContent.length === "number" || $util.isString(message.MsgContent)))
                            return "MsgContent: buffer expected";
                    if (message.MsgEncryptContent != null && message.hasOwnProperty("MsgEncryptContent"))
                        if (!(message.MsgEncryptContent && typeof message.MsgEncryptContent.length === "number" || $util.isString(message.MsgEncryptContent)))
                            return "MsgEncryptContent: buffer expected";
                    return null;
                };

                /**
                 * Creates a MsgBody message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgBody.MsgBody} MsgBody
                 */
                MsgBody.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgBody.MsgBody)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgBody.MsgBody();
                    if (object.RichText != null) {
                        if (typeof object.RichText !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgBody.MsgBody.RichText: object expected");
                        message.RichText = $root.Msg.MsgField.ImMsgBody.RichText.fromObject(object.RichText);
                    }
                    if (object.MsgContent != null)
                        if (typeof object.MsgContent === "string")
                            $util.base64.decode(object.MsgContent, message.MsgContent = $util.newBuffer($util.base64.length(object.MsgContent)), 0);
                        else if (object.MsgContent.length)
                            message.MsgContent = object.MsgContent;
                    if (object.MsgEncryptContent != null)
                        if (typeof object.MsgEncryptContent === "string")
                            $util.base64.decode(object.MsgEncryptContent, message.MsgEncryptContent = $util.newBuffer($util.base64.length(object.MsgEncryptContent)), 0);
                        else if (object.MsgEncryptContent.length)
                            message.MsgEncryptContent = object.MsgEncryptContent;
                    return message;
                };

                /**
                 * Creates a plain object from a MsgBody message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @static
                 * @param {Msg.MsgField.ImMsgBody.MsgBody} message MsgBody
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgBody.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.RichText = null;
                        if (options.bytes === String)
                            object.MsgContent = "";
                        else {
                            object.MsgContent = [];
                            if (options.bytes !== Array)
                                object.MsgContent = $util.newBuffer(object.MsgContent);
                        }
                        if (options.bytes === String)
                            object.MsgEncryptContent = "";
                        else {
                            object.MsgEncryptContent = [];
                            if (options.bytes !== Array)
                                object.MsgEncryptContent = $util.newBuffer(object.MsgEncryptContent);
                        }
                    }
                    if (message.RichText != null && message.hasOwnProperty("RichText"))
                        object.RichText = $root.Msg.MsgField.ImMsgBody.RichText.toObject(message.RichText, options);
                    if (message.MsgContent != null && message.hasOwnProperty("MsgContent"))
                        object.MsgContent = options.bytes === String ? $util.base64.encode(message.MsgContent, 0, message.MsgContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.MsgContent) : message.MsgContent;
                    if (message.MsgEncryptContent != null && message.hasOwnProperty("MsgEncryptContent"))
                        object.MsgEncryptContent = options.bytes === String ? $util.base64.encode(message.MsgEncryptContent, 0, message.MsgEncryptContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.MsgEncryptContent) : message.MsgEncryptContent;
                    return object;
                };

                /**
                 * Converts this MsgBody to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgBody.MsgBody
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgBody.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MsgBody;
            })();

            return ImMsgBody;
        })();

        MsgField.ImMsgHead = (function() {

            /**
             * Properties of an ImMsgHead.
             * @memberof Msg.MsgField
             * @interface IImMsgHead
             */

            /**
             * Constructs a new ImMsgHead.
             * @memberof Msg.MsgField
             * @classdesc Represents an ImMsgHead.
             * @implements IImMsgHead
             * @constructor
             * @param {Msg.MsgField.IImMsgHead=} [properties] Properties to set
             */
            function ImMsgHead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ImMsgHead instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {Msg.MsgField.IImMsgHead=} [properties] Properties to set
             * @returns {Msg.MsgField.ImMsgHead} ImMsgHead instance
             */
            ImMsgHead.create = function create(properties) {
                return new ImMsgHead(properties);
            };

            /**
             * Encodes the specified ImMsgHead message. Does not implicitly {@link Msg.MsgField.ImMsgHead.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {Msg.MsgField.IImMsgHead} message ImMsgHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImMsgHead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ImMsgHead message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgHead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {Msg.MsgField.IImMsgHead} message ImMsgHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImMsgHead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImMsgHead message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.ImMsgHead} ImMsgHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImMsgHead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgHead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImMsgHead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.ImMsgHead} ImMsgHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImMsgHead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImMsgHead message.
             * @function verify
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImMsgHead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ImMsgHead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.ImMsgHead} ImMsgHead
             */
            ImMsgHead.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.ImMsgHead)
                    return object;
                return new $root.Msg.MsgField.ImMsgHead();
            };

            /**
             * Creates a plain object from an ImMsgHead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.ImMsgHead
             * @static
             * @param {Msg.MsgField.ImMsgHead} message ImMsgHead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImMsgHead.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ImMsgHead to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.ImMsgHead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImMsgHead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ImMsgHead.InstInfo = (function() {

                /**
                 * Properties of an InstInfo.
                 * @memberof Msg.MsgField.ImMsgHead
                 * @interface IInstInfo
                 * @property {number|null} [Appid] InstInfo Appid
                 * @property {number|null} [Instid] InstInfo Instid
                 * @property {number|null} [Platform] InstInfo Platform
                 * @property {number|null} [EnumDeviceType] InstInfo EnumDeviceType
                 */

                /**
                 * Constructs a new InstInfo.
                 * @memberof Msg.MsgField.ImMsgHead
                 * @classdesc Represents an InstInfo.
                 * @implements IInstInfo
                 * @constructor
                 * @param {Msg.MsgField.ImMsgHead.IInstInfo=} [properties] Properties to set
                 */
                function InstInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InstInfo Appid.
                 * @member {number} Appid
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @instance
                 */
                InstInfo.prototype.Appid = 0;

                /**
                 * InstInfo Instid.
                 * @member {number} Instid
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @instance
                 */
                InstInfo.prototype.Instid = 0;

                /**
                 * InstInfo Platform.
                 * @member {number} Platform
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @instance
                 */
                InstInfo.prototype.Platform = 0;

                /**
                 * InstInfo EnumDeviceType.
                 * @member {number} EnumDeviceType
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @instance
                 */
                InstInfo.prototype.EnumDeviceType = 0;

                /**
                 * Creates a new InstInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.IInstInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgHead.InstInfo} InstInfo instance
                 */
                InstInfo.create = function create(properties) {
                    return new InstInfo(properties);
                };

                /**
                 * Encodes the specified InstInfo message. Does not implicitly {@link Msg.MsgField.ImMsgHead.InstInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.IInstInfo} message InstInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Appid != null && Object.hasOwnProperty.call(message, "Appid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Appid);
                    if (message.Instid != null && Object.hasOwnProperty.call(message, "Instid"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Instid);
                    if (message.Platform != null && Object.hasOwnProperty.call(message, "Platform"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Platform);
                    if (message.EnumDeviceType != null && Object.hasOwnProperty.call(message, "EnumDeviceType"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.EnumDeviceType);
                    return writer;
                };

                /**
                 * Encodes the specified InstInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgHead.InstInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.IInstInfo} message InstInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InstInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgHead.InstInfo} InstInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgHead.InstInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Appid = reader.int32();
                            break;
                        case 2:
                            message.Instid = reader.int32();
                            break;
                        case 3:
                            message.Platform = reader.int32();
                            break;
                        case 10:
                            message.EnumDeviceType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InstInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgHead.InstInfo} InstInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InstInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InstInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Appid != null && message.hasOwnProperty("Appid"))
                        if (!$util.isInteger(message.Appid))
                            return "Appid: integer expected";
                    if (message.Instid != null && message.hasOwnProperty("Instid"))
                        if (!$util.isInteger(message.Instid))
                            return "Instid: integer expected";
                    if (message.Platform != null && message.hasOwnProperty("Platform"))
                        if (!$util.isInteger(message.Platform))
                            return "Platform: integer expected";
                    if (message.EnumDeviceType != null && message.hasOwnProperty("EnumDeviceType"))
                        if (!$util.isInteger(message.EnumDeviceType))
                            return "EnumDeviceType: integer expected";
                    return null;
                };

                /**
                 * Creates an InstInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgHead.InstInfo} InstInfo
                 */
                InstInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgHead.InstInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgHead.InstInfo();
                    if (object.Appid != null)
                        message.Appid = object.Appid | 0;
                    if (object.Instid != null)
                        message.Instid = object.Instid | 0;
                    if (object.Platform != null)
                        message.Platform = object.Platform | 0;
                    if (object.EnumDeviceType != null)
                        message.EnumDeviceType = object.EnumDeviceType | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an InstInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.InstInfo} message InstInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InstInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Appid = 0;
                        object.Instid = 0;
                        object.Platform = 0;
                        object.EnumDeviceType = 0;
                    }
                    if (message.Appid != null && message.hasOwnProperty("Appid"))
                        object.Appid = message.Appid;
                    if (message.Instid != null && message.hasOwnProperty("Instid"))
                        object.Instid = message.Instid;
                    if (message.Platform != null && message.hasOwnProperty("Platform"))
                        object.Platform = message.Platform;
                    if (message.EnumDeviceType != null && message.hasOwnProperty("EnumDeviceType"))
                        object.EnumDeviceType = message.EnumDeviceType;
                    return object;
                };

                /**
                 * Converts this InstInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgHead.InstInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InstInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InstInfo;
            })();

            ImMsgHead.InstCtrl = (function() {

                /**
                 * Properties of an InstCtrl.
                 * @memberof Msg.MsgField.ImMsgHead
                 * @interface IInstCtrl
                 * @property {Array.<Msg.MsgField.ImMsgHead.IInstInfo>|null} [MsgSendToInst] InstCtrl MsgSendToInst
                 * @property {Array.<Msg.MsgField.ImMsgHead.IInstInfo>|null} [MsgExcludeInst] InstCtrl MsgExcludeInst
                 * @property {Msg.MsgField.ImMsgHead.IInstInfo|null} [MsgFromInst] InstCtrl MsgFromInst
                 */

                /**
                 * Constructs a new InstCtrl.
                 * @memberof Msg.MsgField.ImMsgHead
                 * @classdesc Represents an InstCtrl.
                 * @implements IInstCtrl
                 * @constructor
                 * @param {Msg.MsgField.ImMsgHead.IInstCtrl=} [properties] Properties to set
                 */
                function InstCtrl(properties) {
                    this.MsgSendToInst = [];
                    this.MsgExcludeInst = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InstCtrl MsgSendToInst.
                 * @member {Array.<Msg.MsgField.ImMsgHead.IInstInfo>} MsgSendToInst
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @instance
                 */
                InstCtrl.prototype.MsgSendToInst = $util.emptyArray;

                /**
                 * InstCtrl MsgExcludeInst.
                 * @member {Array.<Msg.MsgField.ImMsgHead.IInstInfo>} MsgExcludeInst
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @instance
                 */
                InstCtrl.prototype.MsgExcludeInst = $util.emptyArray;

                /**
                 * InstCtrl MsgFromInst.
                 * @member {Msg.MsgField.ImMsgHead.IInstInfo|null|undefined} MsgFromInst
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @instance
                 */
                InstCtrl.prototype.MsgFromInst = null;

                /**
                 * Creates a new InstCtrl instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.IInstCtrl=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImMsgHead.InstCtrl} InstCtrl instance
                 */
                InstCtrl.create = function create(properties) {
                    return new InstCtrl(properties);
                };

                /**
                 * Encodes the specified InstCtrl message. Does not implicitly {@link Msg.MsgField.ImMsgHead.InstCtrl.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.IInstCtrl} message InstCtrl message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstCtrl.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MsgSendToInst != null && message.MsgSendToInst.length)
                        for (var i = 0; i < message.MsgSendToInst.length; ++i)
                            $root.Msg.MsgField.ImMsgHead.InstInfo.encode(message.MsgSendToInst[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.MsgExcludeInst != null && message.MsgExcludeInst.length)
                        for (var i = 0; i < message.MsgExcludeInst.length; ++i)
                            $root.Msg.MsgField.ImMsgHead.InstInfo.encode(message.MsgExcludeInst[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.MsgFromInst != null && Object.hasOwnProperty.call(message, "MsgFromInst"))
                        $root.Msg.MsgField.ImMsgHead.InstInfo.encode(message.MsgFromInst, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified InstCtrl message, length delimited. Does not implicitly {@link Msg.MsgField.ImMsgHead.InstCtrl.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.IInstCtrl} message InstCtrl message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstCtrl.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InstCtrl message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImMsgHead.InstCtrl} InstCtrl
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstCtrl.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImMsgHead.InstCtrl();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.MsgSendToInst && message.MsgSendToInst.length))
                                message.MsgSendToInst = [];
                            message.MsgSendToInst.push($root.Msg.MsgField.ImMsgHead.InstInfo.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.MsgExcludeInst && message.MsgExcludeInst.length))
                                message.MsgExcludeInst = [];
                            message.MsgExcludeInst.push($root.Msg.MsgField.ImMsgHead.InstInfo.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.MsgFromInst = $root.Msg.MsgField.ImMsgHead.InstInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InstCtrl message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImMsgHead.InstCtrl} InstCtrl
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstCtrl.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InstCtrl message.
                 * @function verify
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InstCtrl.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MsgSendToInst != null && message.hasOwnProperty("MsgSendToInst")) {
                        if (!Array.isArray(message.MsgSendToInst))
                            return "MsgSendToInst: array expected";
                        for (var i = 0; i < message.MsgSendToInst.length; ++i) {
                            var error = $root.Msg.MsgField.ImMsgHead.InstInfo.verify(message.MsgSendToInst[i]);
                            if (error)
                                return "MsgSendToInst." + error;
                        }
                    }
                    if (message.MsgExcludeInst != null && message.hasOwnProperty("MsgExcludeInst")) {
                        if (!Array.isArray(message.MsgExcludeInst))
                            return "MsgExcludeInst: array expected";
                        for (var i = 0; i < message.MsgExcludeInst.length; ++i) {
                            var error = $root.Msg.MsgField.ImMsgHead.InstInfo.verify(message.MsgExcludeInst[i]);
                            if (error)
                                return "MsgExcludeInst." + error;
                        }
                    }
                    if (message.MsgFromInst != null && message.hasOwnProperty("MsgFromInst")) {
                        var error = $root.Msg.MsgField.ImMsgHead.InstInfo.verify(message.MsgFromInst);
                        if (error)
                            return "MsgFromInst." + error;
                    }
                    return null;
                };

                /**
                 * Creates an InstCtrl message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImMsgHead.InstCtrl} InstCtrl
                 */
                InstCtrl.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImMsgHead.InstCtrl)
                        return object;
                    var message = new $root.Msg.MsgField.ImMsgHead.InstCtrl();
                    if (object.MsgSendToInst) {
                        if (!Array.isArray(object.MsgSendToInst))
                            throw TypeError(".Msg.MsgField.ImMsgHead.InstCtrl.MsgSendToInst: array expected");
                        message.MsgSendToInst = [];
                        for (var i = 0; i < object.MsgSendToInst.length; ++i) {
                            if (typeof object.MsgSendToInst[i] !== "object")
                                throw TypeError(".Msg.MsgField.ImMsgHead.InstCtrl.MsgSendToInst: object expected");
                            message.MsgSendToInst[i] = $root.Msg.MsgField.ImMsgHead.InstInfo.fromObject(object.MsgSendToInst[i]);
                        }
                    }
                    if (object.MsgExcludeInst) {
                        if (!Array.isArray(object.MsgExcludeInst))
                            throw TypeError(".Msg.MsgField.ImMsgHead.InstCtrl.MsgExcludeInst: array expected");
                        message.MsgExcludeInst = [];
                        for (var i = 0; i < object.MsgExcludeInst.length; ++i) {
                            if (typeof object.MsgExcludeInst[i] !== "object")
                                throw TypeError(".Msg.MsgField.ImMsgHead.InstCtrl.MsgExcludeInst: object expected");
                            message.MsgExcludeInst[i] = $root.Msg.MsgField.ImMsgHead.InstInfo.fromObject(object.MsgExcludeInst[i]);
                        }
                    }
                    if (object.MsgFromInst != null) {
                        if (typeof object.MsgFromInst !== "object")
                            throw TypeError(".Msg.MsgField.ImMsgHead.InstCtrl.MsgFromInst: object expected");
                        message.MsgFromInst = $root.Msg.MsgField.ImMsgHead.InstInfo.fromObject(object.MsgFromInst);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an InstCtrl message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @static
                 * @param {Msg.MsgField.ImMsgHead.InstCtrl} message InstCtrl
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InstCtrl.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.MsgSendToInst = [];
                        object.MsgExcludeInst = [];
                    }
                    if (options.defaults)
                        object.MsgFromInst = null;
                    if (message.MsgSendToInst && message.MsgSendToInst.length) {
                        object.MsgSendToInst = [];
                        for (var j = 0; j < message.MsgSendToInst.length; ++j)
                            object.MsgSendToInst[j] = $root.Msg.MsgField.ImMsgHead.InstInfo.toObject(message.MsgSendToInst[j], options);
                    }
                    if (message.MsgExcludeInst && message.MsgExcludeInst.length) {
                        object.MsgExcludeInst = [];
                        for (var j = 0; j < message.MsgExcludeInst.length; ++j)
                            object.MsgExcludeInst[j] = $root.Msg.MsgField.ImMsgHead.InstInfo.toObject(message.MsgExcludeInst[j], options);
                    }
                    if (message.MsgFromInst != null && message.hasOwnProperty("MsgFromInst"))
                        object.MsgFromInst = $root.Msg.MsgField.ImMsgHead.InstInfo.toObject(message.MsgFromInst, options);
                    return object;
                };

                /**
                 * Converts this InstCtrl to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImMsgHead.InstCtrl
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InstCtrl.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InstCtrl;
            })();

            return ImMsgHead;
        })();

        MsgField.PluginInfo = (function() {

            /**
             * Properties of a PluginInfo.
             * @memberof Msg.MsgField
             * @interface IPluginInfo
             * @property {number|null} [ResId] PluginInfo ResId
             * @property {string|null} [PkgName] PluginInfo PkgName
             * @property {number|null} [NewVar] PluginInfo NewVar
             * @property {number|null} [ResType] PluginInfo ResType
             * @property {number|null} [LanType] PluginInfo LanType
             * @property {number|null} [Priority] PluginInfo Priority
             * @property {string|null} [ResName] PluginInfo ResName
             * @property {string|null} [ResDesc] PluginInfo ResDesc
             * @property {string|null} [ResUrlBig] PluginInfo ResUrlBig
             * @property {string|null} [ResUrlSmall] PluginInfo ResUrlSmall
             * @property {string|null} [ResConf] PluginInfo ResConf
             */

            /**
             * Constructs a new PluginInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents a PluginInfo.
             * @implements IPluginInfo
             * @constructor
             * @param {Msg.MsgField.IPluginInfo=} [properties] Properties to set
             */
            function PluginInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PluginInfo ResId.
             * @member {number} ResId
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.ResId = 0;

            /**
             * PluginInfo PkgName.
             * @member {string} PkgName
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.PkgName = "";

            /**
             * PluginInfo NewVar.
             * @member {number} NewVar
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.NewVar = 0;

            /**
             * PluginInfo ResType.
             * @member {number} ResType
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.ResType = 0;

            /**
             * PluginInfo LanType.
             * @member {number} LanType
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.LanType = 0;

            /**
             * PluginInfo Priority.
             * @member {number} Priority
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.Priority = 0;

            /**
             * PluginInfo ResName.
             * @member {string} ResName
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.ResName = "";

            /**
             * PluginInfo ResDesc.
             * @member {string} ResDesc
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.ResDesc = "";

            /**
             * PluginInfo ResUrlBig.
             * @member {string} ResUrlBig
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.ResUrlBig = "";

            /**
             * PluginInfo ResUrlSmall.
             * @member {string} ResUrlSmall
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.ResUrlSmall = "";

            /**
             * PluginInfo ResConf.
             * @member {string} ResConf
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             */
            PluginInfo.prototype.ResConf = "";

            /**
             * Creates a new PluginInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {Msg.MsgField.IPluginInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.PluginInfo} PluginInfo instance
             */
            PluginInfo.create = function create(properties) {
                return new PluginInfo(properties);
            };

            /**
             * Encodes the specified PluginInfo message. Does not implicitly {@link Msg.MsgField.PluginInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {Msg.MsgField.IPluginInfo} message PluginInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PluginInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ResId != null && Object.hasOwnProperty.call(message, "ResId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ResId);
                if (message.PkgName != null && Object.hasOwnProperty.call(message, "PkgName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.PkgName);
                if (message.NewVar != null && Object.hasOwnProperty.call(message, "NewVar"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.NewVar);
                if (message.ResType != null && Object.hasOwnProperty.call(message, "ResType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ResType);
                if (message.LanType != null && Object.hasOwnProperty.call(message, "LanType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.LanType);
                if (message.Priority != null && Object.hasOwnProperty.call(message, "Priority"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Priority);
                if (message.ResName != null && Object.hasOwnProperty.call(message, "ResName"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.ResName);
                if (message.ResDesc != null && Object.hasOwnProperty.call(message, "ResDesc"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.ResDesc);
                if (message.ResUrlBig != null && Object.hasOwnProperty.call(message, "ResUrlBig"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.ResUrlBig);
                if (message.ResUrlSmall != null && Object.hasOwnProperty.call(message, "ResUrlSmall"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.ResUrlSmall);
                if (message.ResConf != null && Object.hasOwnProperty.call(message, "ResConf"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.ResConf);
                return writer;
            };

            /**
             * Encodes the specified PluginInfo message, length delimited. Does not implicitly {@link Msg.MsgField.PluginInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {Msg.MsgField.IPluginInfo} message PluginInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PluginInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PluginInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.PluginInfo} PluginInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PluginInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PluginInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ResId = reader.int32();
                        break;
                    case 2:
                        message.PkgName = reader.string();
                        break;
                    case 3:
                        message.NewVar = reader.int32();
                        break;
                    case 4:
                        message.ResType = reader.int32();
                        break;
                    case 5:
                        message.LanType = reader.int32();
                        break;
                    case 6:
                        message.Priority = reader.int32();
                        break;
                    case 7:
                        message.ResName = reader.string();
                        break;
                    case 8:
                        message.ResDesc = reader.string();
                        break;
                    case 9:
                        message.ResUrlBig = reader.string();
                        break;
                    case 10:
                        message.ResUrlSmall = reader.string();
                        break;
                    case 11:
                        message.ResConf = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PluginInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.PluginInfo} PluginInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PluginInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PluginInfo message.
             * @function verify
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PluginInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ResId != null && message.hasOwnProperty("ResId"))
                    if (!$util.isInteger(message.ResId))
                        return "ResId: integer expected";
                if (message.PkgName != null && message.hasOwnProperty("PkgName"))
                    if (!$util.isString(message.PkgName))
                        return "PkgName: string expected";
                if (message.NewVar != null && message.hasOwnProperty("NewVar"))
                    if (!$util.isInteger(message.NewVar))
                        return "NewVar: integer expected";
                if (message.ResType != null && message.hasOwnProperty("ResType"))
                    if (!$util.isInteger(message.ResType))
                        return "ResType: integer expected";
                if (message.LanType != null && message.hasOwnProperty("LanType"))
                    if (!$util.isInteger(message.LanType))
                        return "LanType: integer expected";
                if (message.Priority != null && message.hasOwnProperty("Priority"))
                    if (!$util.isInteger(message.Priority))
                        return "Priority: integer expected";
                if (message.ResName != null && message.hasOwnProperty("ResName"))
                    if (!$util.isString(message.ResName))
                        return "ResName: string expected";
                if (message.ResDesc != null && message.hasOwnProperty("ResDesc"))
                    if (!$util.isString(message.ResDesc))
                        return "ResDesc: string expected";
                if (message.ResUrlBig != null && message.hasOwnProperty("ResUrlBig"))
                    if (!$util.isString(message.ResUrlBig))
                        return "ResUrlBig: string expected";
                if (message.ResUrlSmall != null && message.hasOwnProperty("ResUrlSmall"))
                    if (!$util.isString(message.ResUrlSmall))
                        return "ResUrlSmall: string expected";
                if (message.ResConf != null && message.hasOwnProperty("ResConf"))
                    if (!$util.isString(message.ResConf))
                        return "ResConf: string expected";
                return null;
            };

            /**
             * Creates a PluginInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.PluginInfo} PluginInfo
             */
            PluginInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.PluginInfo)
                    return object;
                var message = new $root.Msg.MsgField.PluginInfo();
                if (object.ResId != null)
                    message.ResId = object.ResId | 0;
                if (object.PkgName != null)
                    message.PkgName = String(object.PkgName);
                if (object.NewVar != null)
                    message.NewVar = object.NewVar | 0;
                if (object.ResType != null)
                    message.ResType = object.ResType | 0;
                if (object.LanType != null)
                    message.LanType = object.LanType | 0;
                if (object.Priority != null)
                    message.Priority = object.Priority | 0;
                if (object.ResName != null)
                    message.ResName = String(object.ResName);
                if (object.ResDesc != null)
                    message.ResDesc = String(object.ResDesc);
                if (object.ResUrlBig != null)
                    message.ResUrlBig = String(object.ResUrlBig);
                if (object.ResUrlSmall != null)
                    message.ResUrlSmall = String(object.ResUrlSmall);
                if (object.ResConf != null)
                    message.ResConf = String(object.ResConf);
                return message;
            };

            /**
             * Creates a plain object from a PluginInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.PluginInfo
             * @static
             * @param {Msg.MsgField.PluginInfo} message PluginInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PluginInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.ResId = 0;
                    object.PkgName = "";
                    object.NewVar = 0;
                    object.ResType = 0;
                    object.LanType = 0;
                    object.Priority = 0;
                    object.ResName = "";
                    object.ResDesc = "";
                    object.ResUrlBig = "";
                    object.ResUrlSmall = "";
                    object.ResConf = "";
                }
                if (message.ResId != null && message.hasOwnProperty("ResId"))
                    object.ResId = message.ResId;
                if (message.PkgName != null && message.hasOwnProperty("PkgName"))
                    object.PkgName = message.PkgName;
                if (message.NewVar != null && message.hasOwnProperty("NewVar"))
                    object.NewVar = message.NewVar;
                if (message.ResType != null && message.hasOwnProperty("ResType"))
                    object.ResType = message.ResType;
                if (message.LanType != null && message.hasOwnProperty("LanType"))
                    object.LanType = message.LanType;
                if (message.Priority != null && message.hasOwnProperty("Priority"))
                    object.Priority = message.Priority;
                if (message.ResName != null && message.hasOwnProperty("ResName"))
                    object.ResName = message.ResName;
                if (message.ResDesc != null && message.hasOwnProperty("ResDesc"))
                    object.ResDesc = message.ResDesc;
                if (message.ResUrlBig != null && message.hasOwnProperty("ResUrlBig"))
                    object.ResUrlBig = message.ResUrlBig;
                if (message.ResUrlSmall != null && message.hasOwnProperty("ResUrlSmall"))
                    object.ResUrlSmall = message.ResUrlSmall;
                if (message.ResConf != null && message.hasOwnProperty("ResConf"))
                    object.ResConf = message.ResConf;
                return object;
            };

            /**
             * Converts this PluginInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.PluginInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PluginInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PluginInfo;
        })();

        MsgField.AppShareInfo = (function() {

            /**
             * Properties of an AppShareInfo.
             * @memberof Msg.MsgField
             * @interface IAppShareInfo
             * @property {number|null} [AppshareId] AppShareInfo AppshareId
             * @property {Uint8Array|null} [AppshareCookie] AppShareInfo AppshareCookie
             * @property {Msg.MsgField.IPluginInfo|null} [AppshareResource] AppShareInfo AppshareResource
             */

            /**
             * Constructs a new AppShareInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents an AppShareInfo.
             * @implements IAppShareInfo
             * @constructor
             * @param {Msg.MsgField.IAppShareInfo=} [properties] Properties to set
             */
            function AppShareInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AppShareInfo AppshareId.
             * @member {number} AppshareId
             * @memberof Msg.MsgField.AppShareInfo
             * @instance
             */
            AppShareInfo.prototype.AppshareId = 0;

            /**
             * AppShareInfo AppshareCookie.
             * @member {Uint8Array} AppshareCookie
             * @memberof Msg.MsgField.AppShareInfo
             * @instance
             */
            AppShareInfo.prototype.AppshareCookie = $util.newBuffer([]);

            /**
             * AppShareInfo AppshareResource.
             * @member {Msg.MsgField.IPluginInfo|null|undefined} AppshareResource
             * @memberof Msg.MsgField.AppShareInfo
             * @instance
             */
            AppShareInfo.prototype.AppshareResource = null;

            /**
             * Creates a new AppShareInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {Msg.MsgField.IAppShareInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.AppShareInfo} AppShareInfo instance
             */
            AppShareInfo.create = function create(properties) {
                return new AppShareInfo(properties);
            };

            /**
             * Encodes the specified AppShareInfo message. Does not implicitly {@link Msg.MsgField.AppShareInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {Msg.MsgField.IAppShareInfo} message AppShareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppShareInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.AppshareId != null && Object.hasOwnProperty.call(message, "AppshareId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AppshareId);
                if (message.AppshareCookie != null && Object.hasOwnProperty.call(message, "AppshareCookie"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.AppshareCookie);
                if (message.AppshareResource != null && Object.hasOwnProperty.call(message, "AppshareResource"))
                    $root.Msg.MsgField.PluginInfo.encode(message.AppshareResource, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AppShareInfo message, length delimited. Does not implicitly {@link Msg.MsgField.AppShareInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {Msg.MsgField.IAppShareInfo} message AppShareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppShareInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AppShareInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.AppShareInfo} AppShareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppShareInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.AppShareInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.AppshareId = reader.int32();
                        break;
                    case 2:
                        message.AppshareCookie = reader.bytes();
                        break;
                    case 3:
                        message.AppshareResource = $root.Msg.MsgField.PluginInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AppShareInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.AppShareInfo} AppShareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppShareInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AppShareInfo message.
             * @function verify
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AppShareInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.AppshareId != null && message.hasOwnProperty("AppshareId"))
                    if (!$util.isInteger(message.AppshareId))
                        return "AppshareId: integer expected";
                if (message.AppshareCookie != null && message.hasOwnProperty("AppshareCookie"))
                    if (!(message.AppshareCookie && typeof message.AppshareCookie.length === "number" || $util.isString(message.AppshareCookie)))
                        return "AppshareCookie: buffer expected";
                if (message.AppshareResource != null && message.hasOwnProperty("AppshareResource")) {
                    var error = $root.Msg.MsgField.PluginInfo.verify(message.AppshareResource);
                    if (error)
                        return "AppshareResource." + error;
                }
                return null;
            };

            /**
             * Creates an AppShareInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.AppShareInfo} AppShareInfo
             */
            AppShareInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.AppShareInfo)
                    return object;
                var message = new $root.Msg.MsgField.AppShareInfo();
                if (object.AppshareId != null)
                    message.AppshareId = object.AppshareId | 0;
                if (object.AppshareCookie != null)
                    if (typeof object.AppshareCookie === "string")
                        $util.base64.decode(object.AppshareCookie, message.AppshareCookie = $util.newBuffer($util.base64.length(object.AppshareCookie)), 0);
                    else if (object.AppshareCookie.length)
                        message.AppshareCookie = object.AppshareCookie;
                if (object.AppshareResource != null) {
                    if (typeof object.AppshareResource !== "object")
                        throw TypeError(".Msg.MsgField.AppShareInfo.AppshareResource: object expected");
                    message.AppshareResource = $root.Msg.MsgField.PluginInfo.fromObject(object.AppshareResource);
                }
                return message;
            };

            /**
             * Creates a plain object from an AppShareInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.AppShareInfo
             * @static
             * @param {Msg.MsgField.AppShareInfo} message AppShareInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppShareInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.AppshareId = 0;
                    if (options.bytes === String)
                        object.AppshareCookie = "";
                    else {
                        object.AppshareCookie = [];
                        if (options.bytes !== Array)
                            object.AppshareCookie = $util.newBuffer(object.AppshareCookie);
                    }
                    object.AppshareResource = null;
                }
                if (message.AppshareId != null && message.hasOwnProperty("AppshareId"))
                    object.AppshareId = message.AppshareId;
                if (message.AppshareCookie != null && message.hasOwnProperty("AppshareCookie"))
                    object.AppshareCookie = options.bytes === String ? $util.base64.encode(message.AppshareCookie, 0, message.AppshareCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.AppshareCookie) : message.AppshareCookie;
                if (message.AppshareResource != null && message.hasOwnProperty("AppshareResource"))
                    object.AppshareResource = $root.Msg.MsgField.PluginInfo.toObject(message.AppshareResource, options);
                return object;
            };

            /**
             * Converts this AppShareInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.AppShareInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppShareInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AppShareInfo;
        })();

        MsgField.C2cTmpMsgHead = (function() {

            /**
             * Properties of a C2cTmpMsgHead.
             * @memberof Msg.MsgField
             * @interface IC2cTmpMsgHead
             * @property {number|null} [C2cType] C2cTmpMsgHead C2cType
             * @property {number|null} [ServiceType] C2cTmpMsgHead ServiceType
             * @property {number|Long|null} [GroupUin] C2cTmpMsgHead GroupUin
             * @property {number|Long|null} [groupCode] C2cTmpMsgHead groupCode
             * @property {Uint8Array|null} [Sig] C2cTmpMsgHead Sig
             * @property {number|null} [SigType] C2cTmpMsgHead SigType
             * @property {string|null} [FromPhone] C2cTmpMsgHead FromPhone
             * @property {string|null} [ToPhone] C2cTmpMsgHead ToPhone
             * @property {number|null} [LockDisplay] C2cTmpMsgHead LockDisplay
             * @property {number|null} [DirectionFlag] C2cTmpMsgHead DirectionFlag
             * @property {Uint8Array|null} [Reserved] C2cTmpMsgHead Reserved
             */

            /**
             * Constructs a new C2cTmpMsgHead.
             * @memberof Msg.MsgField
             * @classdesc Represents a C2cTmpMsgHead.
             * @implements IC2cTmpMsgHead
             * @constructor
             * @param {Msg.MsgField.IC2cTmpMsgHead=} [properties] Properties to set
             */
            function C2cTmpMsgHead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2cTmpMsgHead C2cType.
             * @member {number} C2cType
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.C2cType = 0;

            /**
             * C2cTmpMsgHead ServiceType.
             * @member {number} ServiceType
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.ServiceType = 0;

            /**
             * C2cTmpMsgHead GroupUin.
             * @member {number|Long} GroupUin
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.GroupUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * C2cTmpMsgHead groupCode.
             * @member {number|Long} groupCode
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.groupCode = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * C2cTmpMsgHead Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.Sig = $util.newBuffer([]);

            /**
             * C2cTmpMsgHead SigType.
             * @member {number} SigType
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.SigType = 0;

            /**
             * C2cTmpMsgHead FromPhone.
             * @member {string} FromPhone
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.FromPhone = "";

            /**
             * C2cTmpMsgHead ToPhone.
             * @member {string} ToPhone
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.ToPhone = "";

            /**
             * C2cTmpMsgHead LockDisplay.
             * @member {number} LockDisplay
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.LockDisplay = 0;

            /**
             * C2cTmpMsgHead DirectionFlag.
             * @member {number} DirectionFlag
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.DirectionFlag = 0;

            /**
             * C2cTmpMsgHead Reserved.
             * @member {Uint8Array} Reserved
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             */
            C2cTmpMsgHead.prototype.Reserved = $util.newBuffer([]);

            /**
             * Creates a new C2cTmpMsgHead instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {Msg.MsgField.IC2cTmpMsgHead=} [properties] Properties to set
             * @returns {Msg.MsgField.C2cTmpMsgHead} C2cTmpMsgHead instance
             */
            C2cTmpMsgHead.create = function create(properties) {
                return new C2cTmpMsgHead(properties);
            };

            /**
             * Encodes the specified C2cTmpMsgHead message. Does not implicitly {@link Msg.MsgField.C2cTmpMsgHead.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {Msg.MsgField.IC2cTmpMsgHead} message C2cTmpMsgHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2cTmpMsgHead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.C2cType != null && Object.hasOwnProperty.call(message, "C2cType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.C2cType);
                if (message.ServiceType != null && Object.hasOwnProperty.call(message, "ServiceType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ServiceType);
                if (message.GroupUin != null && Object.hasOwnProperty.call(message, "GroupUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GroupUin);
                if (message.groupCode != null && Object.hasOwnProperty.call(message, "groupCode"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.groupCode);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Sig);
                if (message.SigType != null && Object.hasOwnProperty.call(message, "SigType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.SigType);
                if (message.FromPhone != null && Object.hasOwnProperty.call(message, "FromPhone"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.FromPhone);
                if (message.ToPhone != null && Object.hasOwnProperty.call(message, "ToPhone"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.ToPhone);
                if (message.LockDisplay != null && Object.hasOwnProperty.call(message, "LockDisplay"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.LockDisplay);
                if (message.DirectionFlag != null && Object.hasOwnProperty.call(message, "DirectionFlag"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.DirectionFlag);
                if (message.Reserved != null && Object.hasOwnProperty.call(message, "Reserved"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Reserved);
                return writer;
            };

            /**
             * Encodes the specified C2cTmpMsgHead message, length delimited. Does not implicitly {@link Msg.MsgField.C2cTmpMsgHead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {Msg.MsgField.IC2cTmpMsgHead} message C2cTmpMsgHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2cTmpMsgHead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2cTmpMsgHead message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.C2cTmpMsgHead} C2cTmpMsgHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2cTmpMsgHead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.C2cTmpMsgHead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.C2cType = reader.int32();
                        break;
                    case 2:
                        message.ServiceType = reader.int32();
                        break;
                    case 3:
                        message.GroupUin = reader.int64();
                        break;
                    case 4:
                        message.groupCode = reader.int64();
                        break;
                    case 5:
                        message.Sig = reader.bytes();
                        break;
                    case 6:
                        message.SigType = reader.int32();
                        break;
                    case 7:
                        message.FromPhone = reader.string();
                        break;
                    case 8:
                        message.ToPhone = reader.string();
                        break;
                    case 9:
                        message.LockDisplay = reader.int32();
                        break;
                    case 10:
                        message.DirectionFlag = reader.int32();
                        break;
                    case 11:
                        message.Reserved = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a C2cTmpMsgHead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.C2cTmpMsgHead} C2cTmpMsgHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2cTmpMsgHead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2cTmpMsgHead message.
             * @function verify
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2cTmpMsgHead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.C2cType != null && message.hasOwnProperty("C2cType"))
                    if (!$util.isInteger(message.C2cType))
                        return "C2cType: integer expected";
                if (message.ServiceType != null && message.hasOwnProperty("ServiceType"))
                    if (!$util.isInteger(message.ServiceType))
                        return "ServiceType: integer expected";
                if (message.GroupUin != null && message.hasOwnProperty("GroupUin"))
                    if (!$util.isInteger(message.GroupUin) && !(message.GroupUin && $util.isInteger(message.GroupUin.low) && $util.isInteger(message.GroupUin.high)))
                        return "GroupUin: integer|Long expected";
                if (message.groupCode != null && message.hasOwnProperty("groupCode"))
                    if (!$util.isInteger(message.groupCode) && !(message.groupCode && $util.isInteger(message.groupCode.low) && $util.isInteger(message.groupCode.high)))
                        return "groupCode: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.SigType != null && message.hasOwnProperty("SigType"))
                    if (!$util.isInteger(message.SigType))
                        return "SigType: integer expected";
                if (message.FromPhone != null && message.hasOwnProperty("FromPhone"))
                    if (!$util.isString(message.FromPhone))
                        return "FromPhone: string expected";
                if (message.ToPhone != null && message.hasOwnProperty("ToPhone"))
                    if (!$util.isString(message.ToPhone))
                        return "ToPhone: string expected";
                if (message.LockDisplay != null && message.hasOwnProperty("LockDisplay"))
                    if (!$util.isInteger(message.LockDisplay))
                        return "LockDisplay: integer expected";
                if (message.DirectionFlag != null && message.hasOwnProperty("DirectionFlag"))
                    if (!$util.isInteger(message.DirectionFlag))
                        return "DirectionFlag: integer expected";
                if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                    if (!(message.Reserved && typeof message.Reserved.length === "number" || $util.isString(message.Reserved)))
                        return "Reserved: buffer expected";
                return null;
            };

            /**
             * Creates a C2cTmpMsgHead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.C2cTmpMsgHead} C2cTmpMsgHead
             */
            C2cTmpMsgHead.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.C2cTmpMsgHead)
                    return object;
                var message = new $root.Msg.MsgField.C2cTmpMsgHead();
                if (object.C2cType != null)
                    message.C2cType = object.C2cType | 0;
                if (object.ServiceType != null)
                    message.ServiceType = object.ServiceType | 0;
                if (object.GroupUin != null)
                    if ($util.Long)
                        (message.GroupUin = $util.Long.fromValue(object.GroupUin)).unsigned = false;
                    else if (typeof object.GroupUin === "string")
                        message.GroupUin = parseInt(object.GroupUin, 10);
                    else if (typeof object.GroupUin === "number")
                        message.GroupUin = object.GroupUin;
                    else if (typeof object.GroupUin === "object")
                        message.GroupUin = new $util.LongBits(object.GroupUin.low >>> 0, object.GroupUin.high >>> 0).toNumber();
                if (object.groupCode != null)
                    if ($util.Long)
                        (message.groupCode = $util.Long.fromValue(object.groupCode)).unsigned = false;
                    else if (typeof object.groupCode === "string")
                        message.groupCode = parseInt(object.groupCode, 10);
                    else if (typeof object.groupCode === "number")
                        message.groupCode = object.groupCode;
                    else if (typeof object.groupCode === "object")
                        message.groupCode = new $util.LongBits(object.groupCode.low >>> 0, object.groupCode.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.SigType != null)
                    message.SigType = object.SigType | 0;
                if (object.FromPhone != null)
                    message.FromPhone = String(object.FromPhone);
                if (object.ToPhone != null)
                    message.ToPhone = String(object.ToPhone);
                if (object.LockDisplay != null)
                    message.LockDisplay = object.LockDisplay | 0;
                if (object.DirectionFlag != null)
                    message.DirectionFlag = object.DirectionFlag | 0;
                if (object.Reserved != null)
                    if (typeof object.Reserved === "string")
                        $util.base64.decode(object.Reserved, message.Reserved = $util.newBuffer($util.base64.length(object.Reserved)), 0);
                    else if (object.Reserved.length)
                        message.Reserved = object.Reserved;
                return message;
            };

            /**
             * Creates a plain object from a C2cTmpMsgHead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @static
             * @param {Msg.MsgField.C2cTmpMsgHead} message C2cTmpMsgHead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2cTmpMsgHead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.C2cType = 0;
                    object.ServiceType = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.GroupUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.GroupUin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.groupCode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupCode = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    object.SigType = 0;
                    object.FromPhone = "";
                    object.ToPhone = "";
                    object.LockDisplay = 0;
                    object.DirectionFlag = 0;
                    if (options.bytes === String)
                        object.Reserved = "";
                    else {
                        object.Reserved = [];
                        if (options.bytes !== Array)
                            object.Reserved = $util.newBuffer(object.Reserved);
                    }
                }
                if (message.C2cType != null && message.hasOwnProperty("C2cType"))
                    object.C2cType = message.C2cType;
                if (message.ServiceType != null && message.hasOwnProperty("ServiceType"))
                    object.ServiceType = message.ServiceType;
                if (message.GroupUin != null && message.hasOwnProperty("GroupUin"))
                    if (typeof message.GroupUin === "number")
                        object.GroupUin = options.longs === String ? String(message.GroupUin) : message.GroupUin;
                    else
                        object.GroupUin = options.longs === String ? $util.Long.prototype.toString.call(message.GroupUin) : options.longs === Number ? new $util.LongBits(message.GroupUin.low >>> 0, message.GroupUin.high >>> 0).toNumber() : message.GroupUin;
                if (message.groupCode != null && message.hasOwnProperty("groupCode"))
                    if (typeof message.groupCode === "number")
                        object.groupCode = options.longs === String ? String(message.groupCode) : message.groupCode;
                    else
                        object.groupCode = options.longs === String ? $util.Long.prototype.toString.call(message.groupCode) : options.longs === Number ? new $util.LongBits(message.groupCode.low >>> 0, message.groupCode.high >>> 0).toNumber() : message.groupCode;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.SigType != null && message.hasOwnProperty("SigType"))
                    object.SigType = message.SigType;
                if (message.FromPhone != null && message.hasOwnProperty("FromPhone"))
                    object.FromPhone = message.FromPhone;
                if (message.ToPhone != null && message.hasOwnProperty("ToPhone"))
                    object.ToPhone = message.ToPhone;
                if (message.LockDisplay != null && message.hasOwnProperty("LockDisplay"))
                    object.LockDisplay = message.LockDisplay;
                if (message.DirectionFlag != null && message.hasOwnProperty("DirectionFlag"))
                    object.DirectionFlag = message.DirectionFlag;
                if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                    object.Reserved = options.bytes === String ? $util.base64.encode(message.Reserved, 0, message.Reserved.length) : options.bytes === Array ? Array.prototype.slice.call(message.Reserved) : message.Reserved;
                return object;
            };

            /**
             * Converts this C2cTmpMsgHead to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.C2cTmpMsgHead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2cTmpMsgHead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return C2cTmpMsgHead;
        })();

        MsgField.DiscussInfo = (function() {

            /**
             * Properties of a DiscussInfo.
             * @memberof Msg.MsgField
             * @interface IDiscussInfo
             * @property {number|Long|null} [DiscussUin] DiscussInfo DiscussUin
             * @property {number|null} [DiscussType] DiscussInfo DiscussType
             * @property {number|Long|null} [DiscussInfoSeq] DiscussInfo DiscussInfoSeq
             * @property {Uint8Array|null} [DiscussRemark] DiscussInfo DiscussRemark
             * @property {Uint8Array|null} [DiscussName] DiscussInfo DiscussName
             */

            /**
             * Constructs a new DiscussInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents a DiscussInfo.
             * @implements IDiscussInfo
             * @constructor
             * @param {Msg.MsgField.IDiscussInfo=} [properties] Properties to set
             */
            function DiscussInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiscussInfo DiscussUin.
             * @member {number|Long} DiscussUin
             * @memberof Msg.MsgField.DiscussInfo
             * @instance
             */
            DiscussInfo.prototype.DiscussUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DiscussInfo DiscussType.
             * @member {number} DiscussType
             * @memberof Msg.MsgField.DiscussInfo
             * @instance
             */
            DiscussInfo.prototype.DiscussType = 0;

            /**
             * DiscussInfo DiscussInfoSeq.
             * @member {number|Long} DiscussInfoSeq
             * @memberof Msg.MsgField.DiscussInfo
             * @instance
             */
            DiscussInfo.prototype.DiscussInfoSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DiscussInfo DiscussRemark.
             * @member {Uint8Array} DiscussRemark
             * @memberof Msg.MsgField.DiscussInfo
             * @instance
             */
            DiscussInfo.prototype.DiscussRemark = $util.newBuffer([]);

            /**
             * DiscussInfo DiscussName.
             * @member {Uint8Array} DiscussName
             * @memberof Msg.MsgField.DiscussInfo
             * @instance
             */
            DiscussInfo.prototype.DiscussName = $util.newBuffer([]);

            /**
             * Creates a new DiscussInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {Msg.MsgField.IDiscussInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.DiscussInfo} DiscussInfo instance
             */
            DiscussInfo.create = function create(properties) {
                return new DiscussInfo(properties);
            };

            /**
             * Encodes the specified DiscussInfo message. Does not implicitly {@link Msg.MsgField.DiscussInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {Msg.MsgField.IDiscussInfo} message DiscussInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiscussInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.DiscussUin != null && Object.hasOwnProperty.call(message, "DiscussUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.DiscussUin);
                if (message.DiscussType != null && Object.hasOwnProperty.call(message, "DiscussType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.DiscussType);
                if (message.DiscussInfoSeq != null && Object.hasOwnProperty.call(message, "DiscussInfoSeq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.DiscussInfoSeq);
                if (message.DiscussRemark != null && Object.hasOwnProperty.call(message, "DiscussRemark"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.DiscussRemark);
                if (message.DiscussName != null && Object.hasOwnProperty.call(message, "DiscussName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.DiscussName);
                return writer;
            };

            /**
             * Encodes the specified DiscussInfo message, length delimited. Does not implicitly {@link Msg.MsgField.DiscussInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {Msg.MsgField.IDiscussInfo} message DiscussInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiscussInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiscussInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.DiscussInfo} DiscussInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiscussInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.DiscussInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.DiscussUin = reader.int64();
                        break;
                    case 2:
                        message.DiscussType = reader.int32();
                        break;
                    case 3:
                        message.DiscussInfoSeq = reader.int64();
                        break;
                    case 4:
                        message.DiscussRemark = reader.bytes();
                        break;
                    case 5:
                        message.DiscussName = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiscussInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.DiscussInfo} DiscussInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiscussInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiscussInfo message.
             * @function verify
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiscussInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.DiscussUin != null && message.hasOwnProperty("DiscussUin"))
                    if (!$util.isInteger(message.DiscussUin) && !(message.DiscussUin && $util.isInteger(message.DiscussUin.low) && $util.isInteger(message.DiscussUin.high)))
                        return "DiscussUin: integer|Long expected";
                if (message.DiscussType != null && message.hasOwnProperty("DiscussType"))
                    if (!$util.isInteger(message.DiscussType))
                        return "DiscussType: integer expected";
                if (message.DiscussInfoSeq != null && message.hasOwnProperty("DiscussInfoSeq"))
                    if (!$util.isInteger(message.DiscussInfoSeq) && !(message.DiscussInfoSeq && $util.isInteger(message.DiscussInfoSeq.low) && $util.isInteger(message.DiscussInfoSeq.high)))
                        return "DiscussInfoSeq: integer|Long expected";
                if (message.DiscussRemark != null && message.hasOwnProperty("DiscussRemark"))
                    if (!(message.DiscussRemark && typeof message.DiscussRemark.length === "number" || $util.isString(message.DiscussRemark)))
                        return "DiscussRemark: buffer expected";
                if (message.DiscussName != null && message.hasOwnProperty("DiscussName"))
                    if (!(message.DiscussName && typeof message.DiscussName.length === "number" || $util.isString(message.DiscussName)))
                        return "DiscussName: buffer expected";
                return null;
            };

            /**
             * Creates a DiscussInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.DiscussInfo} DiscussInfo
             */
            DiscussInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.DiscussInfo)
                    return object;
                var message = new $root.Msg.MsgField.DiscussInfo();
                if (object.DiscussUin != null)
                    if ($util.Long)
                        (message.DiscussUin = $util.Long.fromValue(object.DiscussUin)).unsigned = false;
                    else if (typeof object.DiscussUin === "string")
                        message.DiscussUin = parseInt(object.DiscussUin, 10);
                    else if (typeof object.DiscussUin === "number")
                        message.DiscussUin = object.DiscussUin;
                    else if (typeof object.DiscussUin === "object")
                        message.DiscussUin = new $util.LongBits(object.DiscussUin.low >>> 0, object.DiscussUin.high >>> 0).toNumber();
                if (object.DiscussType != null)
                    message.DiscussType = object.DiscussType | 0;
                if (object.DiscussInfoSeq != null)
                    if ($util.Long)
                        (message.DiscussInfoSeq = $util.Long.fromValue(object.DiscussInfoSeq)).unsigned = false;
                    else if (typeof object.DiscussInfoSeq === "string")
                        message.DiscussInfoSeq = parseInt(object.DiscussInfoSeq, 10);
                    else if (typeof object.DiscussInfoSeq === "number")
                        message.DiscussInfoSeq = object.DiscussInfoSeq;
                    else if (typeof object.DiscussInfoSeq === "object")
                        message.DiscussInfoSeq = new $util.LongBits(object.DiscussInfoSeq.low >>> 0, object.DiscussInfoSeq.high >>> 0).toNumber();
                if (object.DiscussRemark != null)
                    if (typeof object.DiscussRemark === "string")
                        $util.base64.decode(object.DiscussRemark, message.DiscussRemark = $util.newBuffer($util.base64.length(object.DiscussRemark)), 0);
                    else if (object.DiscussRemark.length)
                        message.DiscussRemark = object.DiscussRemark;
                if (object.DiscussName != null)
                    if (typeof object.DiscussName === "string")
                        $util.base64.decode(object.DiscussName, message.DiscussName = $util.newBuffer($util.base64.length(object.DiscussName)), 0);
                    else if (object.DiscussName.length)
                        message.DiscussName = object.DiscussName;
                return message;
            };

            /**
             * Creates a plain object from a DiscussInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.DiscussInfo
             * @static
             * @param {Msg.MsgField.DiscussInfo} message DiscussInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiscussInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.DiscussUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.DiscussUin = options.longs === String ? "0" : 0;
                    object.DiscussType = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.DiscussInfoSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.DiscussInfoSeq = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.DiscussRemark = "";
                    else {
                        object.DiscussRemark = [];
                        if (options.bytes !== Array)
                            object.DiscussRemark = $util.newBuffer(object.DiscussRemark);
                    }
                    if (options.bytes === String)
                        object.DiscussName = "";
                    else {
                        object.DiscussName = [];
                        if (options.bytes !== Array)
                            object.DiscussName = $util.newBuffer(object.DiscussName);
                    }
                }
                if (message.DiscussUin != null && message.hasOwnProperty("DiscussUin"))
                    if (typeof message.DiscussUin === "number")
                        object.DiscussUin = options.longs === String ? String(message.DiscussUin) : message.DiscussUin;
                    else
                        object.DiscussUin = options.longs === String ? $util.Long.prototype.toString.call(message.DiscussUin) : options.longs === Number ? new $util.LongBits(message.DiscussUin.low >>> 0, message.DiscussUin.high >>> 0).toNumber() : message.DiscussUin;
                if (message.DiscussType != null && message.hasOwnProperty("DiscussType"))
                    object.DiscussType = message.DiscussType;
                if (message.DiscussInfoSeq != null && message.hasOwnProperty("DiscussInfoSeq"))
                    if (typeof message.DiscussInfoSeq === "number")
                        object.DiscussInfoSeq = options.longs === String ? String(message.DiscussInfoSeq) : message.DiscussInfoSeq;
                    else
                        object.DiscussInfoSeq = options.longs === String ? $util.Long.prototype.toString.call(message.DiscussInfoSeq) : options.longs === Number ? new $util.LongBits(message.DiscussInfoSeq.low >>> 0, message.DiscussInfoSeq.high >>> 0).toNumber() : message.DiscussInfoSeq;
                if (message.DiscussRemark != null && message.hasOwnProperty("DiscussRemark"))
                    object.DiscussRemark = options.bytes === String ? $util.base64.encode(message.DiscussRemark, 0, message.DiscussRemark.length) : options.bytes === Array ? Array.prototype.slice.call(message.DiscussRemark) : message.DiscussRemark;
                if (message.DiscussName != null && message.hasOwnProperty("DiscussName"))
                    object.DiscussName = options.bytes === String ? $util.base64.encode(message.DiscussName, 0, message.DiscussName.length) : options.bytes === Array ? Array.prototype.slice.call(message.DiscussName) : message.DiscussName;
                return object;
            };

            /**
             * Converts this DiscussInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.DiscussInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiscussInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DiscussInfo;
        })();

        MsgField.GroupInfo = (function() {

            /**
             * Properties of a GroupInfo.
             * @memberof Msg.MsgField
             * @interface IGroupInfo
             * @property {number|Long|null} [GroupCode] GroupInfo GroupCode
             * @property {number|null} [GroupType] GroupInfo GroupType
             * @property {number|Long|null} [GroupInfoSeq] GroupInfo GroupInfoSeq
             * @property {string|null} [GroupCard] GroupInfo GroupCard
             * @property {Uint8Array|null} [GroupRank] GroupInfo GroupRank
             * @property {number|null} [GroupLevel] GroupInfo GroupLevel
             * @property {number|null} [GroupCardType] GroupInfo GroupCardType
             * @property {Uint8Array|null} [GroupName] GroupInfo GroupName
             */

            /**
             * Constructs a new GroupInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents a GroupInfo.
             * @implements IGroupInfo
             * @constructor
             * @param {Msg.MsgField.IGroupInfo=} [properties] Properties to set
             */
            function GroupInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupInfo GroupCode.
             * @member {number|Long} GroupCode
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupCode = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupInfo GroupType.
             * @member {number} GroupType
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupType = 0;

            /**
             * GroupInfo GroupInfoSeq.
             * @member {number|Long} GroupInfoSeq
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupInfoSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupInfo GroupCard.
             * @member {string} GroupCard
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupCard = "";

            /**
             * GroupInfo GroupRank.
             * @member {Uint8Array} GroupRank
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupRank = $util.newBuffer([]);

            /**
             * GroupInfo GroupLevel.
             * @member {number} GroupLevel
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupLevel = 0;

            /**
             * GroupInfo GroupCardType.
             * @member {number} GroupCardType
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupCardType = 0;

            /**
             * GroupInfo GroupName.
             * @member {Uint8Array} GroupName
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             */
            GroupInfo.prototype.GroupName = $util.newBuffer([]);

            /**
             * Creates a new GroupInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {Msg.MsgField.IGroupInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.GroupInfo} GroupInfo instance
             */
            GroupInfo.create = function create(properties) {
                return new GroupInfo(properties);
            };

            /**
             * Encodes the specified GroupInfo message. Does not implicitly {@link Msg.MsgField.GroupInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {Msg.MsgField.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.GroupCode != null && Object.hasOwnProperty.call(message, "GroupCode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.GroupCode);
                if (message.GroupType != null && Object.hasOwnProperty.call(message, "GroupType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GroupType);
                if (message.GroupInfoSeq != null && Object.hasOwnProperty.call(message, "GroupInfoSeq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GroupInfoSeq);
                if (message.GroupCard != null && Object.hasOwnProperty.call(message, "GroupCard"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.GroupCard);
                if (message.GroupRank != null && Object.hasOwnProperty.call(message, "GroupRank"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.GroupRank);
                if (message.GroupLevel != null && Object.hasOwnProperty.call(message, "GroupLevel"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.GroupLevel);
                if (message.GroupCardType != null && Object.hasOwnProperty.call(message, "GroupCardType"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.GroupCardType);
                if (message.GroupName != null && Object.hasOwnProperty.call(message, "GroupName"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.GroupName);
                return writer;
            };

            /**
             * Encodes the specified GroupInfo message, length delimited. Does not implicitly {@link Msg.MsgField.GroupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {Msg.MsgField.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.GroupInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.GroupCode = reader.int64();
                        break;
                    case 2:
                        message.GroupType = reader.int32();
                        break;
                    case 3:
                        message.GroupInfoSeq = reader.int64();
                        break;
                    case 4:
                        message.GroupCard = reader.string();
                        break;
                    case 5:
                        message.GroupRank = reader.bytes();
                        break;
                    case 6:
                        message.GroupLevel = reader.int32();
                        break;
                    case 7:
                        message.GroupCardType = reader.int32();
                        break;
                    case 8:
                        message.GroupName = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupInfo message.
             * @function verify
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.GroupCode != null && message.hasOwnProperty("GroupCode"))
                    if (!$util.isInteger(message.GroupCode) && !(message.GroupCode && $util.isInteger(message.GroupCode.low) && $util.isInteger(message.GroupCode.high)))
                        return "GroupCode: integer|Long expected";
                if (message.GroupType != null && message.hasOwnProperty("GroupType"))
                    if (!$util.isInteger(message.GroupType))
                        return "GroupType: integer expected";
                if (message.GroupInfoSeq != null && message.hasOwnProperty("GroupInfoSeq"))
                    if (!$util.isInteger(message.GroupInfoSeq) && !(message.GroupInfoSeq && $util.isInteger(message.GroupInfoSeq.low) && $util.isInteger(message.GroupInfoSeq.high)))
                        return "GroupInfoSeq: integer|Long expected";
                if (message.GroupCard != null && message.hasOwnProperty("GroupCard"))
                    if (!$util.isString(message.GroupCard))
                        return "GroupCard: string expected";
                if (message.GroupRank != null && message.hasOwnProperty("GroupRank"))
                    if (!(message.GroupRank && typeof message.GroupRank.length === "number" || $util.isString(message.GroupRank)))
                        return "GroupRank: buffer expected";
                if (message.GroupLevel != null && message.hasOwnProperty("GroupLevel"))
                    if (!$util.isInteger(message.GroupLevel))
                        return "GroupLevel: integer expected";
                if (message.GroupCardType != null && message.hasOwnProperty("GroupCardType"))
                    if (!$util.isInteger(message.GroupCardType))
                        return "GroupCardType: integer expected";
                if (message.GroupName != null && message.hasOwnProperty("GroupName"))
                    if (!(message.GroupName && typeof message.GroupName.length === "number" || $util.isString(message.GroupName)))
                        return "GroupName: buffer expected";
                return null;
            };

            /**
             * Creates a GroupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.GroupInfo} GroupInfo
             */
            GroupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.GroupInfo)
                    return object;
                var message = new $root.Msg.MsgField.GroupInfo();
                if (object.GroupCode != null)
                    if ($util.Long)
                        (message.GroupCode = $util.Long.fromValue(object.GroupCode)).unsigned = false;
                    else if (typeof object.GroupCode === "string")
                        message.GroupCode = parseInt(object.GroupCode, 10);
                    else if (typeof object.GroupCode === "number")
                        message.GroupCode = object.GroupCode;
                    else if (typeof object.GroupCode === "object")
                        message.GroupCode = new $util.LongBits(object.GroupCode.low >>> 0, object.GroupCode.high >>> 0).toNumber();
                if (object.GroupType != null)
                    message.GroupType = object.GroupType | 0;
                if (object.GroupInfoSeq != null)
                    if ($util.Long)
                        (message.GroupInfoSeq = $util.Long.fromValue(object.GroupInfoSeq)).unsigned = false;
                    else if (typeof object.GroupInfoSeq === "string")
                        message.GroupInfoSeq = parseInt(object.GroupInfoSeq, 10);
                    else if (typeof object.GroupInfoSeq === "number")
                        message.GroupInfoSeq = object.GroupInfoSeq;
                    else if (typeof object.GroupInfoSeq === "object")
                        message.GroupInfoSeq = new $util.LongBits(object.GroupInfoSeq.low >>> 0, object.GroupInfoSeq.high >>> 0).toNumber();
                if (object.GroupCard != null)
                    message.GroupCard = String(object.GroupCard);
                if (object.GroupRank != null)
                    if (typeof object.GroupRank === "string")
                        $util.base64.decode(object.GroupRank, message.GroupRank = $util.newBuffer($util.base64.length(object.GroupRank)), 0);
                    else if (object.GroupRank.length)
                        message.GroupRank = object.GroupRank;
                if (object.GroupLevel != null)
                    message.GroupLevel = object.GroupLevel | 0;
                if (object.GroupCardType != null)
                    message.GroupCardType = object.GroupCardType | 0;
                if (object.GroupName != null)
                    if (typeof object.GroupName === "string")
                        $util.base64.decode(object.GroupName, message.GroupName = $util.newBuffer($util.base64.length(object.GroupName)), 0);
                    else if (object.GroupName.length)
                        message.GroupName = object.GroupName;
                return message;
            };

            /**
             * Creates a plain object from a GroupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.GroupInfo
             * @static
             * @param {Msg.MsgField.GroupInfo} message GroupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.GroupCode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.GroupCode = options.longs === String ? "0" : 0;
                    object.GroupType = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.GroupInfoSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.GroupInfoSeq = options.longs === String ? "0" : 0;
                    object.GroupCard = "";
                    if (options.bytes === String)
                        object.GroupRank = "";
                    else {
                        object.GroupRank = [];
                        if (options.bytes !== Array)
                            object.GroupRank = $util.newBuffer(object.GroupRank);
                    }
                    object.GroupLevel = 0;
                    object.GroupCardType = 0;
                    if (options.bytes === String)
                        object.GroupName = "";
                    else {
                        object.GroupName = [];
                        if (options.bytes !== Array)
                            object.GroupName = $util.newBuffer(object.GroupName);
                    }
                }
                if (message.GroupCode != null && message.hasOwnProperty("GroupCode"))
                    if (typeof message.GroupCode === "number")
                        object.GroupCode = options.longs === String ? String(message.GroupCode) : message.GroupCode;
                    else
                        object.GroupCode = options.longs === String ? $util.Long.prototype.toString.call(message.GroupCode) : options.longs === Number ? new $util.LongBits(message.GroupCode.low >>> 0, message.GroupCode.high >>> 0).toNumber() : message.GroupCode;
                if (message.GroupType != null && message.hasOwnProperty("GroupType"))
                    object.GroupType = message.GroupType;
                if (message.GroupInfoSeq != null && message.hasOwnProperty("GroupInfoSeq"))
                    if (typeof message.GroupInfoSeq === "number")
                        object.GroupInfoSeq = options.longs === String ? String(message.GroupInfoSeq) : message.GroupInfoSeq;
                    else
                        object.GroupInfoSeq = options.longs === String ? $util.Long.prototype.toString.call(message.GroupInfoSeq) : options.longs === Number ? new $util.LongBits(message.GroupInfoSeq.low >>> 0, message.GroupInfoSeq.high >>> 0).toNumber() : message.GroupInfoSeq;
                if (message.GroupCard != null && message.hasOwnProperty("GroupCard"))
                    object.GroupCard = message.GroupCard;
                if (message.GroupRank != null && message.hasOwnProperty("GroupRank"))
                    object.GroupRank = options.bytes === String ? $util.base64.encode(message.GroupRank, 0, message.GroupRank.length) : options.bytes === Array ? Array.prototype.slice.call(message.GroupRank) : message.GroupRank;
                if (message.GroupLevel != null && message.hasOwnProperty("GroupLevel"))
                    object.GroupLevel = message.GroupLevel;
                if (message.GroupCardType != null && message.hasOwnProperty("GroupCardType"))
                    object.GroupCardType = message.GroupCardType;
                if (message.GroupName != null && message.hasOwnProperty("GroupName"))
                    object.GroupName = options.bytes === String ? $util.base64.encode(message.GroupName, 0, message.GroupName.length) : options.bytes === Array ? Array.prototype.slice.call(message.GroupName) : message.GroupName;
                return object;
            };

            /**
             * Converts this GroupInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.GroupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupInfo;
        })();

        MsgField.MutilTransHead = (function() {

            /**
             * Properties of a MutilTransHead.
             * @memberof Msg.MsgField
             * @interface IMutilTransHead
             * @property {number|null} [Status] MutilTransHead Status
             * @property {number|null} [MsgId] MutilTransHead MsgId
             */

            /**
             * Constructs a new MutilTransHead.
             * @memberof Msg.MsgField
             * @classdesc Represents a MutilTransHead.
             * @implements IMutilTransHead
             * @constructor
             * @param {Msg.MsgField.IMutilTransHead=} [properties] Properties to set
             */
            function MutilTransHead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MutilTransHead Status.
             * @member {number} Status
             * @memberof Msg.MsgField.MutilTransHead
             * @instance
             */
            MutilTransHead.prototype.Status = 0;

            /**
             * MutilTransHead MsgId.
             * @member {number} MsgId
             * @memberof Msg.MsgField.MutilTransHead
             * @instance
             */
            MutilTransHead.prototype.MsgId = 0;

            /**
             * Creates a new MutilTransHead instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {Msg.MsgField.IMutilTransHead=} [properties] Properties to set
             * @returns {Msg.MsgField.MutilTransHead} MutilTransHead instance
             */
            MutilTransHead.create = function create(properties) {
                return new MutilTransHead(properties);
            };

            /**
             * Encodes the specified MutilTransHead message. Does not implicitly {@link Msg.MsgField.MutilTransHead.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {Msg.MsgField.IMutilTransHead} message MutilTransHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MutilTransHead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Status != null && Object.hasOwnProperty.call(message, "Status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Status);
                if (message.MsgId != null && Object.hasOwnProperty.call(message, "MsgId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.MsgId);
                return writer;
            };

            /**
             * Encodes the specified MutilTransHead message, length delimited. Does not implicitly {@link Msg.MsgField.MutilTransHead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {Msg.MsgField.IMutilTransHead} message MutilTransHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MutilTransHead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MutilTransHead message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.MutilTransHead} MutilTransHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MutilTransHead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.MutilTransHead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Status = reader.int32();
                        break;
                    case 2:
                        message.MsgId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MutilTransHead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.MutilTransHead} MutilTransHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MutilTransHead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MutilTransHead message.
             * @function verify
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MutilTransHead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Status != null && message.hasOwnProperty("Status"))
                    if (!$util.isInteger(message.Status))
                        return "Status: integer expected";
                if (message.MsgId != null && message.hasOwnProperty("MsgId"))
                    if (!$util.isInteger(message.MsgId))
                        return "MsgId: integer expected";
                return null;
            };

            /**
             * Creates a MutilTransHead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.MutilTransHead} MutilTransHead
             */
            MutilTransHead.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.MutilTransHead)
                    return object;
                var message = new $root.Msg.MsgField.MutilTransHead();
                if (object.Status != null)
                    message.Status = object.Status | 0;
                if (object.MsgId != null)
                    message.MsgId = object.MsgId | 0;
                return message;
            };

            /**
             * Creates a plain object from a MutilTransHead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.MutilTransHead
             * @static
             * @param {Msg.MsgField.MutilTransHead} message MutilTransHead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MutilTransHead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Status = 0;
                    object.MsgId = 0;
                }
                if (message.Status != null && message.hasOwnProperty("Status"))
                    object.Status = message.Status;
                if (message.MsgId != null && message.hasOwnProperty("MsgId"))
                    object.MsgId = message.MsgId;
                return object;
            };

            /**
             * Converts this MutilTransHead to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.MutilTransHead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MutilTransHead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MutilTransHead;
        })();

        MsgField.ExtGroupKeyInfo = (function() {

            /**
             * Properties of an ExtGroupKeyInfo.
             * @memberof Msg.MsgField
             * @interface IExtGroupKeyInfo
             * @property {number|null} [CurMaxSeq] ExtGroupKeyInfo CurMaxSeq
             * @property {number|Long|null} [CurTime] ExtGroupKeyInfo CurTime
             */

            /**
             * Constructs a new ExtGroupKeyInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents an ExtGroupKeyInfo.
             * @implements IExtGroupKeyInfo
             * @constructor
             * @param {Msg.MsgField.IExtGroupKeyInfo=} [properties] Properties to set
             */
            function ExtGroupKeyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtGroupKeyInfo CurMaxSeq.
             * @member {number} CurMaxSeq
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @instance
             */
            ExtGroupKeyInfo.prototype.CurMaxSeq = 0;

            /**
             * ExtGroupKeyInfo CurTime.
             * @member {number|Long} CurTime
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @instance
             */
            ExtGroupKeyInfo.prototype.CurTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ExtGroupKeyInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {Msg.MsgField.IExtGroupKeyInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.ExtGroupKeyInfo} ExtGroupKeyInfo instance
             */
            ExtGroupKeyInfo.create = function create(properties) {
                return new ExtGroupKeyInfo(properties);
            };

            /**
             * Encodes the specified ExtGroupKeyInfo message. Does not implicitly {@link Msg.MsgField.ExtGroupKeyInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {Msg.MsgField.IExtGroupKeyInfo} message ExtGroupKeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtGroupKeyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.CurMaxSeq != null && Object.hasOwnProperty.call(message, "CurMaxSeq"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CurMaxSeq);
                if (message.CurTime != null && Object.hasOwnProperty.call(message, "CurTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.CurTime);
                return writer;
            };

            /**
             * Encodes the specified ExtGroupKeyInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ExtGroupKeyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {Msg.MsgField.IExtGroupKeyInfo} message ExtGroupKeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtGroupKeyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtGroupKeyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.ExtGroupKeyInfo} ExtGroupKeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtGroupKeyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ExtGroupKeyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.CurMaxSeq = reader.int32();
                        break;
                    case 2:
                        message.CurTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtGroupKeyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.ExtGroupKeyInfo} ExtGroupKeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtGroupKeyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtGroupKeyInfo message.
             * @function verify
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtGroupKeyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.CurMaxSeq != null && message.hasOwnProperty("CurMaxSeq"))
                    if (!$util.isInteger(message.CurMaxSeq))
                        return "CurMaxSeq: integer expected";
                if (message.CurTime != null && message.hasOwnProperty("CurTime"))
                    if (!$util.isInteger(message.CurTime) && !(message.CurTime && $util.isInteger(message.CurTime.low) && $util.isInteger(message.CurTime.high)))
                        return "CurTime: integer|Long expected";
                return null;
            };

            /**
             * Creates an ExtGroupKeyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.ExtGroupKeyInfo} ExtGroupKeyInfo
             */
            ExtGroupKeyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.ExtGroupKeyInfo)
                    return object;
                var message = new $root.Msg.MsgField.ExtGroupKeyInfo();
                if (object.CurMaxSeq != null)
                    message.CurMaxSeq = object.CurMaxSeq | 0;
                if (object.CurTime != null)
                    if ($util.Long)
                        (message.CurTime = $util.Long.fromValue(object.CurTime)).unsigned = false;
                    else if (typeof object.CurTime === "string")
                        message.CurTime = parseInt(object.CurTime, 10);
                    else if (typeof object.CurTime === "number")
                        message.CurTime = object.CurTime;
                    else if (typeof object.CurTime === "object")
                        message.CurTime = new $util.LongBits(object.CurTime.low >>> 0, object.CurTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an ExtGroupKeyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @static
             * @param {Msg.MsgField.ExtGroupKeyInfo} message ExtGroupKeyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtGroupKeyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.CurMaxSeq = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.CurTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.CurTime = options.longs === String ? "0" : 0;
                }
                if (message.CurMaxSeq != null && message.hasOwnProperty("CurMaxSeq"))
                    object.CurMaxSeq = message.CurMaxSeq;
                if (message.CurTime != null && message.hasOwnProperty("CurTime"))
                    if (typeof message.CurTime === "number")
                        object.CurTime = options.longs === String ? String(message.CurTime) : message.CurTime;
                    else
                        object.CurTime = options.longs === String ? $util.Long.prototype.toString.call(message.CurTime) : options.longs === Number ? new $util.LongBits(message.CurTime.low >>> 0, message.CurTime.high >>> 0).toNumber() : message.CurTime;
                return object;
            };

            /**
             * Converts this ExtGroupKeyInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.ExtGroupKeyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtGroupKeyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExtGroupKeyInfo;
        })();

        MsgField.MsgHead = (function() {

            /**
             * Properties of a MsgHead.
             * @memberof Msg.MsgField
             * @interface IMsgHead
             * @property {number|Long|null} [FromUin] MsgHead FromUin
             * @property {number|Long|null} [ToUin] MsgHead ToUin
             * @property {number|null} [MsgType] MsgHead MsgType
             * @property {number|null} [C2cCmd] MsgHead C2cCmd
             * @property {number|null} [MsgSeq] MsgHead MsgSeq
             * @property {number|null} [MsgTime] MsgHead MsgTime
             * @property {number|Long|null} [MsgUid] MsgHead MsgUid
             * @property {Msg.MsgField.IC2cTmpMsgHead|null} [C2CTmpMsgHead] MsgHead C2CTmpMsgHead
             * @property {Msg.MsgField.IGroupInfo|null} [GroupInfo] MsgHead GroupInfo
             * @property {number|null} [FromAppid] MsgHead FromAppid
             * @property {number|null} [FromInstid] MsgHead FromInstid
             * @property {number|null} [UserActive] MsgHead UserActive
             * @property {Msg.MsgField.IDiscussInfo|null} [DiscussInfo] MsgHead DiscussInfo
             * @property {string|null} [FromNick] MsgHead FromNick
             * @property {number|Long|null} [AuthUin] MsgHead AuthUin
             * @property {string|null} [AuthString] MsgHead AuthString
             * @property {number|null} [MsgFlag] MsgHead MsgFlag
             * @property {string|null} [AuthRemark] MsgHead AuthRemark
             * @property {Uint8Array|null} [GroupName] MsgHead GroupName
             * @property {Msg.MsgField.IMutilTransHead|null} [MutilTransHead] MsgHead MutilTransHead
             * @property {Msg.MsgField.ImMsgHead.IInstCtrl|null} [MsgInstCtrl] MsgHead MsgInstCtrl
             * @property {number|null} [PublicAccountGroupSendFlag] MsgHead PublicAccountGroupSendFlag
             * @property {number|null} [WseqInC2cMsghead] MsgHead WseqInC2cMsghead
             * @property {number|Long|null} [Cpid] MsgHead Cpid
             * @property {Msg.MsgField.IExtGroupKeyInfo|null} [ExtGroupKeyInfo] MsgHead ExtGroupKeyInfo
             * @property {string|null} [MultiCompatibleText] MsgHead MultiCompatibleText
             * @property {number|null} [AuthSex] MsgHead AuthSex
             * @property {boolean|null} [IsSrcMsg] MsgHead IsSrcMsg
             */

            /**
             * Constructs a new MsgHead.
             * @memberof Msg.MsgField
             * @classdesc Represents a MsgHead.
             * @implements IMsgHead
             * @constructor
             * @param {Msg.MsgField.IMsgHead=} [properties] Properties to set
             */
            function MsgHead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgHead FromUin.
             * @member {number|Long} FromUin
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.FromUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MsgHead ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MsgHead MsgType.
             * @member {number} MsgType
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MsgType = 0;

            /**
             * MsgHead C2cCmd.
             * @member {number} C2cCmd
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.C2cCmd = 0;

            /**
             * MsgHead MsgSeq.
             * @member {number} MsgSeq
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MsgSeq = 0;

            /**
             * MsgHead MsgTime.
             * @member {number} MsgTime
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MsgTime = 0;

            /**
             * MsgHead MsgUid.
             * @member {number|Long} MsgUid
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MsgUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MsgHead C2CTmpMsgHead.
             * @member {Msg.MsgField.IC2cTmpMsgHead|null|undefined} C2CTmpMsgHead
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.C2CTmpMsgHead = null;

            /**
             * MsgHead GroupInfo.
             * @member {Msg.MsgField.IGroupInfo|null|undefined} GroupInfo
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.GroupInfo = null;

            /**
             * MsgHead FromAppid.
             * @member {number} FromAppid
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.FromAppid = 0;

            /**
             * MsgHead FromInstid.
             * @member {number} FromInstid
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.FromInstid = 0;

            /**
             * MsgHead UserActive.
             * @member {number} UserActive
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.UserActive = 0;

            /**
             * MsgHead DiscussInfo.
             * @member {Msg.MsgField.IDiscussInfo|null|undefined} DiscussInfo
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.DiscussInfo = null;

            /**
             * MsgHead FromNick.
             * @member {string} FromNick
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.FromNick = "";

            /**
             * MsgHead AuthUin.
             * @member {number|Long} AuthUin
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.AuthUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MsgHead AuthString.
             * @member {string} AuthString
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.AuthString = "";

            /**
             * MsgHead MsgFlag.
             * @member {number} MsgFlag
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MsgFlag = 0;

            /**
             * MsgHead AuthRemark.
             * @member {string} AuthRemark
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.AuthRemark = "";

            /**
             * MsgHead GroupName.
             * @member {Uint8Array} GroupName
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.GroupName = $util.newBuffer([]);

            /**
             * MsgHead MutilTransHead.
             * @member {Msg.MsgField.IMutilTransHead|null|undefined} MutilTransHead
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MutilTransHead = null;

            /**
             * MsgHead MsgInstCtrl.
             * @member {Msg.MsgField.ImMsgHead.IInstCtrl|null|undefined} MsgInstCtrl
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MsgInstCtrl = null;

            /**
             * MsgHead PublicAccountGroupSendFlag.
             * @member {number} PublicAccountGroupSendFlag
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.PublicAccountGroupSendFlag = 0;

            /**
             * MsgHead WseqInC2cMsghead.
             * @member {number} WseqInC2cMsghead
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.WseqInC2cMsghead = 0;

            /**
             * MsgHead Cpid.
             * @member {number|Long} Cpid
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.Cpid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MsgHead ExtGroupKeyInfo.
             * @member {Msg.MsgField.IExtGroupKeyInfo|null|undefined} ExtGroupKeyInfo
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.ExtGroupKeyInfo = null;

            /**
             * MsgHead MultiCompatibleText.
             * @member {string} MultiCompatibleText
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.MultiCompatibleText = "";

            /**
             * MsgHead AuthSex.
             * @member {number} AuthSex
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.AuthSex = 0;

            /**
             * MsgHead IsSrcMsg.
             * @member {boolean} IsSrcMsg
             * @memberof Msg.MsgField.MsgHead
             * @instance
             */
            MsgHead.prototype.IsSrcMsg = false;

            /**
             * Creates a new MsgHead instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {Msg.MsgField.IMsgHead=} [properties] Properties to set
             * @returns {Msg.MsgField.MsgHead} MsgHead instance
             */
            MsgHead.create = function create(properties) {
                return new MsgHead(properties);
            };

            /**
             * Encodes the specified MsgHead message. Does not implicitly {@link Msg.MsgField.MsgHead.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {Msg.MsgField.IMsgHead} message MsgHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgHead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.FromUin != null && Object.hasOwnProperty.call(message, "FromUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.FromUin);
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ToUin);
                if (message.MsgType != null && Object.hasOwnProperty.call(message, "MsgType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MsgType);
                if (message.C2cCmd != null && Object.hasOwnProperty.call(message, "C2cCmd"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.C2cCmd);
                if (message.MsgSeq != null && Object.hasOwnProperty.call(message, "MsgSeq"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.MsgSeq);
                if (message.MsgTime != null && Object.hasOwnProperty.call(message, "MsgTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.MsgTime);
                if (message.MsgUid != null && Object.hasOwnProperty.call(message, "MsgUid"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.MsgUid);
                if (message.C2CTmpMsgHead != null && Object.hasOwnProperty.call(message, "C2CTmpMsgHead"))
                    $root.Msg.MsgField.C2cTmpMsgHead.encode(message.C2CTmpMsgHead, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.GroupInfo != null && Object.hasOwnProperty.call(message, "GroupInfo"))
                    $root.Msg.MsgField.GroupInfo.encode(message.GroupInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.FromAppid != null && Object.hasOwnProperty.call(message, "FromAppid"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.FromAppid);
                if (message.FromInstid != null && Object.hasOwnProperty.call(message, "FromInstid"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.FromInstid);
                if (message.UserActive != null && Object.hasOwnProperty.call(message, "UserActive"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.UserActive);
                if (message.DiscussInfo != null && Object.hasOwnProperty.call(message, "DiscussInfo"))
                    $root.Msg.MsgField.DiscussInfo.encode(message.DiscussInfo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.FromNick != null && Object.hasOwnProperty.call(message, "FromNick"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.FromNick);
                if (message.AuthUin != null && Object.hasOwnProperty.call(message, "AuthUin"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int64(message.AuthUin);
                if (message.AuthString != null && Object.hasOwnProperty.call(message, "AuthString"))
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.AuthString);
                if (message.MsgFlag != null && Object.hasOwnProperty.call(message, "MsgFlag"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.MsgFlag);
                if (message.AuthRemark != null && Object.hasOwnProperty.call(message, "AuthRemark"))
                    writer.uint32(/* id 18, wireType 2 =*/146).string(message.AuthRemark);
                if (message.GroupName != null && Object.hasOwnProperty.call(message, "GroupName"))
                    writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.GroupName);
                if (message.MutilTransHead != null && Object.hasOwnProperty.call(message, "MutilTransHead"))
                    $root.Msg.MsgField.MutilTransHead.encode(message.MutilTransHead, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.MsgInstCtrl != null && Object.hasOwnProperty.call(message, "MsgInstCtrl"))
                    $root.Msg.MsgField.ImMsgHead.InstCtrl.encode(message.MsgInstCtrl, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.PublicAccountGroupSendFlag != null && Object.hasOwnProperty.call(message, "PublicAccountGroupSendFlag"))
                    writer.uint32(/* id 22, wireType 0 =*/176).int32(message.PublicAccountGroupSendFlag);
                if (message.WseqInC2cMsghead != null && Object.hasOwnProperty.call(message, "WseqInC2cMsghead"))
                    writer.uint32(/* id 23, wireType 0 =*/184).int32(message.WseqInC2cMsghead);
                if (message.Cpid != null && Object.hasOwnProperty.call(message, "Cpid"))
                    writer.uint32(/* id 24, wireType 0 =*/192).int64(message.Cpid);
                if (message.ExtGroupKeyInfo != null && Object.hasOwnProperty.call(message, "ExtGroupKeyInfo"))
                    $root.Msg.MsgField.ExtGroupKeyInfo.encode(message.ExtGroupKeyInfo, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.MultiCompatibleText != null && Object.hasOwnProperty.call(message, "MultiCompatibleText"))
                    writer.uint32(/* id 26, wireType 2 =*/210).string(message.MultiCompatibleText);
                if (message.AuthSex != null && Object.hasOwnProperty.call(message, "AuthSex"))
                    writer.uint32(/* id 27, wireType 0 =*/216).int32(message.AuthSex);
                if (message.IsSrcMsg != null && Object.hasOwnProperty.call(message, "IsSrcMsg"))
                    writer.uint32(/* id 28, wireType 0 =*/224).bool(message.IsSrcMsg);
                return writer;
            };

            /**
             * Encodes the specified MsgHead message, length delimited. Does not implicitly {@link Msg.MsgField.MsgHead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {Msg.MsgField.IMsgHead} message MsgHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgHead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgHead message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.MsgHead} MsgHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgHead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.MsgHead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.FromUin = reader.int64();
                        break;
                    case 2:
                        message.ToUin = reader.int64();
                        break;
                    case 3:
                        message.MsgType = reader.int32();
                        break;
                    case 4:
                        message.C2cCmd = reader.int32();
                        break;
                    case 5:
                        message.MsgSeq = reader.int32();
                        break;
                    case 6:
                        message.MsgTime = reader.int32();
                        break;
                    case 7:
                        message.MsgUid = reader.int64();
                        break;
                    case 8:
                        message.C2CTmpMsgHead = $root.Msg.MsgField.C2cTmpMsgHead.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.GroupInfo = $root.Msg.MsgField.GroupInfo.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.FromAppid = reader.int32();
                        break;
                    case 11:
                        message.FromInstid = reader.int32();
                        break;
                    case 12:
                        message.UserActive = reader.int32();
                        break;
                    case 13:
                        message.DiscussInfo = $root.Msg.MsgField.DiscussInfo.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.FromNick = reader.string();
                        break;
                    case 15:
                        message.AuthUin = reader.int64();
                        break;
                    case 16:
                        message.AuthString = reader.string();
                        break;
                    case 17:
                        message.MsgFlag = reader.int32();
                        break;
                    case 18:
                        message.AuthRemark = reader.string();
                        break;
                    case 19:
                        message.GroupName = reader.bytes();
                        break;
                    case 20:
                        message.MutilTransHead = $root.Msg.MsgField.MutilTransHead.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.MsgInstCtrl = $root.Msg.MsgField.ImMsgHead.InstCtrl.decode(reader, reader.uint32());
                        break;
                    case 22:
                        message.PublicAccountGroupSendFlag = reader.int32();
                        break;
                    case 23:
                        message.WseqInC2cMsghead = reader.int32();
                        break;
                    case 24:
                        message.Cpid = reader.int64();
                        break;
                    case 25:
                        message.ExtGroupKeyInfo = $root.Msg.MsgField.ExtGroupKeyInfo.decode(reader, reader.uint32());
                        break;
                    case 26:
                        message.MultiCompatibleText = reader.string();
                        break;
                    case 27:
                        message.AuthSex = reader.int32();
                        break;
                    case 28:
                        message.IsSrcMsg = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgHead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.MsgHead} MsgHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgHead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgHead message.
             * @function verify
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgHead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                    if (!$util.isInteger(message.FromUin) && !(message.FromUin && $util.isInteger(message.FromUin.low) && $util.isInteger(message.FromUin.high)))
                        return "FromUin: integer|Long expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                    if (!$util.isInteger(message.MsgType))
                        return "MsgType: integer expected";
                if (message.C2cCmd != null && message.hasOwnProperty("C2cCmd"))
                    if (!$util.isInteger(message.C2cCmd))
                        return "C2cCmd: integer expected";
                if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                    if (!$util.isInteger(message.MsgSeq))
                        return "MsgSeq: integer expected";
                if (message.MsgTime != null && message.hasOwnProperty("MsgTime"))
                    if (!$util.isInteger(message.MsgTime))
                        return "MsgTime: integer expected";
                if (message.MsgUid != null && message.hasOwnProperty("MsgUid"))
                    if (!$util.isInteger(message.MsgUid) && !(message.MsgUid && $util.isInteger(message.MsgUid.low) && $util.isInteger(message.MsgUid.high)))
                        return "MsgUid: integer|Long expected";
                if (message.C2CTmpMsgHead != null && message.hasOwnProperty("C2CTmpMsgHead")) {
                    var error = $root.Msg.MsgField.C2cTmpMsgHead.verify(message.C2CTmpMsgHead);
                    if (error)
                        return "C2CTmpMsgHead." + error;
                }
                if (message.GroupInfo != null && message.hasOwnProperty("GroupInfo")) {
                    var error = $root.Msg.MsgField.GroupInfo.verify(message.GroupInfo);
                    if (error)
                        return "GroupInfo." + error;
                }
                if (message.FromAppid != null && message.hasOwnProperty("FromAppid"))
                    if (!$util.isInteger(message.FromAppid))
                        return "FromAppid: integer expected";
                if (message.FromInstid != null && message.hasOwnProperty("FromInstid"))
                    if (!$util.isInteger(message.FromInstid))
                        return "FromInstid: integer expected";
                if (message.UserActive != null && message.hasOwnProperty("UserActive"))
                    if (!$util.isInteger(message.UserActive))
                        return "UserActive: integer expected";
                if (message.DiscussInfo != null && message.hasOwnProperty("DiscussInfo")) {
                    var error = $root.Msg.MsgField.DiscussInfo.verify(message.DiscussInfo);
                    if (error)
                        return "DiscussInfo." + error;
                }
                if (message.FromNick != null && message.hasOwnProperty("FromNick"))
                    if (!$util.isString(message.FromNick))
                        return "FromNick: string expected";
                if (message.AuthUin != null && message.hasOwnProperty("AuthUin"))
                    if (!$util.isInteger(message.AuthUin) && !(message.AuthUin && $util.isInteger(message.AuthUin.low) && $util.isInteger(message.AuthUin.high)))
                        return "AuthUin: integer|Long expected";
                if (message.AuthString != null && message.hasOwnProperty("AuthString"))
                    if (!$util.isString(message.AuthString))
                        return "AuthString: string expected";
                if (message.MsgFlag != null && message.hasOwnProperty("MsgFlag"))
                    if (!$util.isInteger(message.MsgFlag))
                        return "MsgFlag: integer expected";
                if (message.AuthRemark != null && message.hasOwnProperty("AuthRemark"))
                    if (!$util.isString(message.AuthRemark))
                        return "AuthRemark: string expected";
                if (message.GroupName != null && message.hasOwnProperty("GroupName"))
                    if (!(message.GroupName && typeof message.GroupName.length === "number" || $util.isString(message.GroupName)))
                        return "GroupName: buffer expected";
                if (message.MutilTransHead != null && message.hasOwnProperty("MutilTransHead")) {
                    var error = $root.Msg.MsgField.MutilTransHead.verify(message.MutilTransHead);
                    if (error)
                        return "MutilTransHead." + error;
                }
                if (message.MsgInstCtrl != null && message.hasOwnProperty("MsgInstCtrl")) {
                    var error = $root.Msg.MsgField.ImMsgHead.InstCtrl.verify(message.MsgInstCtrl);
                    if (error)
                        return "MsgInstCtrl." + error;
                }
                if (message.PublicAccountGroupSendFlag != null && message.hasOwnProperty("PublicAccountGroupSendFlag"))
                    if (!$util.isInteger(message.PublicAccountGroupSendFlag))
                        return "PublicAccountGroupSendFlag: integer expected";
                if (message.WseqInC2cMsghead != null && message.hasOwnProperty("WseqInC2cMsghead"))
                    if (!$util.isInteger(message.WseqInC2cMsghead))
                        return "WseqInC2cMsghead: integer expected";
                if (message.Cpid != null && message.hasOwnProperty("Cpid"))
                    if (!$util.isInteger(message.Cpid) && !(message.Cpid && $util.isInteger(message.Cpid.low) && $util.isInteger(message.Cpid.high)))
                        return "Cpid: integer|Long expected";
                if (message.ExtGroupKeyInfo != null && message.hasOwnProperty("ExtGroupKeyInfo")) {
                    var error = $root.Msg.MsgField.ExtGroupKeyInfo.verify(message.ExtGroupKeyInfo);
                    if (error)
                        return "ExtGroupKeyInfo." + error;
                }
                if (message.MultiCompatibleText != null && message.hasOwnProperty("MultiCompatibleText"))
                    if (!$util.isString(message.MultiCompatibleText))
                        return "MultiCompatibleText: string expected";
                if (message.AuthSex != null && message.hasOwnProperty("AuthSex"))
                    if (!$util.isInteger(message.AuthSex))
                        return "AuthSex: integer expected";
                if (message.IsSrcMsg != null && message.hasOwnProperty("IsSrcMsg"))
                    if (typeof message.IsSrcMsg !== "boolean")
                        return "IsSrcMsg: boolean expected";
                return null;
            };

            /**
             * Creates a MsgHead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.MsgHead} MsgHead
             */
            MsgHead.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.MsgHead)
                    return object;
                var message = new $root.Msg.MsgField.MsgHead();
                if (object.FromUin != null)
                    if ($util.Long)
                        (message.FromUin = $util.Long.fromValue(object.FromUin)).unsigned = false;
                    else if (typeof object.FromUin === "string")
                        message.FromUin = parseInt(object.FromUin, 10);
                    else if (typeof object.FromUin === "number")
                        message.FromUin = object.FromUin;
                    else if (typeof object.FromUin === "object")
                        message.FromUin = new $util.LongBits(object.FromUin.low >>> 0, object.FromUin.high >>> 0).toNumber();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.MsgType != null)
                    message.MsgType = object.MsgType | 0;
                if (object.C2cCmd != null)
                    message.C2cCmd = object.C2cCmd | 0;
                if (object.MsgSeq != null)
                    message.MsgSeq = object.MsgSeq | 0;
                if (object.MsgTime != null)
                    message.MsgTime = object.MsgTime | 0;
                if (object.MsgUid != null)
                    if ($util.Long)
                        (message.MsgUid = $util.Long.fromValue(object.MsgUid)).unsigned = false;
                    else if (typeof object.MsgUid === "string")
                        message.MsgUid = parseInt(object.MsgUid, 10);
                    else if (typeof object.MsgUid === "number")
                        message.MsgUid = object.MsgUid;
                    else if (typeof object.MsgUid === "object")
                        message.MsgUid = new $util.LongBits(object.MsgUid.low >>> 0, object.MsgUid.high >>> 0).toNumber();
                if (object.C2CTmpMsgHead != null) {
                    if (typeof object.C2CTmpMsgHead !== "object")
                        throw TypeError(".Msg.MsgField.MsgHead.C2CTmpMsgHead: object expected");
                    message.C2CTmpMsgHead = $root.Msg.MsgField.C2cTmpMsgHead.fromObject(object.C2CTmpMsgHead);
                }
                if (object.GroupInfo != null) {
                    if (typeof object.GroupInfo !== "object")
                        throw TypeError(".Msg.MsgField.MsgHead.GroupInfo: object expected");
                    message.GroupInfo = $root.Msg.MsgField.GroupInfo.fromObject(object.GroupInfo);
                }
                if (object.FromAppid != null)
                    message.FromAppid = object.FromAppid | 0;
                if (object.FromInstid != null)
                    message.FromInstid = object.FromInstid | 0;
                if (object.UserActive != null)
                    message.UserActive = object.UserActive | 0;
                if (object.DiscussInfo != null) {
                    if (typeof object.DiscussInfo !== "object")
                        throw TypeError(".Msg.MsgField.MsgHead.DiscussInfo: object expected");
                    message.DiscussInfo = $root.Msg.MsgField.DiscussInfo.fromObject(object.DiscussInfo);
                }
                if (object.FromNick != null)
                    message.FromNick = String(object.FromNick);
                if (object.AuthUin != null)
                    if ($util.Long)
                        (message.AuthUin = $util.Long.fromValue(object.AuthUin)).unsigned = false;
                    else if (typeof object.AuthUin === "string")
                        message.AuthUin = parseInt(object.AuthUin, 10);
                    else if (typeof object.AuthUin === "number")
                        message.AuthUin = object.AuthUin;
                    else if (typeof object.AuthUin === "object")
                        message.AuthUin = new $util.LongBits(object.AuthUin.low >>> 0, object.AuthUin.high >>> 0).toNumber();
                if (object.AuthString != null)
                    message.AuthString = String(object.AuthString);
                if (object.MsgFlag != null)
                    message.MsgFlag = object.MsgFlag | 0;
                if (object.AuthRemark != null)
                    message.AuthRemark = String(object.AuthRemark);
                if (object.GroupName != null)
                    if (typeof object.GroupName === "string")
                        $util.base64.decode(object.GroupName, message.GroupName = $util.newBuffer($util.base64.length(object.GroupName)), 0);
                    else if (object.GroupName.length)
                        message.GroupName = object.GroupName;
                if (object.MutilTransHead != null) {
                    if (typeof object.MutilTransHead !== "object")
                        throw TypeError(".Msg.MsgField.MsgHead.MutilTransHead: object expected");
                    message.MutilTransHead = $root.Msg.MsgField.MutilTransHead.fromObject(object.MutilTransHead);
                }
                if (object.MsgInstCtrl != null) {
                    if (typeof object.MsgInstCtrl !== "object")
                        throw TypeError(".Msg.MsgField.MsgHead.MsgInstCtrl: object expected");
                    message.MsgInstCtrl = $root.Msg.MsgField.ImMsgHead.InstCtrl.fromObject(object.MsgInstCtrl);
                }
                if (object.PublicAccountGroupSendFlag != null)
                    message.PublicAccountGroupSendFlag = object.PublicAccountGroupSendFlag | 0;
                if (object.WseqInC2cMsghead != null)
                    message.WseqInC2cMsghead = object.WseqInC2cMsghead | 0;
                if (object.Cpid != null)
                    if ($util.Long)
                        (message.Cpid = $util.Long.fromValue(object.Cpid)).unsigned = false;
                    else if (typeof object.Cpid === "string")
                        message.Cpid = parseInt(object.Cpid, 10);
                    else if (typeof object.Cpid === "number")
                        message.Cpid = object.Cpid;
                    else if (typeof object.Cpid === "object")
                        message.Cpid = new $util.LongBits(object.Cpid.low >>> 0, object.Cpid.high >>> 0).toNumber();
                if (object.ExtGroupKeyInfo != null) {
                    if (typeof object.ExtGroupKeyInfo !== "object")
                        throw TypeError(".Msg.MsgField.MsgHead.ExtGroupKeyInfo: object expected");
                    message.ExtGroupKeyInfo = $root.Msg.MsgField.ExtGroupKeyInfo.fromObject(object.ExtGroupKeyInfo);
                }
                if (object.MultiCompatibleText != null)
                    message.MultiCompatibleText = String(object.MultiCompatibleText);
                if (object.AuthSex != null)
                    message.AuthSex = object.AuthSex | 0;
                if (object.IsSrcMsg != null)
                    message.IsSrcMsg = Boolean(object.IsSrcMsg);
                return message;
            };

            /**
             * Creates a plain object from a MsgHead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.MsgHead
             * @static
             * @param {Msg.MsgField.MsgHead} message MsgHead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgHead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.FromUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.FromUin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    object.MsgType = 0;
                    object.C2cCmd = 0;
                    object.MsgSeq = 0;
                    object.MsgTime = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.MsgUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.MsgUid = options.longs === String ? "0" : 0;
                    object.C2CTmpMsgHead = null;
                    object.GroupInfo = null;
                    object.FromAppid = 0;
                    object.FromInstid = 0;
                    object.UserActive = 0;
                    object.DiscussInfo = null;
                    object.FromNick = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.AuthUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.AuthUin = options.longs === String ? "0" : 0;
                    object.AuthString = "";
                    object.MsgFlag = 0;
                    object.AuthRemark = "";
                    if (options.bytes === String)
                        object.GroupName = "";
                    else {
                        object.GroupName = [];
                        if (options.bytes !== Array)
                            object.GroupName = $util.newBuffer(object.GroupName);
                    }
                    object.MutilTransHead = null;
                    object.MsgInstCtrl = null;
                    object.PublicAccountGroupSendFlag = 0;
                    object.WseqInC2cMsghead = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Cpid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Cpid = options.longs === String ? "0" : 0;
                    object.ExtGroupKeyInfo = null;
                    object.MultiCompatibleText = "";
                    object.AuthSex = 0;
                    object.IsSrcMsg = false;
                }
                if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                    if (typeof message.FromUin === "number")
                        object.FromUin = options.longs === String ? String(message.FromUin) : message.FromUin;
                    else
                        object.FromUin = options.longs === String ? $util.Long.prototype.toString.call(message.FromUin) : options.longs === Number ? new $util.LongBits(message.FromUin.low >>> 0, message.FromUin.high >>> 0).toNumber() : message.FromUin;
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                    object.MsgType = message.MsgType;
                if (message.C2cCmd != null && message.hasOwnProperty("C2cCmd"))
                    object.C2cCmd = message.C2cCmd;
                if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                    object.MsgSeq = message.MsgSeq;
                if (message.MsgTime != null && message.hasOwnProperty("MsgTime"))
                    object.MsgTime = message.MsgTime;
                if (message.MsgUid != null && message.hasOwnProperty("MsgUid"))
                    if (typeof message.MsgUid === "number")
                        object.MsgUid = options.longs === String ? String(message.MsgUid) : message.MsgUid;
                    else
                        object.MsgUid = options.longs === String ? $util.Long.prototype.toString.call(message.MsgUid) : options.longs === Number ? new $util.LongBits(message.MsgUid.low >>> 0, message.MsgUid.high >>> 0).toNumber() : message.MsgUid;
                if (message.C2CTmpMsgHead != null && message.hasOwnProperty("C2CTmpMsgHead"))
                    object.C2CTmpMsgHead = $root.Msg.MsgField.C2cTmpMsgHead.toObject(message.C2CTmpMsgHead, options);
                if (message.GroupInfo != null && message.hasOwnProperty("GroupInfo"))
                    object.GroupInfo = $root.Msg.MsgField.GroupInfo.toObject(message.GroupInfo, options);
                if (message.FromAppid != null && message.hasOwnProperty("FromAppid"))
                    object.FromAppid = message.FromAppid;
                if (message.FromInstid != null && message.hasOwnProperty("FromInstid"))
                    object.FromInstid = message.FromInstid;
                if (message.UserActive != null && message.hasOwnProperty("UserActive"))
                    object.UserActive = message.UserActive;
                if (message.DiscussInfo != null && message.hasOwnProperty("DiscussInfo"))
                    object.DiscussInfo = $root.Msg.MsgField.DiscussInfo.toObject(message.DiscussInfo, options);
                if (message.FromNick != null && message.hasOwnProperty("FromNick"))
                    object.FromNick = message.FromNick;
                if (message.AuthUin != null && message.hasOwnProperty("AuthUin"))
                    if (typeof message.AuthUin === "number")
                        object.AuthUin = options.longs === String ? String(message.AuthUin) : message.AuthUin;
                    else
                        object.AuthUin = options.longs === String ? $util.Long.prototype.toString.call(message.AuthUin) : options.longs === Number ? new $util.LongBits(message.AuthUin.low >>> 0, message.AuthUin.high >>> 0).toNumber() : message.AuthUin;
                if (message.AuthString != null && message.hasOwnProperty("AuthString"))
                    object.AuthString = message.AuthString;
                if (message.MsgFlag != null && message.hasOwnProperty("MsgFlag"))
                    object.MsgFlag = message.MsgFlag;
                if (message.AuthRemark != null && message.hasOwnProperty("AuthRemark"))
                    object.AuthRemark = message.AuthRemark;
                if (message.GroupName != null && message.hasOwnProperty("GroupName"))
                    object.GroupName = options.bytes === String ? $util.base64.encode(message.GroupName, 0, message.GroupName.length) : options.bytes === Array ? Array.prototype.slice.call(message.GroupName) : message.GroupName;
                if (message.MutilTransHead != null && message.hasOwnProperty("MutilTransHead"))
                    object.MutilTransHead = $root.Msg.MsgField.MutilTransHead.toObject(message.MutilTransHead, options);
                if (message.MsgInstCtrl != null && message.hasOwnProperty("MsgInstCtrl"))
                    object.MsgInstCtrl = $root.Msg.MsgField.ImMsgHead.InstCtrl.toObject(message.MsgInstCtrl, options);
                if (message.PublicAccountGroupSendFlag != null && message.hasOwnProperty("PublicAccountGroupSendFlag"))
                    object.PublicAccountGroupSendFlag = message.PublicAccountGroupSendFlag;
                if (message.WseqInC2cMsghead != null && message.hasOwnProperty("WseqInC2cMsghead"))
                    object.WseqInC2cMsghead = message.WseqInC2cMsghead;
                if (message.Cpid != null && message.hasOwnProperty("Cpid"))
                    if (typeof message.Cpid === "number")
                        object.Cpid = options.longs === String ? String(message.Cpid) : message.Cpid;
                    else
                        object.Cpid = options.longs === String ? $util.Long.prototype.toString.call(message.Cpid) : options.longs === Number ? new $util.LongBits(message.Cpid.low >>> 0, message.Cpid.high >>> 0).toNumber() : message.Cpid;
                if (message.ExtGroupKeyInfo != null && message.hasOwnProperty("ExtGroupKeyInfo"))
                    object.ExtGroupKeyInfo = $root.Msg.MsgField.ExtGroupKeyInfo.toObject(message.ExtGroupKeyInfo, options);
                if (message.MultiCompatibleText != null && message.hasOwnProperty("MultiCompatibleText"))
                    object.MultiCompatibleText = message.MultiCompatibleText;
                if (message.AuthSex != null && message.hasOwnProperty("AuthSex"))
                    object.AuthSex = message.AuthSex;
                if (message.IsSrcMsg != null && message.hasOwnProperty("IsSrcMsg"))
                    object.IsSrcMsg = message.IsSrcMsg;
                return object;
            };

            /**
             * Converts this MsgHead to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.MsgHead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgHead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgHead;
        })();

        MsgField.ContentHead = (function() {

            /**
             * Properties of a ContentHead.
             * @memberof Msg.MsgField
             * @interface IContentHead
             * @property {number|null} [PkgNum] ContentHead PkgNum
             * @property {number|null} [PkgIndex] ContentHead PkgIndex
             * @property {number|null} [DivSeq] ContentHead DivSeq
             * @property {number|null} [AutoReply] ContentHead AutoReply
             */

            /**
             * Constructs a new ContentHead.
             * @memberof Msg.MsgField
             * @classdesc Represents a ContentHead.
             * @implements IContentHead
             * @constructor
             * @param {Msg.MsgField.IContentHead=} [properties] Properties to set
             */
            function ContentHead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContentHead PkgNum.
             * @member {number} PkgNum
             * @memberof Msg.MsgField.ContentHead
             * @instance
             */
            ContentHead.prototype.PkgNum = 0;

            /**
             * ContentHead PkgIndex.
             * @member {number} PkgIndex
             * @memberof Msg.MsgField.ContentHead
             * @instance
             */
            ContentHead.prototype.PkgIndex = 0;

            /**
             * ContentHead DivSeq.
             * @member {number} DivSeq
             * @memberof Msg.MsgField.ContentHead
             * @instance
             */
            ContentHead.prototype.DivSeq = 0;

            /**
             * ContentHead AutoReply.
             * @member {number} AutoReply
             * @memberof Msg.MsgField.ContentHead
             * @instance
             */
            ContentHead.prototype.AutoReply = 0;

            /**
             * Creates a new ContentHead instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {Msg.MsgField.IContentHead=} [properties] Properties to set
             * @returns {Msg.MsgField.ContentHead} ContentHead instance
             */
            ContentHead.create = function create(properties) {
                return new ContentHead(properties);
            };

            /**
             * Encodes the specified ContentHead message. Does not implicitly {@link Msg.MsgField.ContentHead.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {Msg.MsgField.IContentHead} message ContentHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContentHead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.PkgNum != null && Object.hasOwnProperty.call(message, "PkgNum"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PkgNum);
                if (message.PkgIndex != null && Object.hasOwnProperty.call(message, "PkgIndex"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PkgIndex);
                if (message.DivSeq != null && Object.hasOwnProperty.call(message, "DivSeq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.DivSeq);
                if (message.AutoReply != null && Object.hasOwnProperty.call(message, "AutoReply"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.AutoReply);
                return writer;
            };

            /**
             * Encodes the specified ContentHead message, length delimited. Does not implicitly {@link Msg.MsgField.ContentHead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {Msg.MsgField.IContentHead} message ContentHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContentHead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContentHead message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.ContentHead} ContentHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContentHead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ContentHead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.PkgNum = reader.int32();
                        break;
                    case 2:
                        message.PkgIndex = reader.int32();
                        break;
                    case 3:
                        message.DivSeq = reader.int32();
                        break;
                    case 4:
                        message.AutoReply = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContentHead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.ContentHead} ContentHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContentHead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContentHead message.
             * @function verify
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContentHead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.PkgNum != null && message.hasOwnProperty("PkgNum"))
                    if (!$util.isInteger(message.PkgNum))
                        return "PkgNum: integer expected";
                if (message.PkgIndex != null && message.hasOwnProperty("PkgIndex"))
                    if (!$util.isInteger(message.PkgIndex))
                        return "PkgIndex: integer expected";
                if (message.DivSeq != null && message.hasOwnProperty("DivSeq"))
                    if (!$util.isInteger(message.DivSeq))
                        return "DivSeq: integer expected";
                if (message.AutoReply != null && message.hasOwnProperty("AutoReply"))
                    if (!$util.isInteger(message.AutoReply))
                        return "AutoReply: integer expected";
                return null;
            };

            /**
             * Creates a ContentHead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.ContentHead} ContentHead
             */
            ContentHead.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.ContentHead)
                    return object;
                var message = new $root.Msg.MsgField.ContentHead();
                if (object.PkgNum != null)
                    message.PkgNum = object.PkgNum | 0;
                if (object.PkgIndex != null)
                    message.PkgIndex = object.PkgIndex | 0;
                if (object.DivSeq != null)
                    message.DivSeq = object.DivSeq | 0;
                if (object.AutoReply != null)
                    message.AutoReply = object.AutoReply | 0;
                return message;
            };

            /**
             * Creates a plain object from a ContentHead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.ContentHead
             * @static
             * @param {Msg.MsgField.ContentHead} message ContentHead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContentHead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.PkgNum = 0;
                    object.PkgIndex = 0;
                    object.DivSeq = 0;
                    object.AutoReply = 0;
                }
                if (message.PkgNum != null && message.hasOwnProperty("PkgNum"))
                    object.PkgNum = message.PkgNum;
                if (message.PkgIndex != null && message.hasOwnProperty("PkgIndex"))
                    object.PkgIndex = message.PkgIndex;
                if (message.DivSeq != null && message.hasOwnProperty("DivSeq"))
                    object.DivSeq = message.DivSeq;
                if (message.AutoReply != null && message.hasOwnProperty("AutoReply"))
                    object.AutoReply = message.AutoReply;
                return object;
            };

            /**
             * Converts this ContentHead to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.ContentHead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContentHead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ContentHead;
        })();

        MsgField.Msg = (function() {

            /**
             * Properties of a Msg.
             * @memberof Msg.MsgField
             * @interface IMsg
             * @property {Msg.MsgField.IMsgHead|null} [MsgHead] Msg MsgHead
             * @property {Msg.MsgField.IContentHead|null} [ContentHead] Msg ContentHead
             * @property {Msg.MsgField.ImMsgBody.IMsgBody|null} [MsgBody] Msg MsgBody
             * @property {Msg.MsgField.IAppShareInfo|null} [AppshareInfo] Msg AppshareInfo
             */

            /**
             * Constructs a new Msg.
             * @memberof Msg.MsgField
             * @classdesc Represents a Msg.
             * @implements IMsg
             * @constructor
             * @param {Msg.MsgField.IMsg=} [properties] Properties to set
             */
            function Msg(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Msg MsgHead.
             * @member {Msg.MsgField.IMsgHead|null|undefined} MsgHead
             * @memberof Msg.MsgField.Msg
             * @instance
             */
            Msg.prototype.MsgHead = null;

            /**
             * Msg ContentHead.
             * @member {Msg.MsgField.IContentHead|null|undefined} ContentHead
             * @memberof Msg.MsgField.Msg
             * @instance
             */
            Msg.prototype.ContentHead = null;

            /**
             * Msg MsgBody.
             * @member {Msg.MsgField.ImMsgBody.IMsgBody|null|undefined} MsgBody
             * @memberof Msg.MsgField.Msg
             * @instance
             */
            Msg.prototype.MsgBody = null;

            /**
             * Msg AppshareInfo.
             * @member {Msg.MsgField.IAppShareInfo|null|undefined} AppshareInfo
             * @memberof Msg.MsgField.Msg
             * @instance
             */
            Msg.prototype.AppshareInfo = null;

            /**
             * Creates a new Msg instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {Msg.MsgField.IMsg=} [properties] Properties to set
             * @returns {Msg.MsgField.Msg} Msg instance
             */
            Msg.create = function create(properties) {
                return new Msg(properties);
            };

            /**
             * Encodes the specified Msg message. Does not implicitly {@link Msg.MsgField.Msg.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {Msg.MsgField.IMsg} message Msg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Msg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.MsgHead != null && Object.hasOwnProperty.call(message, "MsgHead"))
                    $root.Msg.MsgField.MsgHead.encode(message.MsgHead, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.ContentHead != null && Object.hasOwnProperty.call(message, "ContentHead"))
                    $root.Msg.MsgField.ContentHead.encode(message.ContentHead, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.MsgBody != null && Object.hasOwnProperty.call(message, "MsgBody"))
                    $root.Msg.MsgField.ImMsgBody.MsgBody.encode(message.MsgBody, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.AppshareInfo != null && Object.hasOwnProperty.call(message, "AppshareInfo"))
                    $root.Msg.MsgField.AppShareInfo.encode(message.AppshareInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Msg message, length delimited. Does not implicitly {@link Msg.MsgField.Msg.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {Msg.MsgField.IMsg} message Msg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Msg.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Msg message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.Msg} Msg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Msg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.Msg();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.MsgHead = $root.Msg.MsgField.MsgHead.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.ContentHead = $root.Msg.MsgField.ContentHead.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.MsgBody = $root.Msg.MsgField.ImMsgBody.MsgBody.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.AppshareInfo = $root.Msg.MsgField.AppShareInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Msg message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.Msg} Msg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Msg.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Msg message.
             * @function verify
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Msg.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.MsgHead != null && message.hasOwnProperty("MsgHead")) {
                    var error = $root.Msg.MsgField.MsgHead.verify(message.MsgHead);
                    if (error)
                        return "MsgHead." + error;
                }
                if (message.ContentHead != null && message.hasOwnProperty("ContentHead")) {
                    var error = $root.Msg.MsgField.ContentHead.verify(message.ContentHead);
                    if (error)
                        return "ContentHead." + error;
                }
                if (message.MsgBody != null && message.hasOwnProperty("MsgBody")) {
                    var error = $root.Msg.MsgField.ImMsgBody.MsgBody.verify(message.MsgBody);
                    if (error)
                        return "MsgBody." + error;
                }
                if (message.AppshareInfo != null && message.hasOwnProperty("AppshareInfo")) {
                    var error = $root.Msg.MsgField.AppShareInfo.verify(message.AppshareInfo);
                    if (error)
                        return "AppshareInfo." + error;
                }
                return null;
            };

            /**
             * Creates a Msg message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.Msg} Msg
             */
            Msg.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.Msg)
                    return object;
                var message = new $root.Msg.MsgField.Msg();
                if (object.MsgHead != null) {
                    if (typeof object.MsgHead !== "object")
                        throw TypeError(".Msg.MsgField.Msg.MsgHead: object expected");
                    message.MsgHead = $root.Msg.MsgField.MsgHead.fromObject(object.MsgHead);
                }
                if (object.ContentHead != null) {
                    if (typeof object.ContentHead !== "object")
                        throw TypeError(".Msg.MsgField.Msg.ContentHead: object expected");
                    message.ContentHead = $root.Msg.MsgField.ContentHead.fromObject(object.ContentHead);
                }
                if (object.MsgBody != null) {
                    if (typeof object.MsgBody !== "object")
                        throw TypeError(".Msg.MsgField.Msg.MsgBody: object expected");
                    message.MsgBody = $root.Msg.MsgField.ImMsgBody.MsgBody.fromObject(object.MsgBody);
                }
                if (object.AppshareInfo != null) {
                    if (typeof object.AppshareInfo !== "object")
                        throw TypeError(".Msg.MsgField.Msg.AppshareInfo: object expected");
                    message.AppshareInfo = $root.Msg.MsgField.AppShareInfo.fromObject(object.AppshareInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a Msg message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.Msg
             * @static
             * @param {Msg.MsgField.Msg} message Msg
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Msg.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.MsgHead = null;
                    object.ContentHead = null;
                    object.MsgBody = null;
                    object.AppshareInfo = null;
                }
                if (message.MsgHead != null && message.hasOwnProperty("MsgHead"))
                    object.MsgHead = $root.Msg.MsgField.MsgHead.toObject(message.MsgHead, options);
                if (message.ContentHead != null && message.hasOwnProperty("ContentHead"))
                    object.ContentHead = $root.Msg.MsgField.ContentHead.toObject(message.ContentHead, options);
                if (message.MsgBody != null && message.hasOwnProperty("MsgBody"))
                    object.MsgBody = $root.Msg.MsgField.ImMsgBody.MsgBody.toObject(message.MsgBody, options);
                if (message.AppshareInfo != null && message.hasOwnProperty("AppshareInfo"))
                    object.AppshareInfo = $root.Msg.MsgField.AppShareInfo.toObject(message.AppshareInfo, options);
                return object;
            };

            /**
             * Converts this Msg to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.Msg
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Msg.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Msg;
        })();

        MsgField.UinPairMsg = (function() {

            /**
             * Properties of an UinPairMsg.
             * @memberof Msg.MsgField
             * @interface IUinPairMsg
             * @property {number|null} [LastReadTime] UinPairMsg LastReadTime
             * @property {number|Long|null} [PeerUin] UinPairMsg PeerUin
             * @property {number|null} [MsgCompleted] UinPairMsg MsgCompleted
             * @property {Array.<Msg.MsgField.IMsg>|null} [MsgList] UinPairMsg MsgList
             * @property {number|null} [UnreadMsgNum] UinPairMsg UnreadMsgNum
             * @property {number|null} [C2cType] UinPairMsg C2cType
             * @property {number|null} [serviceType] UinPairMsg serviceType
             * @property {Uint8Array|null} [PbReserve] UinPairMsg PbReserve
             */

            /**
             * Constructs a new UinPairMsg.
             * @memberof Msg.MsgField
             * @classdesc Represents an UinPairMsg.
             * @implements IUinPairMsg
             * @constructor
             * @param {Msg.MsgField.IUinPairMsg=} [properties] Properties to set
             */
            function UinPairMsg(properties) {
                this.MsgList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UinPairMsg LastReadTime.
             * @member {number} LastReadTime
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.LastReadTime = 0;

            /**
             * UinPairMsg PeerUin.
             * @member {number|Long} PeerUin
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.PeerUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UinPairMsg MsgCompleted.
             * @member {number} MsgCompleted
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.MsgCompleted = 0;

            /**
             * UinPairMsg MsgList.
             * @member {Array.<Msg.MsgField.IMsg>} MsgList
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.MsgList = $util.emptyArray;

            /**
             * UinPairMsg UnreadMsgNum.
             * @member {number} UnreadMsgNum
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.UnreadMsgNum = 0;

            /**
             * UinPairMsg C2cType.
             * @member {number} C2cType
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.C2cType = 0;

            /**
             * UinPairMsg serviceType.
             * @member {number} serviceType
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.serviceType = 0;

            /**
             * UinPairMsg PbReserve.
             * @member {Uint8Array} PbReserve
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             */
            UinPairMsg.prototype.PbReserve = $util.newBuffer([]);

            /**
             * Creates a new UinPairMsg instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {Msg.MsgField.IUinPairMsg=} [properties] Properties to set
             * @returns {Msg.MsgField.UinPairMsg} UinPairMsg instance
             */
            UinPairMsg.create = function create(properties) {
                return new UinPairMsg(properties);
            };

            /**
             * Encodes the specified UinPairMsg message. Does not implicitly {@link Msg.MsgField.UinPairMsg.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {Msg.MsgField.IUinPairMsg} message UinPairMsg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UinPairMsg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.LastReadTime != null && Object.hasOwnProperty.call(message, "LastReadTime"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.LastReadTime);
                if (message.PeerUin != null && Object.hasOwnProperty.call(message, "PeerUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.PeerUin);
                if (message.MsgCompleted != null && Object.hasOwnProperty.call(message, "MsgCompleted"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MsgCompleted);
                if (message.MsgList != null && message.MsgList.length)
                    for (var i = 0; i < message.MsgList.length; ++i)
                        $root.Msg.MsgField.Msg.encode(message.MsgList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.UnreadMsgNum != null && Object.hasOwnProperty.call(message, "UnreadMsgNum"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.UnreadMsgNum);
                if (message.C2cType != null && Object.hasOwnProperty.call(message, "C2cType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.C2cType);
                if (message.serviceType != null && Object.hasOwnProperty.call(message, "serviceType"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.serviceType);
                if (message.PbReserve != null && Object.hasOwnProperty.call(message, "PbReserve"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.PbReserve);
                return writer;
            };

            /**
             * Encodes the specified UinPairMsg message, length delimited. Does not implicitly {@link Msg.MsgField.UinPairMsg.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {Msg.MsgField.IUinPairMsg} message UinPairMsg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UinPairMsg.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UinPairMsg message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.UinPairMsg} UinPairMsg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UinPairMsg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.UinPairMsg();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.LastReadTime = reader.int32();
                        break;
                    case 2:
                        message.PeerUin = reader.int64();
                        break;
                    case 3:
                        message.MsgCompleted = reader.int32();
                        break;
                    case 4:
                        if (!(message.MsgList && message.MsgList.length))
                            message.MsgList = [];
                        message.MsgList.push($root.Msg.MsgField.Msg.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.UnreadMsgNum = reader.int32();
                        break;
                    case 8:
                        message.C2cType = reader.int32();
                        break;
                    case 9:
                        message.serviceType = reader.int32();
                        break;
                    case 10:
                        message.PbReserve = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UinPairMsg message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.UinPairMsg} UinPairMsg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UinPairMsg.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UinPairMsg message.
             * @function verify
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UinPairMsg.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.LastReadTime != null && message.hasOwnProperty("LastReadTime"))
                    if (!$util.isInteger(message.LastReadTime))
                        return "LastReadTime: integer expected";
                if (message.PeerUin != null && message.hasOwnProperty("PeerUin"))
                    if (!$util.isInteger(message.PeerUin) && !(message.PeerUin && $util.isInteger(message.PeerUin.low) && $util.isInteger(message.PeerUin.high)))
                        return "PeerUin: integer|Long expected";
                if (message.MsgCompleted != null && message.hasOwnProperty("MsgCompleted"))
                    if (!$util.isInteger(message.MsgCompleted))
                        return "MsgCompleted: integer expected";
                if (message.MsgList != null && message.hasOwnProperty("MsgList")) {
                    if (!Array.isArray(message.MsgList))
                        return "MsgList: array expected";
                    for (var i = 0; i < message.MsgList.length; ++i) {
                        var error = $root.Msg.MsgField.Msg.verify(message.MsgList[i]);
                        if (error)
                            return "MsgList." + error;
                    }
                }
                if (message.UnreadMsgNum != null && message.hasOwnProperty("UnreadMsgNum"))
                    if (!$util.isInteger(message.UnreadMsgNum))
                        return "UnreadMsgNum: integer expected";
                if (message.C2cType != null && message.hasOwnProperty("C2cType"))
                    if (!$util.isInteger(message.C2cType))
                        return "C2cType: integer expected";
                if (message.serviceType != null && message.hasOwnProperty("serviceType"))
                    if (!$util.isInteger(message.serviceType))
                        return "serviceType: integer expected";
                if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                    if (!(message.PbReserve && typeof message.PbReserve.length === "number" || $util.isString(message.PbReserve)))
                        return "PbReserve: buffer expected";
                return null;
            };

            /**
             * Creates an UinPairMsg message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.UinPairMsg} UinPairMsg
             */
            UinPairMsg.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.UinPairMsg)
                    return object;
                var message = new $root.Msg.MsgField.UinPairMsg();
                if (object.LastReadTime != null)
                    message.LastReadTime = object.LastReadTime | 0;
                if (object.PeerUin != null)
                    if ($util.Long)
                        (message.PeerUin = $util.Long.fromValue(object.PeerUin)).unsigned = false;
                    else if (typeof object.PeerUin === "string")
                        message.PeerUin = parseInt(object.PeerUin, 10);
                    else if (typeof object.PeerUin === "number")
                        message.PeerUin = object.PeerUin;
                    else if (typeof object.PeerUin === "object")
                        message.PeerUin = new $util.LongBits(object.PeerUin.low >>> 0, object.PeerUin.high >>> 0).toNumber();
                if (object.MsgCompleted != null)
                    message.MsgCompleted = object.MsgCompleted | 0;
                if (object.MsgList) {
                    if (!Array.isArray(object.MsgList))
                        throw TypeError(".Msg.MsgField.UinPairMsg.MsgList: array expected");
                    message.MsgList = [];
                    for (var i = 0; i < object.MsgList.length; ++i) {
                        if (typeof object.MsgList[i] !== "object")
                            throw TypeError(".Msg.MsgField.UinPairMsg.MsgList: object expected");
                        message.MsgList[i] = $root.Msg.MsgField.Msg.fromObject(object.MsgList[i]);
                    }
                }
                if (object.UnreadMsgNum != null)
                    message.UnreadMsgNum = object.UnreadMsgNum | 0;
                if (object.C2cType != null)
                    message.C2cType = object.C2cType | 0;
                if (object.serviceType != null)
                    message.serviceType = object.serviceType | 0;
                if (object.PbReserve != null)
                    if (typeof object.PbReserve === "string")
                        $util.base64.decode(object.PbReserve, message.PbReserve = $util.newBuffer($util.base64.length(object.PbReserve)), 0);
                    else if (object.PbReserve.length)
                        message.PbReserve = object.PbReserve;
                return message;
            };

            /**
             * Creates a plain object from an UinPairMsg message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.UinPairMsg
             * @static
             * @param {Msg.MsgField.UinPairMsg} message UinPairMsg
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UinPairMsg.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.MsgList = [];
                if (options.defaults) {
                    object.LastReadTime = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.PeerUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.PeerUin = options.longs === String ? "0" : 0;
                    object.MsgCompleted = 0;
                    object.UnreadMsgNum = 0;
                    object.C2cType = 0;
                    object.serviceType = 0;
                    if (options.bytes === String)
                        object.PbReserve = "";
                    else {
                        object.PbReserve = [];
                        if (options.bytes !== Array)
                            object.PbReserve = $util.newBuffer(object.PbReserve);
                    }
                }
                if (message.LastReadTime != null && message.hasOwnProperty("LastReadTime"))
                    object.LastReadTime = message.LastReadTime;
                if (message.PeerUin != null && message.hasOwnProperty("PeerUin"))
                    if (typeof message.PeerUin === "number")
                        object.PeerUin = options.longs === String ? String(message.PeerUin) : message.PeerUin;
                    else
                        object.PeerUin = options.longs === String ? $util.Long.prototype.toString.call(message.PeerUin) : options.longs === Number ? new $util.LongBits(message.PeerUin.low >>> 0, message.PeerUin.high >>> 0).toNumber() : message.PeerUin;
                if (message.MsgCompleted != null && message.hasOwnProperty("MsgCompleted"))
                    object.MsgCompleted = message.MsgCompleted;
                if (message.MsgList && message.MsgList.length) {
                    object.MsgList = [];
                    for (var j = 0; j < message.MsgList.length; ++j)
                        object.MsgList[j] = $root.Msg.MsgField.Msg.toObject(message.MsgList[j], options);
                }
                if (message.UnreadMsgNum != null && message.hasOwnProperty("UnreadMsgNum"))
                    object.UnreadMsgNum = message.UnreadMsgNum;
                if (message.C2cType != null && message.hasOwnProperty("C2cType"))
                    object.C2cType = message.C2cType;
                if (message.serviceType != null && message.hasOwnProperty("serviceType"))
                    object.serviceType = message.serviceType;
                if (message.PbReserve != null && message.hasOwnProperty("PbReserve"))
                    object.PbReserve = options.bytes === String ? $util.base64.encode(message.PbReserve, 0, message.PbReserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.PbReserve) : message.PbReserve;
                return object;
            };

            /**
             * Converts this UinPairMsg to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.UinPairMsg
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UinPairMsg.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UinPairMsg;
        })();

        MsgField.C2c = (function() {

            /**
             * Properties of a C2c.
             * @memberof Msg.MsgField
             * @interface IC2c
             * @property {number|Long|null} [ToUin] C2c ToUin
             */

            /**
             * Constructs a new C2c.
             * @memberof Msg.MsgField
             * @classdesc Represents a C2c.
             * @implements IC2c
             * @constructor
             * @param {Msg.MsgField.IC2c=} [properties] Properties to set
             */
            function C2c(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * C2c ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.C2c
             * @instance
             */
            C2c.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new C2c instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {Msg.MsgField.IC2c=} [properties] Properties to set
             * @returns {Msg.MsgField.C2c} C2c instance
             */
            C2c.create = function create(properties) {
                return new C2c(properties);
            };

            /**
             * Encodes the specified C2c message. Does not implicitly {@link Msg.MsgField.C2c.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {Msg.MsgField.IC2c} message C2c message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2c.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                return writer;
            };

            /**
             * Encodes the specified C2c message, length delimited. Does not implicitly {@link Msg.MsgField.C2c.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {Msg.MsgField.IC2c} message C2c message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            C2c.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a C2c message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.C2c} C2c
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2c.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.C2c();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a C2c message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.C2c} C2c
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            C2c.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a C2c message.
             * @function verify
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            C2c.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                return null;
            };

            /**
             * Creates a C2c message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.C2c} C2c
             */
            C2c.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.C2c)
                    return object;
                var message = new $root.Msg.MsgField.C2c();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a C2c message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.C2c
             * @static
             * @param {Msg.MsgField.C2c} message C2c
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            C2c.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                return object;
            };

            /**
             * Converts this C2c to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.C2c
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            C2c.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return C2c;
        })();

        MsgField.Grp = (function() {

            /**
             * Properties of a Grp.
             * @memberof Msg.MsgField
             * @interface IGrp
             * @property {number|Long|null} [GroupCode] Grp GroupCode
             */

            /**
             * Constructs a new Grp.
             * @memberof Msg.MsgField
             * @classdesc Represents a Grp.
             * @implements IGrp
             * @constructor
             * @param {Msg.MsgField.IGrp=} [properties] Properties to set
             */
            function Grp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Grp GroupCode.
             * @member {number|Long} GroupCode
             * @memberof Msg.MsgField.Grp
             * @instance
             */
            Grp.prototype.GroupCode = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Grp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {Msg.MsgField.IGrp=} [properties] Properties to set
             * @returns {Msg.MsgField.Grp} Grp instance
             */
            Grp.create = function create(properties) {
                return new Grp(properties);
            };

            /**
             * Encodes the specified Grp message. Does not implicitly {@link Msg.MsgField.Grp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {Msg.MsgField.IGrp} message Grp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Grp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.GroupCode != null && Object.hasOwnProperty.call(message, "GroupCode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.GroupCode);
                return writer;
            };

            /**
             * Encodes the specified Grp message, length delimited. Does not implicitly {@link Msg.MsgField.Grp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {Msg.MsgField.IGrp} message Grp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Grp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Grp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.Grp} Grp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Grp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.Grp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.GroupCode = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Grp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.Grp} Grp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Grp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Grp message.
             * @function verify
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Grp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.GroupCode != null && message.hasOwnProperty("GroupCode"))
                    if (!$util.isInteger(message.GroupCode) && !(message.GroupCode && $util.isInteger(message.GroupCode.low) && $util.isInteger(message.GroupCode.high)))
                        return "GroupCode: integer|Long expected";
                return null;
            };

            /**
             * Creates a Grp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.Grp} Grp
             */
            Grp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.Grp)
                    return object;
                var message = new $root.Msg.MsgField.Grp();
                if (object.GroupCode != null)
                    if ($util.Long)
                        (message.GroupCode = $util.Long.fromValue(object.GroupCode)).unsigned = false;
                    else if (typeof object.GroupCode === "string")
                        message.GroupCode = parseInt(object.GroupCode, 10);
                    else if (typeof object.GroupCode === "number")
                        message.GroupCode = object.GroupCode;
                    else if (typeof object.GroupCode === "object")
                        message.GroupCode = new $util.LongBits(object.GroupCode.low >>> 0, object.GroupCode.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Grp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.Grp
             * @static
             * @param {Msg.MsgField.Grp} message Grp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Grp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.GroupCode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.GroupCode = options.longs === String ? "0" : 0;
                if (message.GroupCode != null && message.hasOwnProperty("GroupCode"))
                    if (typeof message.GroupCode === "number")
                        object.GroupCode = options.longs === String ? String(message.GroupCode) : message.GroupCode;
                    else
                        object.GroupCode = options.longs === String ? $util.Long.prototype.toString.call(message.GroupCode) : options.longs === Number ? new $util.LongBits(message.GroupCode.low >>> 0, message.GroupCode.high >>> 0).toNumber() : message.GroupCode;
                return object;
            };

            /**
             * Converts this Grp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.Grp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Grp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Grp;
        })();

        MsgField.GrpTmp = (function() {

            /**
             * Properties of a GrpTmp.
             * @memberof Msg.MsgField
             * @interface IGrpTmp
             * @property {number|Long|null} [GroupUin] GrpTmp GroupUin
             * @property {number|Long|null} [ToUin] GrpTmp ToUin
             */

            /**
             * Constructs a new GrpTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a GrpTmp.
             * @implements IGrpTmp
             * @constructor
             * @param {Msg.MsgField.IGrpTmp=} [properties] Properties to set
             */
            function GrpTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GrpTmp GroupUin.
             * @member {number|Long} GroupUin
             * @memberof Msg.MsgField.GrpTmp
             * @instance
             */
            GrpTmp.prototype.GroupUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GrpTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.GrpTmp
             * @instance
             */
            GrpTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new GrpTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {Msg.MsgField.IGrpTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.GrpTmp} GrpTmp instance
             */
            GrpTmp.create = function create(properties) {
                return new GrpTmp(properties);
            };

            /**
             * Encodes the specified GrpTmp message. Does not implicitly {@link Msg.MsgField.GrpTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {Msg.MsgField.IGrpTmp} message GrpTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GrpTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.GroupUin != null && Object.hasOwnProperty.call(message, "GroupUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.GroupUin);
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ToUin);
                return writer;
            };

            /**
             * Encodes the specified GrpTmp message, length delimited. Does not implicitly {@link Msg.MsgField.GrpTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {Msg.MsgField.IGrpTmp} message GrpTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GrpTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GrpTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.GrpTmp} GrpTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GrpTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.GrpTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.GroupUin = reader.int64();
                        break;
                    case 2:
                        message.ToUin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GrpTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.GrpTmp} GrpTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GrpTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GrpTmp message.
             * @function verify
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GrpTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.GroupUin != null && message.hasOwnProperty("GroupUin"))
                    if (!$util.isInteger(message.GroupUin) && !(message.GroupUin && $util.isInteger(message.GroupUin.low) && $util.isInteger(message.GroupUin.high)))
                        return "GroupUin: integer|Long expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                return null;
            };

            /**
             * Creates a GrpTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.GrpTmp} GrpTmp
             */
            GrpTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.GrpTmp)
                    return object;
                var message = new $root.Msg.MsgField.GrpTmp();
                if (object.GroupUin != null)
                    if ($util.Long)
                        (message.GroupUin = $util.Long.fromValue(object.GroupUin)).unsigned = false;
                    else if (typeof object.GroupUin === "string")
                        message.GroupUin = parseInt(object.GroupUin, 10);
                    else if (typeof object.GroupUin === "number")
                        message.GroupUin = object.GroupUin;
                    else if (typeof object.GroupUin === "object")
                        message.GroupUin = new $util.LongBits(object.GroupUin.low >>> 0, object.GroupUin.high >>> 0).toNumber();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a GrpTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.GrpTmp
             * @static
             * @param {Msg.MsgField.GrpTmp} message GrpTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GrpTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.GroupUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.GroupUin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                }
                if (message.GroupUin != null && message.hasOwnProperty("GroupUin"))
                    if (typeof message.GroupUin === "number")
                        object.GroupUin = options.longs === String ? String(message.GroupUin) : message.GroupUin;
                    else
                        object.GroupUin = options.longs === String ? $util.Long.prototype.toString.call(message.GroupUin) : options.longs === Number ? new $util.LongBits(message.GroupUin.low >>> 0, message.GroupUin.high >>> 0).toNumber() : message.GroupUin;
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                return object;
            };

            /**
             * Converts this GrpTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.GrpTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GrpTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GrpTmp;
        })();

        MsgField.Dis = (function() {

            /**
             * Properties of a Dis.
             * @memberof Msg.MsgField
             * @interface IDis
             * @property {number|Long|null} [DisUin] Dis DisUin
             */

            /**
             * Constructs a new Dis.
             * @memberof Msg.MsgField
             * @classdesc Represents a Dis.
             * @implements IDis
             * @constructor
             * @param {Msg.MsgField.IDis=} [properties] Properties to set
             */
            function Dis(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Dis DisUin.
             * @member {number|Long} DisUin
             * @memberof Msg.MsgField.Dis
             * @instance
             */
            Dis.prototype.DisUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Dis instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {Msg.MsgField.IDis=} [properties] Properties to set
             * @returns {Msg.MsgField.Dis} Dis instance
             */
            Dis.create = function create(properties) {
                return new Dis(properties);
            };

            /**
             * Encodes the specified Dis message. Does not implicitly {@link Msg.MsgField.Dis.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {Msg.MsgField.IDis} message Dis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dis.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.DisUin != null && Object.hasOwnProperty.call(message, "DisUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.DisUin);
                return writer;
            };

            /**
             * Encodes the specified Dis message, length delimited. Does not implicitly {@link Msg.MsgField.Dis.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {Msg.MsgField.IDis} message Dis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dis.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Dis message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.Dis} Dis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dis.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.Dis();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.DisUin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Dis message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.Dis} Dis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dis.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Dis message.
             * @function verify
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Dis.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.DisUin != null && message.hasOwnProperty("DisUin"))
                    if (!$util.isInteger(message.DisUin) && !(message.DisUin && $util.isInteger(message.DisUin.low) && $util.isInteger(message.DisUin.high)))
                        return "DisUin: integer|Long expected";
                return null;
            };

            /**
             * Creates a Dis message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.Dis} Dis
             */
            Dis.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.Dis)
                    return object;
                var message = new $root.Msg.MsgField.Dis();
                if (object.DisUin != null)
                    if ($util.Long)
                        (message.DisUin = $util.Long.fromValue(object.DisUin)).unsigned = false;
                    else if (typeof object.DisUin === "string")
                        message.DisUin = parseInt(object.DisUin, 10);
                    else if (typeof object.DisUin === "number")
                        message.DisUin = object.DisUin;
                    else if (typeof object.DisUin === "object")
                        message.DisUin = new $util.LongBits(object.DisUin.low >>> 0, object.DisUin.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Dis message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.Dis
             * @static
             * @param {Msg.MsgField.Dis} message Dis
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Dis.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.DisUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.DisUin = options.longs === String ? "0" : 0;
                if (message.DisUin != null && message.hasOwnProperty("DisUin"))
                    if (typeof message.DisUin === "number")
                        object.DisUin = options.longs === String ? String(message.DisUin) : message.DisUin;
                    else
                        object.DisUin = options.longs === String ? $util.Long.prototype.toString.call(message.DisUin) : options.longs === Number ? new $util.LongBits(message.DisUin.low >>> 0, message.DisUin.high >>> 0).toNumber() : message.DisUin;
                return object;
            };

            /**
             * Converts this Dis to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.Dis
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Dis.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Dis;
        })();

        MsgField.DisTmp = (function() {

            /**
             * Properties of a DisTmp.
             * @memberof Msg.MsgField
             * @interface IDisTmp
             * @property {number|Long|null} [DisUin] DisTmp DisUin
             * @property {number|Long|null} [ToUin] DisTmp ToUin
             */

            /**
             * Constructs a new DisTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a DisTmp.
             * @implements IDisTmp
             * @constructor
             * @param {Msg.MsgField.IDisTmp=} [properties] Properties to set
             */
            function DisTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DisTmp DisUin.
             * @member {number|Long} DisUin
             * @memberof Msg.MsgField.DisTmp
             * @instance
             */
            DisTmp.prototype.DisUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DisTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.DisTmp
             * @instance
             */
            DisTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new DisTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {Msg.MsgField.IDisTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.DisTmp} DisTmp instance
             */
            DisTmp.create = function create(properties) {
                return new DisTmp(properties);
            };

            /**
             * Encodes the specified DisTmp message. Does not implicitly {@link Msg.MsgField.DisTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {Msg.MsgField.IDisTmp} message DisTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.DisUin != null && Object.hasOwnProperty.call(message, "DisUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.DisUin);
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ToUin);
                return writer;
            };

            /**
             * Encodes the specified DisTmp message, length delimited. Does not implicitly {@link Msg.MsgField.DisTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {Msg.MsgField.IDisTmp} message DisTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DisTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.DisTmp} DisTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.DisTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.DisUin = reader.int64();
                        break;
                    case 2:
                        message.ToUin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DisTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.DisTmp} DisTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DisTmp message.
             * @function verify
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DisTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.DisUin != null && message.hasOwnProperty("DisUin"))
                    if (!$util.isInteger(message.DisUin) && !(message.DisUin && $util.isInteger(message.DisUin.low) && $util.isInteger(message.DisUin.high)))
                        return "DisUin: integer|Long expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                return null;
            };

            /**
             * Creates a DisTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.DisTmp} DisTmp
             */
            DisTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.DisTmp)
                    return object;
                var message = new $root.Msg.MsgField.DisTmp();
                if (object.DisUin != null)
                    if ($util.Long)
                        (message.DisUin = $util.Long.fromValue(object.DisUin)).unsigned = false;
                    else if (typeof object.DisUin === "string")
                        message.DisUin = parseInt(object.DisUin, 10);
                    else if (typeof object.DisUin === "number")
                        message.DisUin = object.DisUin;
                    else if (typeof object.DisUin === "object")
                        message.DisUin = new $util.LongBits(object.DisUin.low >>> 0, object.DisUin.high >>> 0).toNumber();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a DisTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.DisTmp
             * @static
             * @param {Msg.MsgField.DisTmp} message DisTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.DisUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.DisUin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                }
                if (message.DisUin != null && message.hasOwnProperty("DisUin"))
                    if (typeof message.DisUin === "number")
                        object.DisUin = options.longs === String ? String(message.DisUin) : message.DisUin;
                    else
                        object.DisUin = options.longs === String ? $util.Long.prototype.toString.call(message.DisUin) : options.longs === Number ? new $util.LongBits(message.DisUin.low >>> 0, message.DisUin.high >>> 0).toNumber() : message.DisUin;
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                return object;
            };

            /**
             * Converts this DisTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.DisTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DisTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DisTmp;
        })();

        MsgField.WpaTmp = (function() {

            /**
             * Properties of a WpaTmp.
             * @memberof Msg.MsgField
             * @interface IWpaTmp
             * @property {number|Long|null} [ToUin] WpaTmp ToUin
             * @property {Uint8Array|null} [Sig] WpaTmp Sig
             */

            /**
             * Constructs a new WpaTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a WpaTmp.
             * @implements IWpaTmp
             * @constructor
             * @param {Msg.MsgField.IWpaTmp=} [properties] Properties to set
             */
            function WpaTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WpaTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.WpaTmp
             * @instance
             */
            WpaTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * WpaTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.WpaTmp
             * @instance
             */
            WpaTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * Creates a new WpaTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {Msg.MsgField.IWpaTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.WpaTmp} WpaTmp instance
             */
            WpaTmp.create = function create(properties) {
                return new WpaTmp(properties);
            };

            /**
             * Encodes the specified WpaTmp message. Does not implicitly {@link Msg.MsgField.WpaTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {Msg.MsgField.IWpaTmp} message WpaTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WpaTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                return writer;
            };

            /**
             * Encodes the specified WpaTmp message, length delimited. Does not implicitly {@link Msg.MsgField.WpaTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {Msg.MsgField.IWpaTmp} message WpaTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WpaTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WpaTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.WpaTmp} WpaTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WpaTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.WpaTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WpaTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.WpaTmp} WpaTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WpaTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WpaTmp message.
             * @function verify
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WpaTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                return null;
            };

            /**
             * Creates a WpaTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.WpaTmp} WpaTmp
             */
            WpaTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.WpaTmp)
                    return object;
                var message = new $root.Msg.MsgField.WpaTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                return message;
            };

            /**
             * Creates a plain object from a WpaTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.WpaTmp
             * @static
             * @param {Msg.MsgField.WpaTmp} message WpaTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WpaTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                return object;
            };

            /**
             * Converts this WpaTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.WpaTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WpaTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WpaTmp;
        })();

        MsgField.SubMsgType0xc1 = (function() {

            /**
             * Properties of a SubMsgType0xc1.
             * @memberof Msg.MsgField
             * @interface ISubMsgType0xc1
             */

            /**
             * Constructs a new SubMsgType0xc1.
             * @memberof Msg.MsgField
             * @classdesc Represents a SubMsgType0xc1.
             * @implements ISubMsgType0xc1
             * @constructor
             * @param {Msg.MsgField.ISubMsgType0xc1=} [properties] Properties to set
             */
            function SubMsgType0xc1(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SubMsgType0xc1 instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {Msg.MsgField.ISubMsgType0xc1=} [properties] Properties to set
             * @returns {Msg.MsgField.SubMsgType0xc1} SubMsgType0xc1 instance
             */
            SubMsgType0xc1.create = function create(properties) {
                return new SubMsgType0xc1(properties);
            };

            /**
             * Encodes the specified SubMsgType0xc1 message. Does not implicitly {@link Msg.MsgField.SubMsgType0xc1.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {Msg.MsgField.ISubMsgType0xc1} message SubMsgType0xc1 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubMsgType0xc1.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SubMsgType0xc1 message, length delimited. Does not implicitly {@link Msg.MsgField.SubMsgType0xc1.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {Msg.MsgField.ISubMsgType0xc1} message SubMsgType0xc1 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubMsgType0xc1.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SubMsgType0xc1 message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.SubMsgType0xc1} SubMsgType0xc1
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubMsgType0xc1.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.SubMsgType0xc1();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SubMsgType0xc1 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.SubMsgType0xc1} SubMsgType0xc1
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubMsgType0xc1.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SubMsgType0xc1 message.
             * @function verify
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubMsgType0xc1.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SubMsgType0xc1 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.SubMsgType0xc1} SubMsgType0xc1
             */
            SubMsgType0xc1.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.SubMsgType0xc1)
                    return object;
                return new $root.Msg.MsgField.SubMsgType0xc1();
            };

            /**
             * Creates a plain object from a SubMsgType0xc1 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @static
             * @param {Msg.MsgField.SubMsgType0xc1} message SubMsgType0xc1
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubMsgType0xc1.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SubMsgType0xc1 to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.SubMsgType0xc1
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubMsgType0xc1.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SubMsgType0xc1.NotOnlineImage = (function() {

                /**
                 * Properties of a NotOnlineImage.
                 * @memberof Msg.MsgField.SubMsgType0xc1
                 * @interface INotOnlineImage
                 * @property {Uint8Array|null} [Filepath] NotOnlineImage Filepath
                 * @property {number|null} [Filelen] NotOnlineImage Filelen
                 * @property {Uint8Array|null} [Downloadpath] NotOnlineImage Downloadpath
                 * @property {Uint8Array|null} [Oldversendfile] NotOnlineImage Oldversendfile
                 * @property {number|null} [Imgtype] NotOnlineImage Imgtype
                 * @property {Uint8Array|null} [Previewsimage] NotOnlineImage Previewsimage
                 * @property {Uint8Array|null} [Picmd5] NotOnlineImage Picmd5
                 * @property {number|null} [Picheight] NotOnlineImage Picheight
                 * @property {number|null} [Picwidth] NotOnlineImage Picwidth
                 * @property {Uint8Array|null} [Resid] NotOnlineImage Resid
                 * @property {Uint8Array|null} [Flag] NotOnlineImage Flag
                 * @property {string|null} [Downloadurl] NotOnlineImage Downloadurl
                 * @property {number|null} [Original] NotOnlineImage Original
                 */

                /**
                 * Constructs a new NotOnlineImage.
                 * @memberof Msg.MsgField.SubMsgType0xc1
                 * @classdesc Represents a NotOnlineImage.
                 * @implements INotOnlineImage
                 * @constructor
                 * @param {Msg.MsgField.SubMsgType0xc1.INotOnlineImage=} [properties] Properties to set
                 */
                function NotOnlineImage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NotOnlineImage Filepath.
                 * @member {Uint8Array} Filepath
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Filepath = $util.newBuffer([]);

                /**
                 * NotOnlineImage Filelen.
                 * @member {number} Filelen
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Filelen = 0;

                /**
                 * NotOnlineImage Downloadpath.
                 * @member {Uint8Array} Downloadpath
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Downloadpath = $util.newBuffer([]);

                /**
                 * NotOnlineImage Oldversendfile.
                 * @member {Uint8Array} Oldversendfile
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Oldversendfile = $util.newBuffer([]);

                /**
                 * NotOnlineImage Imgtype.
                 * @member {number} Imgtype
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Imgtype = 0;

                /**
                 * NotOnlineImage Previewsimage.
                 * @member {Uint8Array} Previewsimage
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Previewsimage = $util.newBuffer([]);

                /**
                 * NotOnlineImage Picmd5.
                 * @member {Uint8Array} Picmd5
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Picmd5 = $util.newBuffer([]);

                /**
                 * NotOnlineImage Picheight.
                 * @member {number} Picheight
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Picheight = 0;

                /**
                 * NotOnlineImage Picwidth.
                 * @member {number} Picwidth
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Picwidth = 0;

                /**
                 * NotOnlineImage Resid.
                 * @member {Uint8Array} Resid
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Resid = $util.newBuffer([]);

                /**
                 * NotOnlineImage Flag.
                 * @member {Uint8Array} Flag
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Flag = $util.newBuffer([]);

                /**
                 * NotOnlineImage Downloadurl.
                 * @member {string} Downloadurl
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Downloadurl = "";

                /**
                 * NotOnlineImage Original.
                 * @member {number} Original
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 */
                NotOnlineImage.prototype.Original = 0;

                /**
                 * Creates a new NotOnlineImage instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.INotOnlineImage=} [properties] Properties to set
                 * @returns {Msg.MsgField.SubMsgType0xc1.NotOnlineImage} NotOnlineImage instance
                 */
                NotOnlineImage.create = function create(properties) {
                    return new NotOnlineImage(properties);
                };

                /**
                 * Encodes the specified NotOnlineImage message. Does not implicitly {@link Msg.MsgField.SubMsgType0xc1.NotOnlineImage.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.INotOnlineImage} message NotOnlineImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotOnlineImage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Filepath != null && Object.hasOwnProperty.call(message, "Filepath"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Filepath);
                    if (message.Filelen != null && Object.hasOwnProperty.call(message, "Filelen"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Filelen);
                    if (message.Downloadpath != null && Object.hasOwnProperty.call(message, "Downloadpath"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Downloadpath);
                    if (message.Oldversendfile != null && Object.hasOwnProperty.call(message, "Oldversendfile"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Oldversendfile);
                    if (message.Imgtype != null && Object.hasOwnProperty.call(message, "Imgtype"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Imgtype);
                    if (message.Previewsimage != null && Object.hasOwnProperty.call(message, "Previewsimage"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.Previewsimage);
                    if (message.Picmd5 != null && Object.hasOwnProperty.call(message, "Picmd5"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Picmd5);
                    if (message.Picheight != null && Object.hasOwnProperty.call(message, "Picheight"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Picheight);
                    if (message.Picwidth != null && Object.hasOwnProperty.call(message, "Picwidth"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Picwidth);
                    if (message.Resid != null && Object.hasOwnProperty.call(message, "Resid"))
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.Resid);
                    if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Flag);
                    if (message.Downloadurl != null && Object.hasOwnProperty.call(message, "Downloadurl"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.Downloadurl);
                    if (message.Original != null && Object.hasOwnProperty.call(message, "Original"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.Original);
                    return writer;
                };

                /**
                 * Encodes the specified NotOnlineImage message, length delimited. Does not implicitly {@link Msg.MsgField.SubMsgType0xc1.NotOnlineImage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.INotOnlineImage} message NotOnlineImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotOnlineImage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NotOnlineImage message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.SubMsgType0xc1.NotOnlineImage} NotOnlineImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotOnlineImage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Filepath = reader.bytes();
                            break;
                        case 2:
                            message.Filelen = reader.int32();
                            break;
                        case 3:
                            message.Downloadpath = reader.bytes();
                            break;
                        case 4:
                            message.Oldversendfile = reader.bytes();
                            break;
                        case 5:
                            message.Imgtype = reader.int32();
                            break;
                        case 6:
                            message.Previewsimage = reader.bytes();
                            break;
                        case 7:
                            message.Picmd5 = reader.bytes();
                            break;
                        case 8:
                            message.Picheight = reader.int32();
                            break;
                        case 9:
                            message.Picwidth = reader.int32();
                            break;
                        case 10:
                            message.Resid = reader.bytes();
                            break;
                        case 11:
                            message.Flag = reader.bytes();
                            break;
                        case 12:
                            message.Downloadurl = reader.string();
                            break;
                        case 13:
                            message.Original = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NotOnlineImage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.SubMsgType0xc1.NotOnlineImage} NotOnlineImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotOnlineImage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NotOnlineImage message.
                 * @function verify
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NotOnlineImage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Filepath != null && message.hasOwnProperty("Filepath"))
                        if (!(message.Filepath && typeof message.Filepath.length === "number" || $util.isString(message.Filepath)))
                            return "Filepath: buffer expected";
                    if (message.Filelen != null && message.hasOwnProperty("Filelen"))
                        if (!$util.isInteger(message.Filelen))
                            return "Filelen: integer expected";
                    if (message.Downloadpath != null && message.hasOwnProperty("Downloadpath"))
                        if (!(message.Downloadpath && typeof message.Downloadpath.length === "number" || $util.isString(message.Downloadpath)))
                            return "Downloadpath: buffer expected";
                    if (message.Oldversendfile != null && message.hasOwnProperty("Oldversendfile"))
                        if (!(message.Oldversendfile && typeof message.Oldversendfile.length === "number" || $util.isString(message.Oldversendfile)))
                            return "Oldversendfile: buffer expected";
                    if (message.Imgtype != null && message.hasOwnProperty("Imgtype"))
                        if (!$util.isInteger(message.Imgtype))
                            return "Imgtype: integer expected";
                    if (message.Previewsimage != null && message.hasOwnProperty("Previewsimage"))
                        if (!(message.Previewsimage && typeof message.Previewsimage.length === "number" || $util.isString(message.Previewsimage)))
                            return "Previewsimage: buffer expected";
                    if (message.Picmd5 != null && message.hasOwnProperty("Picmd5"))
                        if (!(message.Picmd5 && typeof message.Picmd5.length === "number" || $util.isString(message.Picmd5)))
                            return "Picmd5: buffer expected";
                    if (message.Picheight != null && message.hasOwnProperty("Picheight"))
                        if (!$util.isInteger(message.Picheight))
                            return "Picheight: integer expected";
                    if (message.Picwidth != null && message.hasOwnProperty("Picwidth"))
                        if (!$util.isInteger(message.Picwidth))
                            return "Picwidth: integer expected";
                    if (message.Resid != null && message.hasOwnProperty("Resid"))
                        if (!(message.Resid && typeof message.Resid.length === "number" || $util.isString(message.Resid)))
                            return "Resid: buffer expected";
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        if (!(message.Flag && typeof message.Flag.length === "number" || $util.isString(message.Flag)))
                            return "Flag: buffer expected";
                    if (message.Downloadurl != null && message.hasOwnProperty("Downloadurl"))
                        if (!$util.isString(message.Downloadurl))
                            return "Downloadurl: string expected";
                    if (message.Original != null && message.hasOwnProperty("Original"))
                        if (!$util.isInteger(message.Original))
                            return "Original: integer expected";
                    return null;
                };

                /**
                 * Creates a NotOnlineImage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.SubMsgType0xc1.NotOnlineImage} NotOnlineImage
                 */
                NotOnlineImage.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage)
                        return object;
                    var message = new $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage();
                    if (object.Filepath != null)
                        if (typeof object.Filepath === "string")
                            $util.base64.decode(object.Filepath, message.Filepath = $util.newBuffer($util.base64.length(object.Filepath)), 0);
                        else if (object.Filepath.length)
                            message.Filepath = object.Filepath;
                    if (object.Filelen != null)
                        message.Filelen = object.Filelen | 0;
                    if (object.Downloadpath != null)
                        if (typeof object.Downloadpath === "string")
                            $util.base64.decode(object.Downloadpath, message.Downloadpath = $util.newBuffer($util.base64.length(object.Downloadpath)), 0);
                        else if (object.Downloadpath.length)
                            message.Downloadpath = object.Downloadpath;
                    if (object.Oldversendfile != null)
                        if (typeof object.Oldversendfile === "string")
                            $util.base64.decode(object.Oldversendfile, message.Oldversendfile = $util.newBuffer($util.base64.length(object.Oldversendfile)), 0);
                        else if (object.Oldversendfile.length)
                            message.Oldversendfile = object.Oldversendfile;
                    if (object.Imgtype != null)
                        message.Imgtype = object.Imgtype | 0;
                    if (object.Previewsimage != null)
                        if (typeof object.Previewsimage === "string")
                            $util.base64.decode(object.Previewsimage, message.Previewsimage = $util.newBuffer($util.base64.length(object.Previewsimage)), 0);
                        else if (object.Previewsimage.length)
                            message.Previewsimage = object.Previewsimage;
                    if (object.Picmd5 != null)
                        if (typeof object.Picmd5 === "string")
                            $util.base64.decode(object.Picmd5, message.Picmd5 = $util.newBuffer($util.base64.length(object.Picmd5)), 0);
                        else if (object.Picmd5.length)
                            message.Picmd5 = object.Picmd5;
                    if (object.Picheight != null)
                        message.Picheight = object.Picheight | 0;
                    if (object.Picwidth != null)
                        message.Picwidth = object.Picwidth | 0;
                    if (object.Resid != null)
                        if (typeof object.Resid === "string")
                            $util.base64.decode(object.Resid, message.Resid = $util.newBuffer($util.base64.length(object.Resid)), 0);
                        else if (object.Resid.length)
                            message.Resid = object.Resid;
                    if (object.Flag != null)
                        if (typeof object.Flag === "string")
                            $util.base64.decode(object.Flag, message.Flag = $util.newBuffer($util.base64.length(object.Flag)), 0);
                        else if (object.Flag.length)
                            message.Flag = object.Flag;
                    if (object.Downloadurl != null)
                        message.Downloadurl = String(object.Downloadurl);
                    if (object.Original != null)
                        message.Original = object.Original | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a NotOnlineImage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.NotOnlineImage} message NotOnlineImage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NotOnlineImage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Filepath = "";
                        else {
                            object.Filepath = [];
                            if (options.bytes !== Array)
                                object.Filepath = $util.newBuffer(object.Filepath);
                        }
                        object.Filelen = 0;
                        if (options.bytes === String)
                            object.Downloadpath = "";
                        else {
                            object.Downloadpath = [];
                            if (options.bytes !== Array)
                                object.Downloadpath = $util.newBuffer(object.Downloadpath);
                        }
                        if (options.bytes === String)
                            object.Oldversendfile = "";
                        else {
                            object.Oldversendfile = [];
                            if (options.bytes !== Array)
                                object.Oldversendfile = $util.newBuffer(object.Oldversendfile);
                        }
                        object.Imgtype = 0;
                        if (options.bytes === String)
                            object.Previewsimage = "";
                        else {
                            object.Previewsimage = [];
                            if (options.bytes !== Array)
                                object.Previewsimage = $util.newBuffer(object.Previewsimage);
                        }
                        if (options.bytes === String)
                            object.Picmd5 = "";
                        else {
                            object.Picmd5 = [];
                            if (options.bytes !== Array)
                                object.Picmd5 = $util.newBuffer(object.Picmd5);
                        }
                        object.Picheight = 0;
                        object.Picwidth = 0;
                        if (options.bytes === String)
                            object.Resid = "";
                        else {
                            object.Resid = [];
                            if (options.bytes !== Array)
                                object.Resid = $util.newBuffer(object.Resid);
                        }
                        if (options.bytes === String)
                            object.Flag = "";
                        else {
                            object.Flag = [];
                            if (options.bytes !== Array)
                                object.Flag = $util.newBuffer(object.Flag);
                        }
                        object.Downloadurl = "";
                        object.Original = 0;
                    }
                    if (message.Filepath != null && message.hasOwnProperty("Filepath"))
                        object.Filepath = options.bytes === String ? $util.base64.encode(message.Filepath, 0, message.Filepath.length) : options.bytes === Array ? Array.prototype.slice.call(message.Filepath) : message.Filepath;
                    if (message.Filelen != null && message.hasOwnProperty("Filelen"))
                        object.Filelen = message.Filelen;
                    if (message.Downloadpath != null && message.hasOwnProperty("Downloadpath"))
                        object.Downloadpath = options.bytes === String ? $util.base64.encode(message.Downloadpath, 0, message.Downloadpath.length) : options.bytes === Array ? Array.prototype.slice.call(message.Downloadpath) : message.Downloadpath;
                    if (message.Oldversendfile != null && message.hasOwnProperty("Oldversendfile"))
                        object.Oldversendfile = options.bytes === String ? $util.base64.encode(message.Oldversendfile, 0, message.Oldversendfile.length) : options.bytes === Array ? Array.prototype.slice.call(message.Oldversendfile) : message.Oldversendfile;
                    if (message.Imgtype != null && message.hasOwnProperty("Imgtype"))
                        object.Imgtype = message.Imgtype;
                    if (message.Previewsimage != null && message.hasOwnProperty("Previewsimage"))
                        object.Previewsimage = options.bytes === String ? $util.base64.encode(message.Previewsimage, 0, message.Previewsimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.Previewsimage) : message.Previewsimage;
                    if (message.Picmd5 != null && message.hasOwnProperty("Picmd5"))
                        object.Picmd5 = options.bytes === String ? $util.base64.encode(message.Picmd5, 0, message.Picmd5.length) : options.bytes === Array ? Array.prototype.slice.call(message.Picmd5) : message.Picmd5;
                    if (message.Picheight != null && message.hasOwnProperty("Picheight"))
                        object.Picheight = message.Picheight;
                    if (message.Picwidth != null && message.hasOwnProperty("Picwidth"))
                        object.Picwidth = message.Picwidth;
                    if (message.Resid != null && message.hasOwnProperty("Resid"))
                        object.Resid = options.bytes === String ? $util.base64.encode(message.Resid, 0, message.Resid.length) : options.bytes === Array ? Array.prototype.slice.call(message.Resid) : message.Resid;
                    if (message.Flag != null && message.hasOwnProperty("Flag"))
                        object.Flag = options.bytes === String ? $util.base64.encode(message.Flag, 0, message.Flag.length) : options.bytes === Array ? Array.prototype.slice.call(message.Flag) : message.Flag;
                    if (message.Downloadurl != null && message.hasOwnProperty("Downloadurl"))
                        object.Downloadurl = message.Downloadurl;
                    if (message.Original != null && message.hasOwnProperty("Original"))
                        object.Original = message.Original;
                    return object;
                };

                /**
                 * Converts this NotOnlineImage to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.SubMsgType0xc1.NotOnlineImage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NotOnlineImage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NotOnlineImage;
            })();

            SubMsgType0xc1.MsgBody = (function() {

                /**
                 * Properties of a MsgBody.
                 * @memberof Msg.MsgField.SubMsgType0xc1
                 * @interface IMsgBody
                 * @property {Uint8Array|null} [Filekey] MsgBody Filekey
                 * @property {number|Long|null} [Fromuin] MsgBody Fromuin
                 * @property {number|Long|null} [Touin] MsgBody Touin
                 * @property {number|null} [Status] MsgBody Status
                 * @property {number|null} [Ttl] MsgBody Ttl
                 * @property {number|null} [Type] MsgBody Type
                 * @property {number|null} [Encryptpreheadlength] MsgBody Encryptpreheadlength
                 * @property {number|null} [Encrypttype] MsgBody Encrypttype
                 * @property {Uint8Array|null} [Encryptkey] MsgBody Encryptkey
                 * @property {number|null} [Readtimes] MsgBody Readtimes
                 * @property {number|null} [Lefttime] MsgBody Lefttime
                 * @property {Msg.MsgField.SubMsgType0xc1.INotOnlineImage|null} [Notonlineimage] MsgBody Notonlineimage
                 */

                /**
                 * Constructs a new MsgBody.
                 * @memberof Msg.MsgField.SubMsgType0xc1
                 * @classdesc Represents a MsgBody.
                 * @implements IMsgBody
                 * @constructor
                 * @param {Msg.MsgField.SubMsgType0xc1.IMsgBody=} [properties] Properties to set
                 */
                function MsgBody(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgBody Filekey.
                 * @member {Uint8Array} Filekey
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Filekey = $util.newBuffer([]);

                /**
                 * MsgBody Fromuin.
                 * @member {number|Long} Fromuin
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Fromuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgBody Touin.
                 * @member {number|Long} Touin
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgBody Status.
                 * @member {number} Status
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Status = 0;

                /**
                 * MsgBody Ttl.
                 * @member {number} Ttl
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Ttl = 0;

                /**
                 * MsgBody Type.
                 * @member {number} Type
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Type = 0;

                /**
                 * MsgBody Encryptpreheadlength.
                 * @member {number} Encryptpreheadlength
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Encryptpreheadlength = 0;

                /**
                 * MsgBody Encrypttype.
                 * @member {number} Encrypttype
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Encrypttype = 0;

                /**
                 * MsgBody Encryptkey.
                 * @member {Uint8Array} Encryptkey
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Encryptkey = $util.newBuffer([]);

                /**
                 * MsgBody Readtimes.
                 * @member {number} Readtimes
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Readtimes = 0;

                /**
                 * MsgBody Lefttime.
                 * @member {number} Lefttime
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Lefttime = 0;

                /**
                 * MsgBody Notonlineimage.
                 * @member {Msg.MsgField.SubMsgType0xc1.INotOnlineImage|null|undefined} Notonlineimage
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 */
                MsgBody.prototype.Notonlineimage = null;

                /**
                 * Creates a new MsgBody instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.IMsgBody=} [properties] Properties to set
                 * @returns {Msg.MsgField.SubMsgType0xc1.MsgBody} MsgBody instance
                 */
                MsgBody.create = function create(properties) {
                    return new MsgBody(properties);
                };

                /**
                 * Encodes the specified MsgBody message. Does not implicitly {@link Msg.MsgField.SubMsgType0xc1.MsgBody.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.IMsgBody} message MsgBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBody.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Filekey != null && Object.hasOwnProperty.call(message, "Filekey"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Filekey);
                    if (message.Fromuin != null && Object.hasOwnProperty.call(message, "Fromuin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Fromuin);
                    if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.Touin);
                    if (message.Status != null && Object.hasOwnProperty.call(message, "Status"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Status);
                    if (message.Ttl != null && Object.hasOwnProperty.call(message, "Ttl"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Ttl);
                    if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Type);
                    if (message.Encryptpreheadlength != null && Object.hasOwnProperty.call(message, "Encryptpreheadlength"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Encryptpreheadlength);
                    if (message.Encrypttype != null && Object.hasOwnProperty.call(message, "Encrypttype"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Encrypttype);
                    if (message.Encryptkey != null && Object.hasOwnProperty.call(message, "Encryptkey"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.Encryptkey);
                    if (message.Readtimes != null && Object.hasOwnProperty.call(message, "Readtimes"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Readtimes);
                    if (message.Lefttime != null && Object.hasOwnProperty.call(message, "Lefttime"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.Lefttime);
                    if (message.Notonlineimage != null && Object.hasOwnProperty.call(message, "Notonlineimage"))
                        $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage.encode(message.Notonlineimage, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MsgBody message, length delimited. Does not implicitly {@link Msg.MsgField.SubMsgType0xc1.MsgBody.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.IMsgBody} message MsgBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgBody.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgBody message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.SubMsgType0xc1.MsgBody} MsgBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBody.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.SubMsgType0xc1.MsgBody();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Filekey = reader.bytes();
                            break;
                        case 2:
                            message.Fromuin = reader.int64();
                            break;
                        case 3:
                            message.Touin = reader.int64();
                            break;
                        case 4:
                            message.Status = reader.int32();
                            break;
                        case 5:
                            message.Ttl = reader.int32();
                            break;
                        case 6:
                            message.Type = reader.int32();
                            break;
                        case 7:
                            message.Encryptpreheadlength = reader.int32();
                            break;
                        case 8:
                            message.Encrypttype = reader.int32();
                            break;
                        case 9:
                            message.Encryptkey = reader.bytes();
                            break;
                        case 10:
                            message.Readtimes = reader.int32();
                            break;
                        case 11:
                            message.Lefttime = reader.int32();
                            break;
                        case 12:
                            message.Notonlineimage = $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgBody message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.SubMsgType0xc1.MsgBody} MsgBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgBody.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgBody message.
                 * @function verify
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgBody.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Filekey != null && message.hasOwnProperty("Filekey"))
                        if (!(message.Filekey && typeof message.Filekey.length === "number" || $util.isString(message.Filekey)))
                            return "Filekey: buffer expected";
                    if (message.Fromuin != null && message.hasOwnProperty("Fromuin"))
                        if (!$util.isInteger(message.Fromuin) && !(message.Fromuin && $util.isInteger(message.Fromuin.low) && $util.isInteger(message.Fromuin.high)))
                            return "Fromuin: integer|Long expected";
                    if (message.Touin != null && message.hasOwnProperty("Touin"))
                        if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                            return "Touin: integer|Long expected";
                    if (message.Status != null && message.hasOwnProperty("Status"))
                        if (!$util.isInteger(message.Status))
                            return "Status: integer expected";
                    if (message.Ttl != null && message.hasOwnProperty("Ttl"))
                        if (!$util.isInteger(message.Ttl))
                            return "Ttl: integer expected";
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        if (!$util.isInteger(message.Type))
                            return "Type: integer expected";
                    if (message.Encryptpreheadlength != null && message.hasOwnProperty("Encryptpreheadlength"))
                        if (!$util.isInteger(message.Encryptpreheadlength))
                            return "Encryptpreheadlength: integer expected";
                    if (message.Encrypttype != null && message.hasOwnProperty("Encrypttype"))
                        if (!$util.isInteger(message.Encrypttype))
                            return "Encrypttype: integer expected";
                    if (message.Encryptkey != null && message.hasOwnProperty("Encryptkey"))
                        if (!(message.Encryptkey && typeof message.Encryptkey.length === "number" || $util.isString(message.Encryptkey)))
                            return "Encryptkey: buffer expected";
                    if (message.Readtimes != null && message.hasOwnProperty("Readtimes"))
                        if (!$util.isInteger(message.Readtimes))
                            return "Readtimes: integer expected";
                    if (message.Lefttime != null && message.hasOwnProperty("Lefttime"))
                        if (!$util.isInteger(message.Lefttime))
                            return "Lefttime: integer expected";
                    if (message.Notonlineimage != null && message.hasOwnProperty("Notonlineimage")) {
                        var error = $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage.verify(message.Notonlineimage);
                        if (error)
                            return "Notonlineimage." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MsgBody message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.SubMsgType0xc1.MsgBody} MsgBody
                 */
                MsgBody.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.SubMsgType0xc1.MsgBody)
                        return object;
                    var message = new $root.Msg.MsgField.SubMsgType0xc1.MsgBody();
                    if (object.Filekey != null)
                        if (typeof object.Filekey === "string")
                            $util.base64.decode(object.Filekey, message.Filekey = $util.newBuffer($util.base64.length(object.Filekey)), 0);
                        else if (object.Filekey.length)
                            message.Filekey = object.Filekey;
                    if (object.Fromuin != null)
                        if ($util.Long)
                            (message.Fromuin = $util.Long.fromValue(object.Fromuin)).unsigned = false;
                        else if (typeof object.Fromuin === "string")
                            message.Fromuin = parseInt(object.Fromuin, 10);
                        else if (typeof object.Fromuin === "number")
                            message.Fromuin = object.Fromuin;
                        else if (typeof object.Fromuin === "object")
                            message.Fromuin = new $util.LongBits(object.Fromuin.low >>> 0, object.Fromuin.high >>> 0).toNumber();
                    if (object.Touin != null)
                        if ($util.Long)
                            (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                        else if (typeof object.Touin === "string")
                            message.Touin = parseInt(object.Touin, 10);
                        else if (typeof object.Touin === "number")
                            message.Touin = object.Touin;
                        else if (typeof object.Touin === "object")
                            message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                    if (object.Status != null)
                        message.Status = object.Status | 0;
                    if (object.Ttl != null)
                        message.Ttl = object.Ttl | 0;
                    if (object.Type != null)
                        message.Type = object.Type | 0;
                    if (object.Encryptpreheadlength != null)
                        message.Encryptpreheadlength = object.Encryptpreheadlength | 0;
                    if (object.Encrypttype != null)
                        message.Encrypttype = object.Encrypttype | 0;
                    if (object.Encryptkey != null)
                        if (typeof object.Encryptkey === "string")
                            $util.base64.decode(object.Encryptkey, message.Encryptkey = $util.newBuffer($util.base64.length(object.Encryptkey)), 0);
                        else if (object.Encryptkey.length)
                            message.Encryptkey = object.Encryptkey;
                    if (object.Readtimes != null)
                        message.Readtimes = object.Readtimes | 0;
                    if (object.Lefttime != null)
                        message.Lefttime = object.Lefttime | 0;
                    if (object.Notonlineimage != null) {
                        if (typeof object.Notonlineimage !== "object")
                            throw TypeError(".Msg.MsgField.SubMsgType0xc1.MsgBody.Notonlineimage: object expected");
                        message.Notonlineimage = $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage.fromObject(object.Notonlineimage);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MsgBody message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @static
                 * @param {Msg.MsgField.SubMsgType0xc1.MsgBody} message MsgBody
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgBody.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.Filekey = "";
                        else {
                            object.Filekey = [];
                            if (options.bytes !== Array)
                                object.Filekey = $util.newBuffer(object.Filekey);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Fromuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Fromuin = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Touin = options.longs === String ? "0" : 0;
                        object.Status = 0;
                        object.Ttl = 0;
                        object.Type = 0;
                        object.Encryptpreheadlength = 0;
                        object.Encrypttype = 0;
                        if (options.bytes === String)
                            object.Encryptkey = "";
                        else {
                            object.Encryptkey = [];
                            if (options.bytes !== Array)
                                object.Encryptkey = $util.newBuffer(object.Encryptkey);
                        }
                        object.Readtimes = 0;
                        object.Lefttime = 0;
                        object.Notonlineimage = null;
                    }
                    if (message.Filekey != null && message.hasOwnProperty("Filekey"))
                        object.Filekey = options.bytes === String ? $util.base64.encode(message.Filekey, 0, message.Filekey.length) : options.bytes === Array ? Array.prototype.slice.call(message.Filekey) : message.Filekey;
                    if (message.Fromuin != null && message.hasOwnProperty("Fromuin"))
                        if (typeof message.Fromuin === "number")
                            object.Fromuin = options.longs === String ? String(message.Fromuin) : message.Fromuin;
                        else
                            object.Fromuin = options.longs === String ? $util.Long.prototype.toString.call(message.Fromuin) : options.longs === Number ? new $util.LongBits(message.Fromuin.low >>> 0, message.Fromuin.high >>> 0).toNumber() : message.Fromuin;
                    if (message.Touin != null && message.hasOwnProperty("Touin"))
                        if (typeof message.Touin === "number")
                            object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                        else
                            object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                    if (message.Status != null && message.hasOwnProperty("Status"))
                        object.Status = message.Status;
                    if (message.Ttl != null && message.hasOwnProperty("Ttl"))
                        object.Ttl = message.Ttl;
                    if (message.Type != null && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    if (message.Encryptpreheadlength != null && message.hasOwnProperty("Encryptpreheadlength"))
                        object.Encryptpreheadlength = message.Encryptpreheadlength;
                    if (message.Encrypttype != null && message.hasOwnProperty("Encrypttype"))
                        object.Encrypttype = message.Encrypttype;
                    if (message.Encryptkey != null && message.hasOwnProperty("Encryptkey"))
                        object.Encryptkey = options.bytes === String ? $util.base64.encode(message.Encryptkey, 0, message.Encryptkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.Encryptkey) : message.Encryptkey;
                    if (message.Readtimes != null && message.hasOwnProperty("Readtimes"))
                        object.Readtimes = message.Readtimes;
                    if (message.Lefttime != null && message.hasOwnProperty("Lefttime"))
                        object.Lefttime = message.Lefttime;
                    if (message.Notonlineimage != null && message.hasOwnProperty("Notonlineimage"))
                        object.Notonlineimage = $root.Msg.MsgField.SubMsgType0xc1.NotOnlineImage.toObject(message.Notonlineimage, options);
                    return object;
                };

                /**
                 * Converts this MsgBody to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.SubMsgType0xc1.MsgBody
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgBody.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MsgBody;
            })();

            return SubMsgType0xc1;
        })();

        MsgField.SecretFileHead = (function() {

            /**
             * Properties of a SecretFileHead.
             * @memberof Msg.MsgField
             * @interface ISecretFileHead
             * @property {Msg.MsgField.SubMsgType0xc1.IMsgBody|null} [SecretFileMsg] SecretFileHead SecretFileMsg
             */

            /**
             * Constructs a new SecretFileHead.
             * @memberof Msg.MsgField
             * @classdesc Represents a SecretFileHead.
             * @implements ISecretFileHead
             * @constructor
             * @param {Msg.MsgField.ISecretFileHead=} [properties] Properties to set
             */
            function SecretFileHead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SecretFileHead SecretFileMsg.
             * @member {Msg.MsgField.SubMsgType0xc1.IMsgBody|null|undefined} SecretFileMsg
             * @memberof Msg.MsgField.SecretFileHead
             * @instance
             */
            SecretFileHead.prototype.SecretFileMsg = null;

            /**
             * Creates a new SecretFileHead instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {Msg.MsgField.ISecretFileHead=} [properties] Properties to set
             * @returns {Msg.MsgField.SecretFileHead} SecretFileHead instance
             */
            SecretFileHead.create = function create(properties) {
                return new SecretFileHead(properties);
            };

            /**
             * Encodes the specified SecretFileHead message. Does not implicitly {@link Msg.MsgField.SecretFileHead.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {Msg.MsgField.ISecretFileHead} message SecretFileHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretFileHead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.SecretFileMsg != null && Object.hasOwnProperty.call(message, "SecretFileMsg"))
                    $root.Msg.MsgField.SubMsgType0xc1.MsgBody.encode(message.SecretFileMsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SecretFileHead message, length delimited. Does not implicitly {@link Msg.MsgField.SecretFileHead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {Msg.MsgField.ISecretFileHead} message SecretFileHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretFileHead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SecretFileHead message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.SecretFileHead} SecretFileHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretFileHead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.SecretFileHead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.SecretFileMsg = $root.Msg.MsgField.SubMsgType0xc1.MsgBody.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SecretFileHead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.SecretFileHead} SecretFileHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretFileHead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SecretFileHead message.
             * @function verify
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SecretFileHead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.SecretFileMsg != null && message.hasOwnProperty("SecretFileMsg")) {
                    var error = $root.Msg.MsgField.SubMsgType0xc1.MsgBody.verify(message.SecretFileMsg);
                    if (error)
                        return "SecretFileMsg." + error;
                }
                return null;
            };

            /**
             * Creates a SecretFileHead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.SecretFileHead} SecretFileHead
             */
            SecretFileHead.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.SecretFileHead)
                    return object;
                var message = new $root.Msg.MsgField.SecretFileHead();
                if (object.SecretFileMsg != null) {
                    if (typeof object.SecretFileMsg !== "object")
                        throw TypeError(".Msg.MsgField.SecretFileHead.SecretFileMsg: object expected");
                    message.SecretFileMsg = $root.Msg.MsgField.SubMsgType0xc1.MsgBody.fromObject(object.SecretFileMsg);
                }
                return message;
            };

            /**
             * Creates a plain object from a SecretFileHead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.SecretFileHead
             * @static
             * @param {Msg.MsgField.SecretFileHead} message SecretFileHead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SecretFileHead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.SecretFileMsg = null;
                if (message.SecretFileMsg != null && message.hasOwnProperty("SecretFileMsg"))
                    object.SecretFileMsg = $root.Msg.MsgField.SubMsgType0xc1.MsgBody.toObject(message.SecretFileMsg, options);
                return object;
            };

            /**
             * Converts this SecretFileHead to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.SecretFileHead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SecretFileHead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SecretFileHead;
        })();

        MsgField.PublicPlat = (function() {

            /**
             * Properties of a PublicPlat.
             * @memberof Msg.MsgField
             * @interface IPublicPlat
             * @property {number|Long|null} [ToUin] PublicPlat ToUin
             * @property {Uint8Array|null} [Sig] PublicPlat Sig
             */

            /**
             * Constructs a new PublicPlat.
             * @memberof Msg.MsgField
             * @classdesc Represents a PublicPlat.
             * @implements IPublicPlat
             * @constructor
             * @param {Msg.MsgField.IPublicPlat=} [properties] Properties to set
             */
            function PublicPlat(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PublicPlat ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.PublicPlat
             * @instance
             */
            PublicPlat.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PublicPlat Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.PublicPlat
             * @instance
             */
            PublicPlat.prototype.Sig = $util.newBuffer([]);

            /**
             * Creates a new PublicPlat instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {Msg.MsgField.IPublicPlat=} [properties] Properties to set
             * @returns {Msg.MsgField.PublicPlat} PublicPlat instance
             */
            PublicPlat.create = function create(properties) {
                return new PublicPlat(properties);
            };

            /**
             * Encodes the specified PublicPlat message. Does not implicitly {@link Msg.MsgField.PublicPlat.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {Msg.MsgField.IPublicPlat} message PublicPlat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublicPlat.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                return writer;
            };

            /**
             * Encodes the specified PublicPlat message, length delimited. Does not implicitly {@link Msg.MsgField.PublicPlat.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {Msg.MsgField.IPublicPlat} message PublicPlat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublicPlat.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PublicPlat message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.PublicPlat} PublicPlat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublicPlat.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PublicPlat();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PublicPlat message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.PublicPlat} PublicPlat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublicPlat.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PublicPlat message.
             * @function verify
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PublicPlat.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                return null;
            };

            /**
             * Creates a PublicPlat message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.PublicPlat} PublicPlat
             */
            PublicPlat.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.PublicPlat)
                    return object;
                var message = new $root.Msg.MsgField.PublicPlat();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                return message;
            };

            /**
             * Creates a plain object from a PublicPlat message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.PublicPlat
             * @static
             * @param {Msg.MsgField.PublicPlat} message PublicPlat
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PublicPlat.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                return object;
            };

            /**
             * Converts this PublicPlat to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.PublicPlat
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PublicPlat.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PublicPlat;
        })();

        MsgField.TransMsg = (function() {

            /**
             * Properties of a TransMsg.
             * @memberof Msg.MsgField
             * @interface ITransMsg
             * @property {number|Long|null} [ToUin] TransMsg ToUin
             * @property {number|null} [C2cCmd] TransMsg C2cCmd
             */

            /**
             * Constructs a new TransMsg.
             * @memberof Msg.MsgField
             * @classdesc Represents a TransMsg.
             * @implements ITransMsg
             * @constructor
             * @param {Msg.MsgField.ITransMsg=} [properties] Properties to set
             */
            function TransMsg(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransMsg ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.TransMsg
             * @instance
             */
            TransMsg.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * TransMsg C2cCmd.
             * @member {number} C2cCmd
             * @memberof Msg.MsgField.TransMsg
             * @instance
             */
            TransMsg.prototype.C2cCmd = 0;

            /**
             * Creates a new TransMsg instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {Msg.MsgField.ITransMsg=} [properties] Properties to set
             * @returns {Msg.MsgField.TransMsg} TransMsg instance
             */
            TransMsg.create = function create(properties) {
                return new TransMsg(properties);
            };

            /**
             * Encodes the specified TransMsg message. Does not implicitly {@link Msg.MsgField.TransMsg.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {Msg.MsgField.ITransMsg} message TransMsg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransMsg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.C2cCmd != null && Object.hasOwnProperty.call(message, "C2cCmd"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.C2cCmd);
                return writer;
            };

            /**
             * Encodes the specified TransMsg message, length delimited. Does not implicitly {@link Msg.MsgField.TransMsg.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {Msg.MsgField.ITransMsg} message TransMsg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransMsg.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransMsg message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.TransMsg} TransMsg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransMsg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.TransMsg();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.C2cCmd = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransMsg message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.TransMsg} TransMsg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransMsg.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransMsg message.
             * @function verify
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransMsg.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.C2cCmd != null && message.hasOwnProperty("C2cCmd"))
                    if (!$util.isInteger(message.C2cCmd))
                        return "C2cCmd: integer expected";
                return null;
            };

            /**
             * Creates a TransMsg message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.TransMsg} TransMsg
             */
            TransMsg.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.TransMsg)
                    return object;
                var message = new $root.Msg.MsgField.TransMsg();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.C2cCmd != null)
                    message.C2cCmd = object.C2cCmd | 0;
                return message;
            };

            /**
             * Creates a plain object from a TransMsg message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.TransMsg
             * @static
             * @param {Msg.MsgField.TransMsg} message TransMsg
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransMsg.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    object.C2cCmd = 0;
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.C2cCmd != null && message.hasOwnProperty("C2cCmd"))
                    object.C2cCmd = message.C2cCmd;
                return object;
            };

            /**
             * Converts this TransMsg to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.TransMsg
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransMsg.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransMsg;
        })();

        MsgField.AddressListTmp = (function() {

            /**
             * Properties of an AddressListTmp.
             * @memberof Msg.MsgField
             * @interface IAddressListTmp
             * @property {string|null} [Fromphone] AddressListTmp Fromphone
             * @property {string|null} [Tophone] AddressListTmp Tophone
             * @property {number|Long|null} [Touin] AddressListTmp Touin
             * @property {Uint8Array|null} [Sig] AddressListTmp Sig
             * @property {number|null} [Fromcontactsize] AddressListTmp Fromcontactsize
             */

            /**
             * Constructs a new AddressListTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents an AddressListTmp.
             * @implements IAddressListTmp
             * @constructor
             * @param {Msg.MsgField.IAddressListTmp=} [properties] Properties to set
             */
            function AddressListTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddressListTmp Fromphone.
             * @member {string} Fromphone
             * @memberof Msg.MsgField.AddressListTmp
             * @instance
             */
            AddressListTmp.prototype.Fromphone = "";

            /**
             * AddressListTmp Tophone.
             * @member {string} Tophone
             * @memberof Msg.MsgField.AddressListTmp
             * @instance
             */
            AddressListTmp.prototype.Tophone = "";

            /**
             * AddressListTmp Touin.
             * @member {number|Long} Touin
             * @memberof Msg.MsgField.AddressListTmp
             * @instance
             */
            AddressListTmp.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AddressListTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.AddressListTmp
             * @instance
             */
            AddressListTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * AddressListTmp Fromcontactsize.
             * @member {number} Fromcontactsize
             * @memberof Msg.MsgField.AddressListTmp
             * @instance
             */
            AddressListTmp.prototype.Fromcontactsize = 0;

            /**
             * Creates a new AddressListTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {Msg.MsgField.IAddressListTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.AddressListTmp} AddressListTmp instance
             */
            AddressListTmp.create = function create(properties) {
                return new AddressListTmp(properties);
            };

            /**
             * Encodes the specified AddressListTmp message. Does not implicitly {@link Msg.MsgField.AddressListTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {Msg.MsgField.IAddressListTmp} message AddressListTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddressListTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Fromphone != null && Object.hasOwnProperty.call(message, "Fromphone"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Fromphone);
                if (message.Tophone != null && Object.hasOwnProperty.call(message, "Tophone"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Tophone);
                if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.Touin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Sig);
                if (message.Fromcontactsize != null && Object.hasOwnProperty.call(message, "Fromcontactsize"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Fromcontactsize);
                return writer;
            };

            /**
             * Encodes the specified AddressListTmp message, length delimited. Does not implicitly {@link Msg.MsgField.AddressListTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {Msg.MsgField.IAddressListTmp} message AddressListTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddressListTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddressListTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.AddressListTmp} AddressListTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddressListTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.AddressListTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Fromphone = reader.string();
                        break;
                    case 2:
                        message.Tophone = reader.string();
                        break;
                    case 3:
                        message.Touin = reader.int64();
                        break;
                    case 4:
                        message.Sig = reader.bytes();
                        break;
                    case 5:
                        message.Fromcontactsize = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddressListTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.AddressListTmp} AddressListTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddressListTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddressListTmp message.
             * @function verify
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddressListTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Fromphone != null && message.hasOwnProperty("Fromphone"))
                    if (!$util.isString(message.Fromphone))
                        return "Fromphone: string expected";
                if (message.Tophone != null && message.hasOwnProperty("Tophone"))
                    if (!$util.isString(message.Tophone))
                        return "Tophone: string expected";
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                        return "Touin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.Fromcontactsize != null && message.hasOwnProperty("Fromcontactsize"))
                    if (!$util.isInteger(message.Fromcontactsize))
                        return "Fromcontactsize: integer expected";
                return null;
            };

            /**
             * Creates an AddressListTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.AddressListTmp} AddressListTmp
             */
            AddressListTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.AddressListTmp)
                    return object;
                var message = new $root.Msg.MsgField.AddressListTmp();
                if (object.Fromphone != null)
                    message.Fromphone = String(object.Fromphone);
                if (object.Tophone != null)
                    message.Tophone = String(object.Tophone);
                if (object.Touin != null)
                    if ($util.Long)
                        (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                    else if (typeof object.Touin === "string")
                        message.Touin = parseInt(object.Touin, 10);
                    else if (typeof object.Touin === "number")
                        message.Touin = object.Touin;
                    else if (typeof object.Touin === "object")
                        message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.Fromcontactsize != null)
                    message.Fromcontactsize = object.Fromcontactsize | 0;
                return message;
            };

            /**
             * Creates a plain object from an AddressListTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.AddressListTmp
             * @static
             * @param {Msg.MsgField.AddressListTmp} message AddressListTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddressListTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Fromphone = "";
                    object.Tophone = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Touin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    object.Fromcontactsize = 0;
                }
                if (message.Fromphone != null && message.hasOwnProperty("Fromphone"))
                    object.Fromphone = message.Fromphone;
                if (message.Tophone != null && message.hasOwnProperty("Tophone"))
                    object.Tophone = message.Tophone;
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (typeof message.Touin === "number")
                        object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                    else
                        object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.Fromcontactsize != null && message.hasOwnProperty("Fromcontactsize"))
                    object.Fromcontactsize = message.Fromcontactsize;
                return object;
            };

            /**
             * Converts this AddressListTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.AddressListTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddressListTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AddressListTmp;
        })();

        MsgField.RichStatusTmp = (function() {

            /**
             * Properties of a RichStatusTmp.
             * @memberof Msg.MsgField
             * @interface IRichStatusTmp
             * @property {number|Long|null} [ToUin] RichStatusTmp ToUin
             * @property {Uint8Array|null} [Sig] RichStatusTmp Sig
             */

            /**
             * Constructs a new RichStatusTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a RichStatusTmp.
             * @implements IRichStatusTmp
             * @constructor
             * @param {Msg.MsgField.IRichStatusTmp=} [properties] Properties to set
             */
            function RichStatusTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RichStatusTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.RichStatusTmp
             * @instance
             */
            RichStatusTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RichStatusTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.RichStatusTmp
             * @instance
             */
            RichStatusTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * Creates a new RichStatusTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {Msg.MsgField.IRichStatusTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.RichStatusTmp} RichStatusTmp instance
             */
            RichStatusTmp.create = function create(properties) {
                return new RichStatusTmp(properties);
            };

            /**
             * Encodes the specified RichStatusTmp message. Does not implicitly {@link Msg.MsgField.RichStatusTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {Msg.MsgField.IRichStatusTmp} message RichStatusTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RichStatusTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                return writer;
            };

            /**
             * Encodes the specified RichStatusTmp message, length delimited. Does not implicitly {@link Msg.MsgField.RichStatusTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {Msg.MsgField.IRichStatusTmp} message RichStatusTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RichStatusTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RichStatusTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.RichStatusTmp} RichStatusTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RichStatusTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.RichStatusTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RichStatusTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.RichStatusTmp} RichStatusTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RichStatusTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RichStatusTmp message.
             * @function verify
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RichStatusTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                return null;
            };

            /**
             * Creates a RichStatusTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.RichStatusTmp} RichStatusTmp
             */
            RichStatusTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.RichStatusTmp)
                    return object;
                var message = new $root.Msg.MsgField.RichStatusTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                return message;
            };

            /**
             * Creates a plain object from a RichStatusTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.RichStatusTmp
             * @static
             * @param {Msg.MsgField.RichStatusTmp} message RichStatusTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RichStatusTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                return object;
            };

            /**
             * Converts this RichStatusTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.RichStatusTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RichStatusTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RichStatusTmp;
        })();

        MsgField.TransCmd = (function() {

            /**
             * Properties of a TransCmd.
             * @memberof Msg.MsgField
             * @interface ITransCmd
             * @property {number|Long|null} [ToUin] TransCmd ToUin
             * @property {number|null} [MsgType] TransCmd MsgType
             */

            /**
             * Constructs a new TransCmd.
             * @memberof Msg.MsgField
             * @classdesc Represents a TransCmd.
             * @implements ITransCmd
             * @constructor
             * @param {Msg.MsgField.ITransCmd=} [properties] Properties to set
             */
            function TransCmd(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransCmd ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.TransCmd
             * @instance
             */
            TransCmd.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * TransCmd MsgType.
             * @member {number} MsgType
             * @memberof Msg.MsgField.TransCmd
             * @instance
             */
            TransCmd.prototype.MsgType = 0;

            /**
             * Creates a new TransCmd instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {Msg.MsgField.ITransCmd=} [properties] Properties to set
             * @returns {Msg.MsgField.TransCmd} TransCmd instance
             */
            TransCmd.create = function create(properties) {
                return new TransCmd(properties);
            };

            /**
             * Encodes the specified TransCmd message. Does not implicitly {@link Msg.MsgField.TransCmd.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {Msg.MsgField.ITransCmd} message TransCmd message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransCmd.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.MsgType != null && Object.hasOwnProperty.call(message, "MsgType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.MsgType);
                return writer;
            };

            /**
             * Encodes the specified TransCmd message, length delimited. Does not implicitly {@link Msg.MsgField.TransCmd.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {Msg.MsgField.ITransCmd} message TransCmd message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransCmd.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransCmd message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.TransCmd} TransCmd
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransCmd.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.TransCmd();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.MsgType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransCmd message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.TransCmd} TransCmd
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransCmd.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransCmd message.
             * @function verify
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransCmd.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                    if (!$util.isInteger(message.MsgType))
                        return "MsgType: integer expected";
                return null;
            };

            /**
             * Creates a TransCmd message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.TransCmd} TransCmd
             */
            TransCmd.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.TransCmd)
                    return object;
                var message = new $root.Msg.MsgField.TransCmd();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.MsgType != null)
                    message.MsgType = object.MsgType | 0;
                return message;
            };

            /**
             * Creates a plain object from a TransCmd message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.TransCmd
             * @static
             * @param {Msg.MsgField.TransCmd} message TransCmd
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransCmd.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    object.MsgType = 0;
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                    object.MsgType = message.MsgType;
                return object;
            };

            /**
             * Converts this TransCmd to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.TransCmd
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransCmd.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransCmd;
        })();

        MsgField.AccostTmp = (function() {

            /**
             * Properties of an AccostTmp.
             * @memberof Msg.MsgField
             * @interface IAccostTmp
             * @property {number|Long|null} [ToUin] AccostTmp ToUin
             * @property {Uint8Array|null} [Sig] AccostTmp Sig
             * @property {boolean|null} [Reply] AccostTmp Reply
             */

            /**
             * Constructs a new AccostTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents an AccostTmp.
             * @implements IAccostTmp
             * @constructor
             * @param {Msg.MsgField.IAccostTmp=} [properties] Properties to set
             */
            function AccostTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccostTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.AccostTmp
             * @instance
             */
            AccostTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccostTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.AccostTmp
             * @instance
             */
            AccostTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * AccostTmp Reply.
             * @member {boolean} Reply
             * @memberof Msg.MsgField.AccostTmp
             * @instance
             */
            AccostTmp.prototype.Reply = false;

            /**
             * Creates a new AccostTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {Msg.MsgField.IAccostTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.AccostTmp} AccostTmp instance
             */
            AccostTmp.create = function create(properties) {
                return new AccostTmp(properties);
            };

            /**
             * Encodes the specified AccostTmp message. Does not implicitly {@link Msg.MsgField.AccostTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {Msg.MsgField.IAccostTmp} message AccostTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccostTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                if (message.Reply != null && Object.hasOwnProperty.call(message, "Reply"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.Reply);
                return writer;
            };

            /**
             * Encodes the specified AccostTmp message, length delimited. Does not implicitly {@link Msg.MsgField.AccostTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {Msg.MsgField.IAccostTmp} message AccostTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccostTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccostTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.AccostTmp} AccostTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccostTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.AccostTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    case 3:
                        message.Reply = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccostTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.AccostTmp} AccostTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccostTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccostTmp message.
             * @function verify
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccostTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.Reply != null && message.hasOwnProperty("Reply"))
                    if (typeof message.Reply !== "boolean")
                        return "Reply: boolean expected";
                return null;
            };

            /**
             * Creates an AccostTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.AccostTmp} AccostTmp
             */
            AccostTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.AccostTmp)
                    return object;
                var message = new $root.Msg.MsgField.AccostTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.Reply != null)
                    message.Reply = Boolean(object.Reply);
                return message;
            };

            /**
             * Creates a plain object from an AccostTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.AccostTmp
             * @static
             * @param {Msg.MsgField.AccostTmp} message AccostTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccostTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    object.Reply = false;
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.Reply != null && message.hasOwnProperty("Reply"))
                    object.Reply = message.Reply;
                return object;
            };

            /**
             * Converts this AccostTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.AccostTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccostTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AccostTmp;
        })();

        MsgField.PubGroupTmp = (function() {

            /**
             * Properties of a PubGroupTmp.
             * @memberof Msg.MsgField
             * @interface IPubGroupTmp
             * @property {number|Long|null} [ToUin] PubGroupTmp ToUin
             * @property {Uint8Array|null} [Sig] PubGroupTmp Sig
             * @property {number|Long|null} [GroupUin] PubGroupTmp GroupUin
             */

            /**
             * Constructs a new PubGroupTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a PubGroupTmp.
             * @implements IPubGroupTmp
             * @constructor
             * @param {Msg.MsgField.IPubGroupTmp=} [properties] Properties to set
             */
            function PubGroupTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PubGroupTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.PubGroupTmp
             * @instance
             */
            PubGroupTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PubGroupTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.PubGroupTmp
             * @instance
             */
            PubGroupTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * PubGroupTmp GroupUin.
             * @member {number|Long} GroupUin
             * @memberof Msg.MsgField.PubGroupTmp
             * @instance
             */
            PubGroupTmp.prototype.GroupUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PubGroupTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {Msg.MsgField.IPubGroupTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.PubGroupTmp} PubGroupTmp instance
             */
            PubGroupTmp.create = function create(properties) {
                return new PubGroupTmp(properties);
            };

            /**
             * Encodes the specified PubGroupTmp message. Does not implicitly {@link Msg.MsgField.PubGroupTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {Msg.MsgField.IPubGroupTmp} message PubGroupTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PubGroupTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                if (message.GroupUin != null && Object.hasOwnProperty.call(message, "GroupUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GroupUin);
                return writer;
            };

            /**
             * Encodes the specified PubGroupTmp message, length delimited. Does not implicitly {@link Msg.MsgField.PubGroupTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {Msg.MsgField.IPubGroupTmp} message PubGroupTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PubGroupTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PubGroupTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.PubGroupTmp} PubGroupTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PubGroupTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PubGroupTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    case 3:
                        message.GroupUin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PubGroupTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.PubGroupTmp} PubGroupTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PubGroupTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PubGroupTmp message.
             * @function verify
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PubGroupTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.GroupUin != null && message.hasOwnProperty("GroupUin"))
                    if (!$util.isInteger(message.GroupUin) && !(message.GroupUin && $util.isInteger(message.GroupUin.low) && $util.isInteger(message.GroupUin.high)))
                        return "GroupUin: integer|Long expected";
                return null;
            };

            /**
             * Creates a PubGroupTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.PubGroupTmp} PubGroupTmp
             */
            PubGroupTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.PubGroupTmp)
                    return object;
                var message = new $root.Msg.MsgField.PubGroupTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.GroupUin != null)
                    if ($util.Long)
                        (message.GroupUin = $util.Long.fromValue(object.GroupUin)).unsigned = false;
                    else if (typeof object.GroupUin === "string")
                        message.GroupUin = parseInt(object.GroupUin, 10);
                    else if (typeof object.GroupUin === "number")
                        message.GroupUin = object.GroupUin;
                    else if (typeof object.GroupUin === "object")
                        message.GroupUin = new $util.LongBits(object.GroupUin.low >>> 0, object.GroupUin.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PubGroupTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.PubGroupTmp
             * @static
             * @param {Msg.MsgField.PubGroupTmp} message PubGroupTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PubGroupTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.GroupUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.GroupUin = options.longs === String ? "0" : 0;
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.GroupUin != null && message.hasOwnProperty("GroupUin"))
                    if (typeof message.GroupUin === "number")
                        object.GroupUin = options.longs === String ? String(message.GroupUin) : message.GroupUin;
                    else
                        object.GroupUin = options.longs === String ? $util.Long.prototype.toString.call(message.GroupUin) : options.longs === Number ? new $util.LongBits(message.GroupUin.low >>> 0, message.GroupUin.high >>> 0).toNumber() : message.GroupUin;
                return object;
            };

            /**
             * Converts this PubGroupTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.PubGroupTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PubGroupTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PubGroupTmp;
        })();

        MsgField.Trans0x211 = (function() {

            /**
             * Properties of a Trans0x211.
             * @memberof Msg.MsgField
             * @interface ITrans0x211
             * @property {number|Long|null} [Touin] Trans0x211 Touin
             * @property {number|null} [CcCmd] Trans0x211 CcCmd
             * @property {Msg.MsgField.ImMsgHead.IInstCtrl|null} [Instctrl] Trans0x211 Instctrl
             * @property {Uint8Array|null} [Sig] Trans0x211 Sig
             * @property {number|null} [C2cType] Trans0x211 C2cType
             * @property {number|null} [ServiceType] Trans0x211 ServiceType
             */

            /**
             * Constructs a new Trans0x211.
             * @memberof Msg.MsgField
             * @classdesc Represents a Trans0x211.
             * @implements ITrans0x211
             * @constructor
             * @param {Msg.MsgField.ITrans0x211=} [properties] Properties to set
             */
            function Trans0x211(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Trans0x211 Touin.
             * @member {number|Long} Touin
             * @memberof Msg.MsgField.Trans0x211
             * @instance
             */
            Trans0x211.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Trans0x211 CcCmd.
             * @member {number} CcCmd
             * @memberof Msg.MsgField.Trans0x211
             * @instance
             */
            Trans0x211.prototype.CcCmd = 0;

            /**
             * Trans0x211 Instctrl.
             * @member {Msg.MsgField.ImMsgHead.IInstCtrl|null|undefined} Instctrl
             * @memberof Msg.MsgField.Trans0x211
             * @instance
             */
            Trans0x211.prototype.Instctrl = null;

            /**
             * Trans0x211 Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.Trans0x211
             * @instance
             */
            Trans0x211.prototype.Sig = $util.newBuffer([]);

            /**
             * Trans0x211 C2cType.
             * @member {number} C2cType
             * @memberof Msg.MsgField.Trans0x211
             * @instance
             */
            Trans0x211.prototype.C2cType = 0;

            /**
             * Trans0x211 ServiceType.
             * @member {number} ServiceType
             * @memberof Msg.MsgField.Trans0x211
             * @instance
             */
            Trans0x211.prototype.ServiceType = 0;

            /**
             * Creates a new Trans0x211 instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {Msg.MsgField.ITrans0x211=} [properties] Properties to set
             * @returns {Msg.MsgField.Trans0x211} Trans0x211 instance
             */
            Trans0x211.create = function create(properties) {
                return new Trans0x211(properties);
            };

            /**
             * Encodes the specified Trans0x211 message. Does not implicitly {@link Msg.MsgField.Trans0x211.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {Msg.MsgField.ITrans0x211} message Trans0x211 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trans0x211.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Touin);
                if (message.CcCmd != null && Object.hasOwnProperty.call(message, "CcCmd"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CcCmd);
                if (message.Instctrl != null && Object.hasOwnProperty.call(message, "Instctrl"))
                    $root.Msg.MsgField.ImMsgHead.InstCtrl.encode(message.Instctrl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Sig);
                if (message.C2cType != null && Object.hasOwnProperty.call(message, "C2cType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.C2cType);
                if (message.ServiceType != null && Object.hasOwnProperty.call(message, "ServiceType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.ServiceType);
                return writer;
            };

            /**
             * Encodes the specified Trans0x211 message, length delimited. Does not implicitly {@link Msg.MsgField.Trans0x211.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {Msg.MsgField.ITrans0x211} message Trans0x211 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trans0x211.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Trans0x211 message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.Trans0x211} Trans0x211
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trans0x211.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.Trans0x211();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Touin = reader.int64();
                        break;
                    case 2:
                        message.CcCmd = reader.int32();
                        break;
                    case 3:
                        message.Instctrl = $root.Msg.MsgField.ImMsgHead.InstCtrl.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.Sig = reader.bytes();
                        break;
                    case 5:
                        message.C2cType = reader.int32();
                        break;
                    case 6:
                        message.ServiceType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Trans0x211 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.Trans0x211} Trans0x211
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trans0x211.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Trans0x211 message.
             * @function verify
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Trans0x211.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                        return "Touin: integer|Long expected";
                if (message.CcCmd != null && message.hasOwnProperty("CcCmd"))
                    if (!$util.isInteger(message.CcCmd))
                        return "CcCmd: integer expected";
                if (message.Instctrl != null && message.hasOwnProperty("Instctrl")) {
                    var error = $root.Msg.MsgField.ImMsgHead.InstCtrl.verify(message.Instctrl);
                    if (error)
                        return "Instctrl." + error;
                }
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.C2cType != null && message.hasOwnProperty("C2cType"))
                    if (!$util.isInteger(message.C2cType))
                        return "C2cType: integer expected";
                if (message.ServiceType != null && message.hasOwnProperty("ServiceType"))
                    if (!$util.isInteger(message.ServiceType))
                        return "ServiceType: integer expected";
                return null;
            };

            /**
             * Creates a Trans0x211 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.Trans0x211} Trans0x211
             */
            Trans0x211.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.Trans0x211)
                    return object;
                var message = new $root.Msg.MsgField.Trans0x211();
                if (object.Touin != null)
                    if ($util.Long)
                        (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                    else if (typeof object.Touin === "string")
                        message.Touin = parseInt(object.Touin, 10);
                    else if (typeof object.Touin === "number")
                        message.Touin = object.Touin;
                    else if (typeof object.Touin === "object")
                        message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                if (object.CcCmd != null)
                    message.CcCmd = object.CcCmd | 0;
                if (object.Instctrl != null) {
                    if (typeof object.Instctrl !== "object")
                        throw TypeError(".Msg.MsgField.Trans0x211.Instctrl: object expected");
                    message.Instctrl = $root.Msg.MsgField.ImMsgHead.InstCtrl.fromObject(object.Instctrl);
                }
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.C2cType != null)
                    message.C2cType = object.C2cType | 0;
                if (object.ServiceType != null)
                    message.ServiceType = object.ServiceType | 0;
                return message;
            };

            /**
             * Creates a plain object from a Trans0x211 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.Trans0x211
             * @static
             * @param {Msg.MsgField.Trans0x211} message Trans0x211
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Trans0x211.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Touin = options.longs === String ? "0" : 0;
                    object.CcCmd = 0;
                    object.Instctrl = null;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    object.C2cType = 0;
                    object.ServiceType = 0;
                }
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (typeof message.Touin === "number")
                        object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                    else
                        object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                if (message.CcCmd != null && message.hasOwnProperty("CcCmd"))
                    object.CcCmd = message.CcCmd;
                if (message.Instctrl != null && message.hasOwnProperty("Instctrl"))
                    object.Instctrl = $root.Msg.MsgField.ImMsgHead.InstCtrl.toObject(message.Instctrl, options);
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.C2cType != null && message.hasOwnProperty("C2cType"))
                    object.C2cType = message.C2cType;
                if (message.ServiceType != null && message.hasOwnProperty("ServiceType"))
                    object.ServiceType = message.ServiceType;
                return object;
            };

            /**
             * Converts this Trans0x211 to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.Trans0x211
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Trans0x211.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Trans0x211;
        })();

        MsgField.BusinessWPATmp = (function() {

            /**
             * Properties of a BusinessWPATmp.
             * @memberof Msg.MsgField
             * @interface IBusinessWPATmp
             * @property {number|Long|null} [Touin] BusinessWPATmp Touin
             * @property {Uint8Array|null} [Sig] BusinessWPATmp Sig
             * @property {Uint8Array|null} [Sigt] BusinessWPATmp Sigt
             */

            /**
             * Constructs a new BusinessWPATmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a BusinessWPATmp.
             * @implements IBusinessWPATmp
             * @constructor
             * @param {Msg.MsgField.IBusinessWPATmp=} [properties] Properties to set
             */
            function BusinessWPATmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BusinessWPATmp Touin.
             * @member {number|Long} Touin
             * @memberof Msg.MsgField.BusinessWPATmp
             * @instance
             */
            BusinessWPATmp.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BusinessWPATmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.BusinessWPATmp
             * @instance
             */
            BusinessWPATmp.prototype.Sig = $util.newBuffer([]);

            /**
             * BusinessWPATmp Sigt.
             * @member {Uint8Array} Sigt
             * @memberof Msg.MsgField.BusinessWPATmp
             * @instance
             */
            BusinessWPATmp.prototype.Sigt = $util.newBuffer([]);

            /**
             * Creates a new BusinessWPATmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {Msg.MsgField.IBusinessWPATmp=} [properties] Properties to set
             * @returns {Msg.MsgField.BusinessWPATmp} BusinessWPATmp instance
             */
            BusinessWPATmp.create = function create(properties) {
                return new BusinessWPATmp(properties);
            };

            /**
             * Encodes the specified BusinessWPATmp message. Does not implicitly {@link Msg.MsgField.BusinessWPATmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {Msg.MsgField.IBusinessWPATmp} message BusinessWPATmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BusinessWPATmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Touin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                if (message.Sigt != null && Object.hasOwnProperty.call(message, "Sigt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Sigt);
                return writer;
            };

            /**
             * Encodes the specified BusinessWPATmp message, length delimited. Does not implicitly {@link Msg.MsgField.BusinessWPATmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {Msg.MsgField.IBusinessWPATmp} message BusinessWPATmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BusinessWPATmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BusinessWPATmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.BusinessWPATmp} BusinessWPATmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BusinessWPATmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.BusinessWPATmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Touin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    case 3:
                        message.Sigt = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BusinessWPATmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.BusinessWPATmp} BusinessWPATmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BusinessWPATmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BusinessWPATmp message.
             * @function verify
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BusinessWPATmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                        return "Touin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.Sigt != null && message.hasOwnProperty("Sigt"))
                    if (!(message.Sigt && typeof message.Sigt.length === "number" || $util.isString(message.Sigt)))
                        return "Sigt: buffer expected";
                return null;
            };

            /**
             * Creates a BusinessWPATmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.BusinessWPATmp} BusinessWPATmp
             */
            BusinessWPATmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.BusinessWPATmp)
                    return object;
                var message = new $root.Msg.MsgField.BusinessWPATmp();
                if (object.Touin != null)
                    if ($util.Long)
                        (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                    else if (typeof object.Touin === "string")
                        message.Touin = parseInt(object.Touin, 10);
                    else if (typeof object.Touin === "number")
                        message.Touin = object.Touin;
                    else if (typeof object.Touin === "object")
                        message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.Sigt != null)
                    if (typeof object.Sigt === "string")
                        $util.base64.decode(object.Sigt, message.Sigt = $util.newBuffer($util.base64.length(object.Sigt)), 0);
                    else if (object.Sigt.length)
                        message.Sigt = object.Sigt;
                return message;
            };

            /**
             * Creates a plain object from a BusinessWPATmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.BusinessWPATmp
             * @static
             * @param {Msg.MsgField.BusinessWPATmp} message BusinessWPATmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BusinessWPATmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Touin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    if (options.bytes === String)
                        object.Sigt = "";
                    else {
                        object.Sigt = [];
                        if (options.bytes !== Array)
                            object.Sigt = $util.newBuffer(object.Sigt);
                    }
                }
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (typeof message.Touin === "number")
                        object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                    else
                        object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.Sigt != null && message.hasOwnProperty("Sigt"))
                    object.Sigt = options.bytes === String ? $util.base64.encode(message.Sigt, 0, message.Sigt.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sigt) : message.Sigt;
                return object;
            };

            /**
             * Converts this BusinessWPATmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.BusinessWPATmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BusinessWPATmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BusinessWPATmp;
        })();

        MsgField.AuthTmp = (function() {

            /**
             * Properties of an AuthTmp.
             * @memberof Msg.MsgField
             * @interface IAuthTmp
             * @property {number|Long|null} [ToUin] AuthTmp ToUin
             * @property {Uint8Array|null} [Sig] AuthTmp Sig
             */

            /**
             * Constructs a new AuthTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents an AuthTmp.
             * @implements IAuthTmp
             * @constructor
             * @param {Msg.MsgField.IAuthTmp=} [properties] Properties to set
             */
            function AuthTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AuthTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.AuthTmp
             * @instance
             */
            AuthTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AuthTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.AuthTmp
             * @instance
             */
            AuthTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * Creates a new AuthTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {Msg.MsgField.IAuthTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.AuthTmp} AuthTmp instance
             */
            AuthTmp.create = function create(properties) {
                return new AuthTmp(properties);
            };

            /**
             * Encodes the specified AuthTmp message. Does not implicitly {@link Msg.MsgField.AuthTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {Msg.MsgField.IAuthTmp} message AuthTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                return writer;
            };

            /**
             * Encodes the specified AuthTmp message, length delimited. Does not implicitly {@link Msg.MsgField.AuthTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {Msg.MsgField.IAuthTmp} message AuthTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AuthTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.AuthTmp} AuthTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.AuthTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AuthTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.AuthTmp} AuthTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AuthTmp message.
             * @function verify
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                return null;
            };

            /**
             * Creates an AuthTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.AuthTmp} AuthTmp
             */
            AuthTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.AuthTmp)
                    return object;
                var message = new $root.Msg.MsgField.AuthTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                return message;
            };

            /**
             * Creates a plain object from an AuthTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.AuthTmp
             * @static
             * @param {Msg.MsgField.AuthTmp} message AuthTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                return object;
            };

            /**
             * Converts this AuthTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.AuthTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AuthTmp;
        })();

        MsgField.BsnsTmp = (function() {

            /**
             * Properties of a BsnsTmp.
             * @memberof Msg.MsgField
             * @interface IBsnsTmp
             * @property {number|Long|null} [ToUin] BsnsTmp ToUin
             * @property {Uint8Array|null} [Sig] BsnsTmp Sig
             */

            /**
             * Constructs a new BsnsTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a BsnsTmp.
             * @implements IBsnsTmp
             * @constructor
             * @param {Msg.MsgField.IBsnsTmp=} [properties] Properties to set
             */
            function BsnsTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BsnsTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.BsnsTmp
             * @instance
             */
            BsnsTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BsnsTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.BsnsTmp
             * @instance
             */
            BsnsTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * Creates a new BsnsTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {Msg.MsgField.IBsnsTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.BsnsTmp} BsnsTmp instance
             */
            BsnsTmp.create = function create(properties) {
                return new BsnsTmp(properties);
            };

            /**
             * Encodes the specified BsnsTmp message. Does not implicitly {@link Msg.MsgField.BsnsTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {Msg.MsgField.IBsnsTmp} message BsnsTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BsnsTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                return writer;
            };

            /**
             * Encodes the specified BsnsTmp message, length delimited. Does not implicitly {@link Msg.MsgField.BsnsTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {Msg.MsgField.IBsnsTmp} message BsnsTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BsnsTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BsnsTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.BsnsTmp} BsnsTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BsnsTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.BsnsTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BsnsTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.BsnsTmp} BsnsTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BsnsTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BsnsTmp message.
             * @function verify
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BsnsTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                return null;
            };

            /**
             * Creates a BsnsTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.BsnsTmp} BsnsTmp
             */
            BsnsTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.BsnsTmp)
                    return object;
                var message = new $root.Msg.MsgField.BsnsTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                return message;
            };

            /**
             * Creates a plain object from a BsnsTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.BsnsTmp
             * @static
             * @param {Msg.MsgField.BsnsTmp} message BsnsTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BsnsTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                return object;
            };

            /**
             * Converts this BsnsTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.BsnsTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BsnsTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BsnsTmp;
        })();

        MsgField.QqqueryBusinessTmp = (function() {

            /**
             * Properties of a QqqueryBusinessTmp.
             * @memberof Msg.MsgField
             * @interface IQqqueryBusinessTmp
             * @property {number|Long|null} [ToUin] QqqueryBusinessTmp ToUin
             * @property {Uint8Array|null} [Sig] QqqueryBusinessTmp Sig
             */

            /**
             * Constructs a new QqqueryBusinessTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a QqqueryBusinessTmp.
             * @implements IQqqueryBusinessTmp
             * @constructor
             * @param {Msg.MsgField.IQqqueryBusinessTmp=} [properties] Properties to set
             */
            function QqqueryBusinessTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QqqueryBusinessTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @instance
             */
            QqqueryBusinessTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * QqqueryBusinessTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @instance
             */
            QqqueryBusinessTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * Creates a new QqqueryBusinessTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {Msg.MsgField.IQqqueryBusinessTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.QqqueryBusinessTmp} QqqueryBusinessTmp instance
             */
            QqqueryBusinessTmp.create = function create(properties) {
                return new QqqueryBusinessTmp(properties);
            };

            /**
             * Encodes the specified QqqueryBusinessTmp message. Does not implicitly {@link Msg.MsgField.QqqueryBusinessTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {Msg.MsgField.IQqqueryBusinessTmp} message QqqueryBusinessTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QqqueryBusinessTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                return writer;
            };

            /**
             * Encodes the specified QqqueryBusinessTmp message, length delimited. Does not implicitly {@link Msg.MsgField.QqqueryBusinessTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {Msg.MsgField.IQqqueryBusinessTmp} message QqqueryBusinessTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QqqueryBusinessTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QqqueryBusinessTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.QqqueryBusinessTmp} QqqueryBusinessTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QqqueryBusinessTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.QqqueryBusinessTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QqqueryBusinessTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.QqqueryBusinessTmp} QqqueryBusinessTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QqqueryBusinessTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QqqueryBusinessTmp message.
             * @function verify
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QqqueryBusinessTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                return null;
            };

            /**
             * Creates a QqqueryBusinessTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.QqqueryBusinessTmp} QqqueryBusinessTmp
             */
            QqqueryBusinessTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.QqqueryBusinessTmp)
                    return object;
                var message = new $root.Msg.MsgField.QqqueryBusinessTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                return message;
            };

            /**
             * Creates a plain object from a QqqueryBusinessTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @static
             * @param {Msg.MsgField.QqqueryBusinessTmp} message QqqueryBusinessTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QqqueryBusinessTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                return object;
            };

            /**
             * Converts this QqqueryBusinessTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.QqqueryBusinessTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QqqueryBusinessTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QqqueryBusinessTmp;
        })();

        MsgField.NearbyDatingTmp = (function() {

            /**
             * Properties of a NearbyDatingTmp.
             * @memberof Msg.MsgField
             * @interface INearbyDatingTmp
             * @property {number|Long|null} [ToUin] NearbyDatingTmp ToUin
             * @property {Uint8Array|null} [Sig] NearbyDatingTmp Sig
             * @property {boolean|null} [Reply] NearbyDatingTmp Reply
             */

            /**
             * Constructs a new NearbyDatingTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a NearbyDatingTmp.
             * @implements INearbyDatingTmp
             * @constructor
             * @param {Msg.MsgField.INearbyDatingTmp=} [properties] Properties to set
             */
            function NearbyDatingTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NearbyDatingTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @instance
             */
            NearbyDatingTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * NearbyDatingTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @instance
             */
            NearbyDatingTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * NearbyDatingTmp Reply.
             * @member {boolean} Reply
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @instance
             */
            NearbyDatingTmp.prototype.Reply = false;

            /**
             * Creates a new NearbyDatingTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {Msg.MsgField.INearbyDatingTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.NearbyDatingTmp} NearbyDatingTmp instance
             */
            NearbyDatingTmp.create = function create(properties) {
                return new NearbyDatingTmp(properties);
            };

            /**
             * Encodes the specified NearbyDatingTmp message. Does not implicitly {@link Msg.MsgField.NearbyDatingTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {Msg.MsgField.INearbyDatingTmp} message NearbyDatingTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NearbyDatingTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                if (message.Reply != null && Object.hasOwnProperty.call(message, "Reply"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.Reply);
                return writer;
            };

            /**
             * Encodes the specified NearbyDatingTmp message, length delimited. Does not implicitly {@link Msg.MsgField.NearbyDatingTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {Msg.MsgField.INearbyDatingTmp} message NearbyDatingTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NearbyDatingTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NearbyDatingTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.NearbyDatingTmp} NearbyDatingTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NearbyDatingTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.NearbyDatingTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    case 3:
                        message.Reply = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NearbyDatingTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.NearbyDatingTmp} NearbyDatingTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NearbyDatingTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NearbyDatingTmp message.
             * @function verify
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NearbyDatingTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.Reply != null && message.hasOwnProperty("Reply"))
                    if (typeof message.Reply !== "boolean")
                        return "Reply: boolean expected";
                return null;
            };

            /**
             * Creates a NearbyDatingTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.NearbyDatingTmp} NearbyDatingTmp
             */
            NearbyDatingTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.NearbyDatingTmp)
                    return object;
                var message = new $root.Msg.MsgField.NearbyDatingTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.Reply != null)
                    message.Reply = Boolean(object.Reply);
                return message;
            };

            /**
             * Creates a plain object from a NearbyDatingTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @static
             * @param {Msg.MsgField.NearbyDatingTmp} message NearbyDatingTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NearbyDatingTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    object.Reply = false;
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.Reply != null && message.hasOwnProperty("Reply"))
                    object.Reply = message.Reply;
                return object;
            };

            /**
             * Converts this NearbyDatingTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.NearbyDatingTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NearbyDatingTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NearbyDatingTmp;
        })();

        MsgField.NearByAssistantTmp = (function() {

            /**
             * Properties of a NearByAssistantTmp.
             * @memberof Msg.MsgField
             * @interface INearByAssistantTmp
             * @property {number|Long|null} [ToUin] NearByAssistantTmp ToUin
             * @property {Uint8Array|null} [Sig] NearByAssistantTmp Sig
             * @property {boolean|null} [Reply] NearByAssistantTmp Reply
             */

            /**
             * Constructs a new NearByAssistantTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a NearByAssistantTmp.
             * @implements INearByAssistantTmp
             * @constructor
             * @param {Msg.MsgField.INearByAssistantTmp=} [properties] Properties to set
             */
            function NearByAssistantTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NearByAssistantTmp ToUin.
             * @member {number|Long} ToUin
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @instance
             */
            NearByAssistantTmp.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * NearByAssistantTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @instance
             */
            NearByAssistantTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * NearByAssistantTmp Reply.
             * @member {boolean} Reply
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @instance
             */
            NearByAssistantTmp.prototype.Reply = false;

            /**
             * Creates a new NearByAssistantTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {Msg.MsgField.INearByAssistantTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.NearByAssistantTmp} NearByAssistantTmp instance
             */
            NearByAssistantTmp.create = function create(properties) {
                return new NearByAssistantTmp(properties);
            };

            /**
             * Encodes the specified NearByAssistantTmp message. Does not implicitly {@link Msg.MsgField.NearByAssistantTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {Msg.MsgField.INearByAssistantTmp} message NearByAssistantTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NearByAssistantTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ToUin);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Sig);
                if (message.Reply != null && Object.hasOwnProperty.call(message, "Reply"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.Reply);
                return writer;
            };

            /**
             * Encodes the specified NearByAssistantTmp message, length delimited. Does not implicitly {@link Msg.MsgField.NearByAssistantTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {Msg.MsgField.INearByAssistantTmp} message NearByAssistantTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NearByAssistantTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NearByAssistantTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.NearByAssistantTmp} NearByAssistantTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NearByAssistantTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.NearByAssistantTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ToUin = reader.int64();
                        break;
                    case 2:
                        message.Sig = reader.bytes();
                        break;
                    case 3:
                        message.Reply = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NearByAssistantTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.NearByAssistantTmp} NearByAssistantTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NearByAssistantTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NearByAssistantTmp message.
             * @function verify
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NearByAssistantTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                        return "ToUin: integer|Long expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.Reply != null && message.hasOwnProperty("Reply"))
                    if (typeof message.Reply !== "boolean")
                        return "Reply: boolean expected";
                return null;
            };

            /**
             * Creates a NearByAssistantTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.NearByAssistantTmp} NearByAssistantTmp
             */
            NearByAssistantTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.NearByAssistantTmp)
                    return object;
                var message = new $root.Msg.MsgField.NearByAssistantTmp();
                if (object.ToUin != null)
                    if ($util.Long)
                        (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                    else if (typeof object.ToUin === "string")
                        message.ToUin = parseInt(object.ToUin, 10);
                    else if (typeof object.ToUin === "number")
                        message.ToUin = object.ToUin;
                    else if (typeof object.ToUin === "object")
                        message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.Reply != null)
                    message.Reply = Boolean(object.Reply);
                return message;
            };

            /**
             * Creates a plain object from a NearByAssistantTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @static
             * @param {Msg.MsgField.NearByAssistantTmp} message NearByAssistantTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NearByAssistantTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ToUin = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    object.Reply = false;
                }
                if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                    if (typeof message.ToUin === "number")
                        object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                    else
                        object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.Reply != null && message.hasOwnProperty("Reply"))
                    object.Reply = message.Reply;
                return object;
            };

            /**
             * Converts this NearByAssistantTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.NearByAssistantTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NearByAssistantTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NearByAssistantTmp;
        })();

        MsgField.CommTmp = (function() {

            /**
             * Properties of a CommTmp.
             * @memberof Msg.MsgField
             * @interface ICommTmp
             * @property {number|Long|null} [Touin] CommTmp Touin
             * @property {number|null} [C2ctype] CommTmp C2ctype
             * @property {number|null} [Svrtype] CommTmp Svrtype
             * @property {Uint8Array|null} [Sig] CommTmp Sig
             * @property {Uint8Array|null} [Reserved] CommTmp Reserved
             */

            /**
             * Constructs a new CommTmp.
             * @memberof Msg.MsgField
             * @classdesc Represents a CommTmp.
             * @implements ICommTmp
             * @constructor
             * @param {Msg.MsgField.ICommTmp=} [properties] Properties to set
             */
            function CommTmp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommTmp Touin.
             * @member {number|Long} Touin
             * @memberof Msg.MsgField.CommTmp
             * @instance
             */
            CommTmp.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * CommTmp C2ctype.
             * @member {number} C2ctype
             * @memberof Msg.MsgField.CommTmp
             * @instance
             */
            CommTmp.prototype.C2ctype = 0;

            /**
             * CommTmp Svrtype.
             * @member {number} Svrtype
             * @memberof Msg.MsgField.CommTmp
             * @instance
             */
            CommTmp.prototype.Svrtype = 0;

            /**
             * CommTmp Sig.
             * @member {Uint8Array} Sig
             * @memberof Msg.MsgField.CommTmp
             * @instance
             */
            CommTmp.prototype.Sig = $util.newBuffer([]);

            /**
             * CommTmp Reserved.
             * @member {Uint8Array} Reserved
             * @memberof Msg.MsgField.CommTmp
             * @instance
             */
            CommTmp.prototype.Reserved = $util.newBuffer([]);

            /**
             * Creates a new CommTmp instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {Msg.MsgField.ICommTmp=} [properties] Properties to set
             * @returns {Msg.MsgField.CommTmp} CommTmp instance
             */
            CommTmp.create = function create(properties) {
                return new CommTmp(properties);
            };

            /**
             * Encodes the specified CommTmp message. Does not implicitly {@link Msg.MsgField.CommTmp.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {Msg.MsgField.ICommTmp} message CommTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommTmp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Touin);
                if (message.C2ctype != null && Object.hasOwnProperty.call(message, "C2ctype"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.C2ctype);
                if (message.Svrtype != null && Object.hasOwnProperty.call(message, "Svrtype"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Svrtype);
                if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Sig);
                if (message.Reserved != null && Object.hasOwnProperty.call(message, "Reserved"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Reserved);
                return writer;
            };

            /**
             * Encodes the specified CommTmp message, length delimited. Does not implicitly {@link Msg.MsgField.CommTmp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {Msg.MsgField.ICommTmp} message CommTmp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommTmp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommTmp message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.CommTmp} CommTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommTmp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.CommTmp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Touin = reader.int64();
                        break;
                    case 2:
                        message.C2ctype = reader.int32();
                        break;
                    case 3:
                        message.Svrtype = reader.int32();
                        break;
                    case 4:
                        message.Sig = reader.bytes();
                        break;
                    case 5:
                        message.Reserved = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommTmp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.CommTmp} CommTmp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommTmp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommTmp message.
             * @function verify
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommTmp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                        return "Touin: integer|Long expected";
                if (message.C2ctype != null && message.hasOwnProperty("C2ctype"))
                    if (!$util.isInteger(message.C2ctype))
                        return "C2ctype: integer expected";
                if (message.Svrtype != null && message.hasOwnProperty("Svrtype"))
                    if (!$util.isInteger(message.Svrtype))
                        return "Svrtype: integer expected";
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                        return "Sig: buffer expected";
                if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                    if (!(message.Reserved && typeof message.Reserved.length === "number" || $util.isString(message.Reserved)))
                        return "Reserved: buffer expected";
                return null;
            };

            /**
             * Creates a CommTmp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.CommTmp} CommTmp
             */
            CommTmp.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.CommTmp)
                    return object;
                var message = new $root.Msg.MsgField.CommTmp();
                if (object.Touin != null)
                    if ($util.Long)
                        (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                    else if (typeof object.Touin === "string")
                        message.Touin = parseInt(object.Touin, 10);
                    else if (typeof object.Touin === "number")
                        message.Touin = object.Touin;
                    else if (typeof object.Touin === "object")
                        message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                if (object.C2ctype != null)
                    message.C2ctype = object.C2ctype | 0;
                if (object.Svrtype != null)
                    message.Svrtype = object.Svrtype | 0;
                if (object.Sig != null)
                    if (typeof object.Sig === "string")
                        $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                    else if (object.Sig.length)
                        message.Sig = object.Sig;
                if (object.Reserved != null)
                    if (typeof object.Reserved === "string")
                        $util.base64.decode(object.Reserved, message.Reserved = $util.newBuffer($util.base64.length(object.Reserved)), 0);
                    else if (object.Reserved.length)
                        message.Reserved = object.Reserved;
                return message;
            };

            /**
             * Creates a plain object from a CommTmp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.CommTmp
             * @static
             * @param {Msg.MsgField.CommTmp} message CommTmp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommTmp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Touin = options.longs === String ? "0" : 0;
                    object.C2ctype = 0;
                    object.Svrtype = 0;
                    if (options.bytes === String)
                        object.Sig = "";
                    else {
                        object.Sig = [];
                        if (options.bytes !== Array)
                            object.Sig = $util.newBuffer(object.Sig);
                    }
                    if (options.bytes === String)
                        object.Reserved = "";
                    else {
                        object.Reserved = [];
                        if (options.bytes !== Array)
                            object.Reserved = $util.newBuffer(object.Reserved);
                    }
                }
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (typeof message.Touin === "number")
                        object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                    else
                        object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                if (message.C2ctype != null && message.hasOwnProperty("C2ctype"))
                    object.C2ctype = message.C2ctype;
                if (message.Svrtype != null && message.hasOwnProperty("Svrtype"))
                    object.Svrtype = message.Svrtype;
                if (message.Sig != null && message.hasOwnProperty("Sig"))
                    object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
                if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                    object.Reserved = options.bytes === String ? $util.base64.encode(message.Reserved, 0, message.Reserved.length) : options.bytes === Array ? Array.prototype.slice.call(message.Reserved) : message.Reserved;
                return object;
            };

            /**
             * Converts this CommTmp to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.CommTmp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommTmp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommTmp;
        })();

        MsgField.RoutingHead = (function() {

            /**
             * Properties of a RoutingHead.
             * @memberof Msg.MsgField
             * @interface IRoutingHead
             * @property {Msg.MsgField.IC2c|null} [C2c] RoutingHead C2c
             * @property {Msg.MsgField.IGrp|null} [Grp] RoutingHead Grp
             * @property {Msg.MsgField.IGrpTmp|null} [GrpTmp] RoutingHead GrpTmp
             * @property {Msg.MsgField.IDis|null} [Dis] RoutingHead Dis
             * @property {Msg.MsgField.IDisTmp|null} [DisTmp] RoutingHead DisTmp
             * @property {Msg.MsgField.IWpaTmp|null} [WpaTmp] RoutingHead WpaTmp
             * @property {Msg.MsgField.ISecretFileHead|null} [SecretFileHead] RoutingHead SecretFileHead
             * @property {Msg.MsgField.IPublicPlat|null} [PublicPlat] RoutingHead PublicPlat
             * @property {Msg.MsgField.ITransMsg|null} [TransMsg] RoutingHead TransMsg
             * @property {Msg.MsgField.IAddressListTmp|null} [AddressListTmp] RoutingHead AddressListTmp
             * @property {Msg.MsgField.IRichStatusTmp|null} [RichStatusTmp] RoutingHead RichStatusTmp
             * @property {Msg.MsgField.ITransCmd|null} [TransCmd] RoutingHead TransCmd
             * @property {Msg.MsgField.IAccostTmp|null} [AccostTmp] RoutingHead AccostTmp
             * @property {Msg.MsgField.IPubGroupTmp|null} [PubGroupTmp] RoutingHead PubGroupTmp
             * @property {Msg.MsgField.ITrans0x211|null} [Trans0x211] RoutingHead Trans0x211
             * @property {Msg.MsgField.IBusinessWPATmp|null} [BusinessWPATmp] RoutingHead BusinessWPATmp
             * @property {Msg.MsgField.IAuthTmp|null} [AuthTmp] RoutingHead AuthTmp
             * @property {Msg.MsgField.IBsnsTmp|null} [BsnsTmp] RoutingHead BsnsTmp
             * @property {Msg.MsgField.IQqqueryBusinessTmp|null} [QqqueryBusinessTmp] RoutingHead QqqueryBusinessTmp
             * @property {Msg.MsgField.INearbyDatingTmp|null} [NearbyDatingTmp] RoutingHead NearbyDatingTmp
             * @property {Msg.MsgField.INearByAssistantTmp|null} [NearByAssistantTmp] RoutingHead NearByAssistantTmp
             * @property {Msg.MsgField.ICommTmp|null} [CommTmp] RoutingHead CommTmp
             */

            /**
             * Constructs a new RoutingHead.
             * @memberof Msg.MsgField
             * @classdesc Represents a RoutingHead.
             * @implements IRoutingHead
             * @constructor
             * @param {Msg.MsgField.IRoutingHead=} [properties] Properties to set
             */
            function RoutingHead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoutingHead C2c.
             * @member {Msg.MsgField.IC2c|null|undefined} C2c
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.C2c = null;

            /**
             * RoutingHead Grp.
             * @member {Msg.MsgField.IGrp|null|undefined} Grp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.Grp = null;

            /**
             * RoutingHead GrpTmp.
             * @member {Msg.MsgField.IGrpTmp|null|undefined} GrpTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.GrpTmp = null;

            /**
             * RoutingHead Dis.
             * @member {Msg.MsgField.IDis|null|undefined} Dis
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.Dis = null;

            /**
             * RoutingHead DisTmp.
             * @member {Msg.MsgField.IDisTmp|null|undefined} DisTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.DisTmp = null;

            /**
             * RoutingHead WpaTmp.
             * @member {Msg.MsgField.IWpaTmp|null|undefined} WpaTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.WpaTmp = null;

            /**
             * RoutingHead SecretFileHead.
             * @member {Msg.MsgField.ISecretFileHead|null|undefined} SecretFileHead
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.SecretFileHead = null;

            /**
             * RoutingHead PublicPlat.
             * @member {Msg.MsgField.IPublicPlat|null|undefined} PublicPlat
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.PublicPlat = null;

            /**
             * RoutingHead TransMsg.
             * @member {Msg.MsgField.ITransMsg|null|undefined} TransMsg
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.TransMsg = null;

            /**
             * RoutingHead AddressListTmp.
             * @member {Msg.MsgField.IAddressListTmp|null|undefined} AddressListTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.AddressListTmp = null;

            /**
             * RoutingHead RichStatusTmp.
             * @member {Msg.MsgField.IRichStatusTmp|null|undefined} RichStatusTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.RichStatusTmp = null;

            /**
             * RoutingHead TransCmd.
             * @member {Msg.MsgField.ITransCmd|null|undefined} TransCmd
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.TransCmd = null;

            /**
             * RoutingHead AccostTmp.
             * @member {Msg.MsgField.IAccostTmp|null|undefined} AccostTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.AccostTmp = null;

            /**
             * RoutingHead PubGroupTmp.
             * @member {Msg.MsgField.IPubGroupTmp|null|undefined} PubGroupTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.PubGroupTmp = null;

            /**
             * RoutingHead Trans0x211.
             * @member {Msg.MsgField.ITrans0x211|null|undefined} Trans0x211
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.Trans0x211 = null;

            /**
             * RoutingHead BusinessWPATmp.
             * @member {Msg.MsgField.IBusinessWPATmp|null|undefined} BusinessWPATmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.BusinessWPATmp = null;

            /**
             * RoutingHead AuthTmp.
             * @member {Msg.MsgField.IAuthTmp|null|undefined} AuthTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.AuthTmp = null;

            /**
             * RoutingHead BsnsTmp.
             * @member {Msg.MsgField.IBsnsTmp|null|undefined} BsnsTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.BsnsTmp = null;

            /**
             * RoutingHead QqqueryBusinessTmp.
             * @member {Msg.MsgField.IQqqueryBusinessTmp|null|undefined} QqqueryBusinessTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.QqqueryBusinessTmp = null;

            /**
             * RoutingHead NearbyDatingTmp.
             * @member {Msg.MsgField.INearbyDatingTmp|null|undefined} NearbyDatingTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.NearbyDatingTmp = null;

            /**
             * RoutingHead NearByAssistantTmp.
             * @member {Msg.MsgField.INearByAssistantTmp|null|undefined} NearByAssistantTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.NearByAssistantTmp = null;

            /**
             * RoutingHead CommTmp.
             * @member {Msg.MsgField.ICommTmp|null|undefined} CommTmp
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             */
            RoutingHead.prototype.CommTmp = null;

            /**
             * Creates a new RoutingHead instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {Msg.MsgField.IRoutingHead=} [properties] Properties to set
             * @returns {Msg.MsgField.RoutingHead} RoutingHead instance
             */
            RoutingHead.create = function create(properties) {
                return new RoutingHead(properties);
            };

            /**
             * Encodes the specified RoutingHead message. Does not implicitly {@link Msg.MsgField.RoutingHead.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {Msg.MsgField.IRoutingHead} message RoutingHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoutingHead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.C2c != null && Object.hasOwnProperty.call(message, "C2c"))
                    $root.Msg.MsgField.C2c.encode(message.C2c, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Grp != null && Object.hasOwnProperty.call(message, "Grp"))
                    $root.Msg.MsgField.Grp.encode(message.Grp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.GrpTmp != null && Object.hasOwnProperty.call(message, "GrpTmp"))
                    $root.Msg.MsgField.GrpTmp.encode(message.GrpTmp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.Dis != null && Object.hasOwnProperty.call(message, "Dis"))
                    $root.Msg.MsgField.Dis.encode(message.Dis, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.DisTmp != null && Object.hasOwnProperty.call(message, "DisTmp"))
                    $root.Msg.MsgField.DisTmp.encode(message.DisTmp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.WpaTmp != null && Object.hasOwnProperty.call(message, "WpaTmp"))
                    $root.Msg.MsgField.WpaTmp.encode(message.WpaTmp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.SecretFileHead != null && Object.hasOwnProperty.call(message, "SecretFileHead"))
                    $root.Msg.MsgField.SecretFileHead.encode(message.SecretFileHead, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.PublicPlat != null && Object.hasOwnProperty.call(message, "PublicPlat"))
                    $root.Msg.MsgField.PublicPlat.encode(message.PublicPlat, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.TransMsg != null && Object.hasOwnProperty.call(message, "TransMsg"))
                    $root.Msg.MsgField.TransMsg.encode(message.TransMsg, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.AddressListTmp != null && Object.hasOwnProperty.call(message, "AddressListTmp"))
                    $root.Msg.MsgField.AddressListTmp.encode(message.AddressListTmp, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.RichStatusTmp != null && Object.hasOwnProperty.call(message, "RichStatusTmp"))
                    $root.Msg.MsgField.RichStatusTmp.encode(message.RichStatusTmp, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.TransCmd != null && Object.hasOwnProperty.call(message, "TransCmd"))
                    $root.Msg.MsgField.TransCmd.encode(message.TransCmd, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.AccostTmp != null && Object.hasOwnProperty.call(message, "AccostTmp"))
                    $root.Msg.MsgField.AccostTmp.encode(message.AccostTmp, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.PubGroupTmp != null && Object.hasOwnProperty.call(message, "PubGroupTmp"))
                    $root.Msg.MsgField.PubGroupTmp.encode(message.PubGroupTmp, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.Trans0x211 != null && Object.hasOwnProperty.call(message, "Trans0x211"))
                    $root.Msg.MsgField.Trans0x211.encode(message.Trans0x211, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.BusinessWPATmp != null && Object.hasOwnProperty.call(message, "BusinessWPATmp"))
                    $root.Msg.MsgField.BusinessWPATmp.encode(message.BusinessWPATmp, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.AuthTmp != null && Object.hasOwnProperty.call(message, "AuthTmp"))
                    $root.Msg.MsgField.AuthTmp.encode(message.AuthTmp, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.BsnsTmp != null && Object.hasOwnProperty.call(message, "BsnsTmp"))
                    $root.Msg.MsgField.BsnsTmp.encode(message.BsnsTmp, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.QqqueryBusinessTmp != null && Object.hasOwnProperty.call(message, "QqqueryBusinessTmp"))
                    $root.Msg.MsgField.QqqueryBusinessTmp.encode(message.QqqueryBusinessTmp, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.NearbyDatingTmp != null && Object.hasOwnProperty.call(message, "NearbyDatingTmp"))
                    $root.Msg.MsgField.NearbyDatingTmp.encode(message.NearbyDatingTmp, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.NearByAssistantTmp != null && Object.hasOwnProperty.call(message, "NearByAssistantTmp"))
                    $root.Msg.MsgField.NearByAssistantTmp.encode(message.NearByAssistantTmp, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.CommTmp != null && Object.hasOwnProperty.call(message, "CommTmp"))
                    $root.Msg.MsgField.CommTmp.encode(message.CommTmp, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RoutingHead message, length delimited. Does not implicitly {@link Msg.MsgField.RoutingHead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {Msg.MsgField.IRoutingHead} message RoutingHead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoutingHead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoutingHead message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.RoutingHead} RoutingHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoutingHead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.RoutingHead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.C2c = $root.Msg.MsgField.C2c.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.Grp = $root.Msg.MsgField.Grp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.GrpTmp = $root.Msg.MsgField.GrpTmp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.Dis = $root.Msg.MsgField.Dis.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.DisTmp = $root.Msg.MsgField.DisTmp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.WpaTmp = $root.Msg.MsgField.WpaTmp.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.SecretFileHead = $root.Msg.MsgField.SecretFileHead.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.PublicPlat = $root.Msg.MsgField.PublicPlat.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.TransMsg = $root.Msg.MsgField.TransMsg.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.AddressListTmp = $root.Msg.MsgField.AddressListTmp.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.RichStatusTmp = $root.Msg.MsgField.RichStatusTmp.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.TransCmd = $root.Msg.MsgField.TransCmd.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.AccostTmp = $root.Msg.MsgField.AccostTmp.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.PubGroupTmp = $root.Msg.MsgField.PubGroupTmp.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.Trans0x211 = $root.Msg.MsgField.Trans0x211.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.BusinessWPATmp = $root.Msg.MsgField.BusinessWPATmp.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.AuthTmp = $root.Msg.MsgField.AuthTmp.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.BsnsTmp = $root.Msg.MsgField.BsnsTmp.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.QqqueryBusinessTmp = $root.Msg.MsgField.QqqueryBusinessTmp.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.NearbyDatingTmp = $root.Msg.MsgField.NearbyDatingTmp.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.NearByAssistantTmp = $root.Msg.MsgField.NearByAssistantTmp.decode(reader, reader.uint32());
                        break;
                    case 22:
                        message.CommTmp = $root.Msg.MsgField.CommTmp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoutingHead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.RoutingHead} RoutingHead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoutingHead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoutingHead message.
             * @function verify
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoutingHead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.C2c != null && message.hasOwnProperty("C2c")) {
                    var error = $root.Msg.MsgField.C2c.verify(message.C2c);
                    if (error)
                        return "C2c." + error;
                }
                if (message.Grp != null && message.hasOwnProperty("Grp")) {
                    var error = $root.Msg.MsgField.Grp.verify(message.Grp);
                    if (error)
                        return "Grp." + error;
                }
                if (message.GrpTmp != null && message.hasOwnProperty("GrpTmp")) {
                    var error = $root.Msg.MsgField.GrpTmp.verify(message.GrpTmp);
                    if (error)
                        return "GrpTmp." + error;
                }
                if (message.Dis != null && message.hasOwnProperty("Dis")) {
                    var error = $root.Msg.MsgField.Dis.verify(message.Dis);
                    if (error)
                        return "Dis." + error;
                }
                if (message.DisTmp != null && message.hasOwnProperty("DisTmp")) {
                    var error = $root.Msg.MsgField.DisTmp.verify(message.DisTmp);
                    if (error)
                        return "DisTmp." + error;
                }
                if (message.WpaTmp != null && message.hasOwnProperty("WpaTmp")) {
                    var error = $root.Msg.MsgField.WpaTmp.verify(message.WpaTmp);
                    if (error)
                        return "WpaTmp." + error;
                }
                if (message.SecretFileHead != null && message.hasOwnProperty("SecretFileHead")) {
                    var error = $root.Msg.MsgField.SecretFileHead.verify(message.SecretFileHead);
                    if (error)
                        return "SecretFileHead." + error;
                }
                if (message.PublicPlat != null && message.hasOwnProperty("PublicPlat")) {
                    var error = $root.Msg.MsgField.PublicPlat.verify(message.PublicPlat);
                    if (error)
                        return "PublicPlat." + error;
                }
                if (message.TransMsg != null && message.hasOwnProperty("TransMsg")) {
                    var error = $root.Msg.MsgField.TransMsg.verify(message.TransMsg);
                    if (error)
                        return "TransMsg." + error;
                }
                if (message.AddressListTmp != null && message.hasOwnProperty("AddressListTmp")) {
                    var error = $root.Msg.MsgField.AddressListTmp.verify(message.AddressListTmp);
                    if (error)
                        return "AddressListTmp." + error;
                }
                if (message.RichStatusTmp != null && message.hasOwnProperty("RichStatusTmp")) {
                    var error = $root.Msg.MsgField.RichStatusTmp.verify(message.RichStatusTmp);
                    if (error)
                        return "RichStatusTmp." + error;
                }
                if (message.TransCmd != null && message.hasOwnProperty("TransCmd")) {
                    var error = $root.Msg.MsgField.TransCmd.verify(message.TransCmd);
                    if (error)
                        return "TransCmd." + error;
                }
                if (message.AccostTmp != null && message.hasOwnProperty("AccostTmp")) {
                    var error = $root.Msg.MsgField.AccostTmp.verify(message.AccostTmp);
                    if (error)
                        return "AccostTmp." + error;
                }
                if (message.PubGroupTmp != null && message.hasOwnProperty("PubGroupTmp")) {
                    var error = $root.Msg.MsgField.PubGroupTmp.verify(message.PubGroupTmp);
                    if (error)
                        return "PubGroupTmp." + error;
                }
                if (message.Trans0x211 != null && message.hasOwnProperty("Trans0x211")) {
                    var error = $root.Msg.MsgField.Trans0x211.verify(message.Trans0x211);
                    if (error)
                        return "Trans0x211." + error;
                }
                if (message.BusinessWPATmp != null && message.hasOwnProperty("BusinessWPATmp")) {
                    var error = $root.Msg.MsgField.BusinessWPATmp.verify(message.BusinessWPATmp);
                    if (error)
                        return "BusinessWPATmp." + error;
                }
                if (message.AuthTmp != null && message.hasOwnProperty("AuthTmp")) {
                    var error = $root.Msg.MsgField.AuthTmp.verify(message.AuthTmp);
                    if (error)
                        return "AuthTmp." + error;
                }
                if (message.BsnsTmp != null && message.hasOwnProperty("BsnsTmp")) {
                    var error = $root.Msg.MsgField.BsnsTmp.verify(message.BsnsTmp);
                    if (error)
                        return "BsnsTmp." + error;
                }
                if (message.QqqueryBusinessTmp != null && message.hasOwnProperty("QqqueryBusinessTmp")) {
                    var error = $root.Msg.MsgField.QqqueryBusinessTmp.verify(message.QqqueryBusinessTmp);
                    if (error)
                        return "QqqueryBusinessTmp." + error;
                }
                if (message.NearbyDatingTmp != null && message.hasOwnProperty("NearbyDatingTmp")) {
                    var error = $root.Msg.MsgField.NearbyDatingTmp.verify(message.NearbyDatingTmp);
                    if (error)
                        return "NearbyDatingTmp." + error;
                }
                if (message.NearByAssistantTmp != null && message.hasOwnProperty("NearByAssistantTmp")) {
                    var error = $root.Msg.MsgField.NearByAssistantTmp.verify(message.NearByAssistantTmp);
                    if (error)
                        return "NearByAssistantTmp." + error;
                }
                if (message.CommTmp != null && message.hasOwnProperty("CommTmp")) {
                    var error = $root.Msg.MsgField.CommTmp.verify(message.CommTmp);
                    if (error)
                        return "CommTmp." + error;
                }
                return null;
            };

            /**
             * Creates a RoutingHead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.RoutingHead} RoutingHead
             */
            RoutingHead.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.RoutingHead)
                    return object;
                var message = new $root.Msg.MsgField.RoutingHead();
                if (object.C2c != null) {
                    if (typeof object.C2c !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.C2c: object expected");
                    message.C2c = $root.Msg.MsgField.C2c.fromObject(object.C2c);
                }
                if (object.Grp != null) {
                    if (typeof object.Grp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.Grp: object expected");
                    message.Grp = $root.Msg.MsgField.Grp.fromObject(object.Grp);
                }
                if (object.GrpTmp != null) {
                    if (typeof object.GrpTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.GrpTmp: object expected");
                    message.GrpTmp = $root.Msg.MsgField.GrpTmp.fromObject(object.GrpTmp);
                }
                if (object.Dis != null) {
                    if (typeof object.Dis !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.Dis: object expected");
                    message.Dis = $root.Msg.MsgField.Dis.fromObject(object.Dis);
                }
                if (object.DisTmp != null) {
                    if (typeof object.DisTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.DisTmp: object expected");
                    message.DisTmp = $root.Msg.MsgField.DisTmp.fromObject(object.DisTmp);
                }
                if (object.WpaTmp != null) {
                    if (typeof object.WpaTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.WpaTmp: object expected");
                    message.WpaTmp = $root.Msg.MsgField.WpaTmp.fromObject(object.WpaTmp);
                }
                if (object.SecretFileHead != null) {
                    if (typeof object.SecretFileHead !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.SecretFileHead: object expected");
                    message.SecretFileHead = $root.Msg.MsgField.SecretFileHead.fromObject(object.SecretFileHead);
                }
                if (object.PublicPlat != null) {
                    if (typeof object.PublicPlat !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.PublicPlat: object expected");
                    message.PublicPlat = $root.Msg.MsgField.PublicPlat.fromObject(object.PublicPlat);
                }
                if (object.TransMsg != null) {
                    if (typeof object.TransMsg !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.TransMsg: object expected");
                    message.TransMsg = $root.Msg.MsgField.TransMsg.fromObject(object.TransMsg);
                }
                if (object.AddressListTmp != null) {
                    if (typeof object.AddressListTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.AddressListTmp: object expected");
                    message.AddressListTmp = $root.Msg.MsgField.AddressListTmp.fromObject(object.AddressListTmp);
                }
                if (object.RichStatusTmp != null) {
                    if (typeof object.RichStatusTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.RichStatusTmp: object expected");
                    message.RichStatusTmp = $root.Msg.MsgField.RichStatusTmp.fromObject(object.RichStatusTmp);
                }
                if (object.TransCmd != null) {
                    if (typeof object.TransCmd !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.TransCmd: object expected");
                    message.TransCmd = $root.Msg.MsgField.TransCmd.fromObject(object.TransCmd);
                }
                if (object.AccostTmp != null) {
                    if (typeof object.AccostTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.AccostTmp: object expected");
                    message.AccostTmp = $root.Msg.MsgField.AccostTmp.fromObject(object.AccostTmp);
                }
                if (object.PubGroupTmp != null) {
                    if (typeof object.PubGroupTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.PubGroupTmp: object expected");
                    message.PubGroupTmp = $root.Msg.MsgField.PubGroupTmp.fromObject(object.PubGroupTmp);
                }
                if (object.Trans0x211 != null) {
                    if (typeof object.Trans0x211 !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.Trans0x211: object expected");
                    message.Trans0x211 = $root.Msg.MsgField.Trans0x211.fromObject(object.Trans0x211);
                }
                if (object.BusinessWPATmp != null) {
                    if (typeof object.BusinessWPATmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.BusinessWPATmp: object expected");
                    message.BusinessWPATmp = $root.Msg.MsgField.BusinessWPATmp.fromObject(object.BusinessWPATmp);
                }
                if (object.AuthTmp != null) {
                    if (typeof object.AuthTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.AuthTmp: object expected");
                    message.AuthTmp = $root.Msg.MsgField.AuthTmp.fromObject(object.AuthTmp);
                }
                if (object.BsnsTmp != null) {
                    if (typeof object.BsnsTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.BsnsTmp: object expected");
                    message.BsnsTmp = $root.Msg.MsgField.BsnsTmp.fromObject(object.BsnsTmp);
                }
                if (object.QqqueryBusinessTmp != null) {
                    if (typeof object.QqqueryBusinessTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.QqqueryBusinessTmp: object expected");
                    message.QqqueryBusinessTmp = $root.Msg.MsgField.QqqueryBusinessTmp.fromObject(object.QqqueryBusinessTmp);
                }
                if (object.NearbyDatingTmp != null) {
                    if (typeof object.NearbyDatingTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.NearbyDatingTmp: object expected");
                    message.NearbyDatingTmp = $root.Msg.MsgField.NearbyDatingTmp.fromObject(object.NearbyDatingTmp);
                }
                if (object.NearByAssistantTmp != null) {
                    if (typeof object.NearByAssistantTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.NearByAssistantTmp: object expected");
                    message.NearByAssistantTmp = $root.Msg.MsgField.NearByAssistantTmp.fromObject(object.NearByAssistantTmp);
                }
                if (object.CommTmp != null) {
                    if (typeof object.CommTmp !== "object")
                        throw TypeError(".Msg.MsgField.RoutingHead.CommTmp: object expected");
                    message.CommTmp = $root.Msg.MsgField.CommTmp.fromObject(object.CommTmp);
                }
                return message;
            };

            /**
             * Creates a plain object from a RoutingHead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.RoutingHead
             * @static
             * @param {Msg.MsgField.RoutingHead} message RoutingHead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoutingHead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.C2c = null;
                    object.Grp = null;
                    object.GrpTmp = null;
                    object.Dis = null;
                    object.DisTmp = null;
                    object.WpaTmp = null;
                    object.SecretFileHead = null;
                    object.PublicPlat = null;
                    object.TransMsg = null;
                    object.AddressListTmp = null;
                    object.RichStatusTmp = null;
                    object.TransCmd = null;
                    object.AccostTmp = null;
                    object.PubGroupTmp = null;
                    object.Trans0x211 = null;
                    object.BusinessWPATmp = null;
                    object.AuthTmp = null;
                    object.BsnsTmp = null;
                    object.QqqueryBusinessTmp = null;
                    object.NearbyDatingTmp = null;
                    object.NearByAssistantTmp = null;
                    object.CommTmp = null;
                }
                if (message.C2c != null && message.hasOwnProperty("C2c"))
                    object.C2c = $root.Msg.MsgField.C2c.toObject(message.C2c, options);
                if (message.Grp != null && message.hasOwnProperty("Grp"))
                    object.Grp = $root.Msg.MsgField.Grp.toObject(message.Grp, options);
                if (message.GrpTmp != null && message.hasOwnProperty("GrpTmp"))
                    object.GrpTmp = $root.Msg.MsgField.GrpTmp.toObject(message.GrpTmp, options);
                if (message.Dis != null && message.hasOwnProperty("Dis"))
                    object.Dis = $root.Msg.MsgField.Dis.toObject(message.Dis, options);
                if (message.DisTmp != null && message.hasOwnProperty("DisTmp"))
                    object.DisTmp = $root.Msg.MsgField.DisTmp.toObject(message.DisTmp, options);
                if (message.WpaTmp != null && message.hasOwnProperty("WpaTmp"))
                    object.WpaTmp = $root.Msg.MsgField.WpaTmp.toObject(message.WpaTmp, options);
                if (message.SecretFileHead != null && message.hasOwnProperty("SecretFileHead"))
                    object.SecretFileHead = $root.Msg.MsgField.SecretFileHead.toObject(message.SecretFileHead, options);
                if (message.PublicPlat != null && message.hasOwnProperty("PublicPlat"))
                    object.PublicPlat = $root.Msg.MsgField.PublicPlat.toObject(message.PublicPlat, options);
                if (message.TransMsg != null && message.hasOwnProperty("TransMsg"))
                    object.TransMsg = $root.Msg.MsgField.TransMsg.toObject(message.TransMsg, options);
                if (message.AddressListTmp != null && message.hasOwnProperty("AddressListTmp"))
                    object.AddressListTmp = $root.Msg.MsgField.AddressListTmp.toObject(message.AddressListTmp, options);
                if (message.RichStatusTmp != null && message.hasOwnProperty("RichStatusTmp"))
                    object.RichStatusTmp = $root.Msg.MsgField.RichStatusTmp.toObject(message.RichStatusTmp, options);
                if (message.TransCmd != null && message.hasOwnProperty("TransCmd"))
                    object.TransCmd = $root.Msg.MsgField.TransCmd.toObject(message.TransCmd, options);
                if (message.AccostTmp != null && message.hasOwnProperty("AccostTmp"))
                    object.AccostTmp = $root.Msg.MsgField.AccostTmp.toObject(message.AccostTmp, options);
                if (message.PubGroupTmp != null && message.hasOwnProperty("PubGroupTmp"))
                    object.PubGroupTmp = $root.Msg.MsgField.PubGroupTmp.toObject(message.PubGroupTmp, options);
                if (message.Trans0x211 != null && message.hasOwnProperty("Trans0x211"))
                    object.Trans0x211 = $root.Msg.MsgField.Trans0x211.toObject(message.Trans0x211, options);
                if (message.BusinessWPATmp != null && message.hasOwnProperty("BusinessWPATmp"))
                    object.BusinessWPATmp = $root.Msg.MsgField.BusinessWPATmp.toObject(message.BusinessWPATmp, options);
                if (message.AuthTmp != null && message.hasOwnProperty("AuthTmp"))
                    object.AuthTmp = $root.Msg.MsgField.AuthTmp.toObject(message.AuthTmp, options);
                if (message.BsnsTmp != null && message.hasOwnProperty("BsnsTmp"))
                    object.BsnsTmp = $root.Msg.MsgField.BsnsTmp.toObject(message.BsnsTmp, options);
                if (message.QqqueryBusinessTmp != null && message.hasOwnProperty("QqqueryBusinessTmp"))
                    object.QqqueryBusinessTmp = $root.Msg.MsgField.QqqueryBusinessTmp.toObject(message.QqqueryBusinessTmp, options);
                if (message.NearbyDatingTmp != null && message.hasOwnProperty("NearbyDatingTmp"))
                    object.NearbyDatingTmp = $root.Msg.MsgField.NearbyDatingTmp.toObject(message.NearbyDatingTmp, options);
                if (message.NearByAssistantTmp != null && message.hasOwnProperty("NearByAssistantTmp"))
                    object.NearByAssistantTmp = $root.Msg.MsgField.NearByAssistantTmp.toObject(message.NearByAssistantTmp, options);
                if (message.CommTmp != null && message.hasOwnProperty("CommTmp"))
                    object.CommTmp = $root.Msg.MsgField.CommTmp.toObject(message.CommTmp, options);
                return object;
            };

            /**
             * Converts this RoutingHead to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.RoutingHead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoutingHead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RoutingHead;
        })();

        MsgField.MultiMsgAssist = (function() {

            /**
             * Properties of a MultiMsgAssist.
             * @memberof Msg.MsgField
             * @interface IMultiMsgAssist
             * @property {Array.<Msg.MsgField.IRoutingHead>|null} [Repeatedrouting] MultiMsgAssist Repeatedrouting
             * @property {number|null} [MsgUse] MultiMsgAssist MsgUse
             * @property {number|Long|null} [TempId] MultiMsgAssist TempId
             * @property {number|Long|null} [VedioLen] MultiMsgAssist VedioLen
             * @property {Uint8Array|null} [RedBagid] MultiMsgAssist RedBagid
             * @property {number|Long|null} [RedBagamount] MultiMsgAssist RedBagamount
             * @property {number|null} [HasReadbag] MultiMsgAssist HasReadbag
             * @property {number|null} [HasVedio] MultiMsgAssist HasVedio
             */

            /**
             * Constructs a new MultiMsgAssist.
             * @memberof Msg.MsgField
             * @classdesc Represents a MultiMsgAssist.
             * @implements IMultiMsgAssist
             * @constructor
             * @param {Msg.MsgField.IMultiMsgAssist=} [properties] Properties to set
             */
            function MultiMsgAssist(properties) {
                this.Repeatedrouting = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MultiMsgAssist Repeatedrouting.
             * @member {Array.<Msg.MsgField.IRoutingHead>} Repeatedrouting
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.Repeatedrouting = $util.emptyArray;

            /**
             * MultiMsgAssist MsgUse.
             * @member {number} MsgUse
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.MsgUse = 0;

            /**
             * MultiMsgAssist TempId.
             * @member {number|Long} TempId
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.TempId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MultiMsgAssist VedioLen.
             * @member {number|Long} VedioLen
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.VedioLen = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MultiMsgAssist RedBagid.
             * @member {Uint8Array} RedBagid
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.RedBagid = $util.newBuffer([]);

            /**
             * MultiMsgAssist RedBagamount.
             * @member {number|Long} RedBagamount
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.RedBagamount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MultiMsgAssist HasReadbag.
             * @member {number} HasReadbag
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.HasReadbag = 0;

            /**
             * MultiMsgAssist HasVedio.
             * @member {number} HasVedio
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             */
            MultiMsgAssist.prototype.HasVedio = 0;

            /**
             * Creates a new MultiMsgAssist instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {Msg.MsgField.IMultiMsgAssist=} [properties] Properties to set
             * @returns {Msg.MsgField.MultiMsgAssist} MultiMsgAssist instance
             */
            MultiMsgAssist.create = function create(properties) {
                return new MultiMsgAssist(properties);
            };

            /**
             * Encodes the specified MultiMsgAssist message. Does not implicitly {@link Msg.MsgField.MultiMsgAssist.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {Msg.MsgField.IMultiMsgAssist} message MultiMsgAssist message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiMsgAssist.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Repeatedrouting != null && message.Repeatedrouting.length)
                    for (var i = 0; i < message.Repeatedrouting.length; ++i)
                        $root.Msg.MsgField.RoutingHead.encode(message.Repeatedrouting[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.MsgUse != null && Object.hasOwnProperty.call(message, "MsgUse"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.MsgUse);
                if (message.TempId != null && Object.hasOwnProperty.call(message, "TempId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.TempId);
                if (message.VedioLen != null && Object.hasOwnProperty.call(message, "VedioLen"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.VedioLen);
                if (message.RedBagid != null && Object.hasOwnProperty.call(message, "RedBagid"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.RedBagid);
                if (message.RedBagamount != null && Object.hasOwnProperty.call(message, "RedBagamount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.RedBagamount);
                if (message.HasReadbag != null && Object.hasOwnProperty.call(message, "HasReadbag"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.HasReadbag);
                if (message.HasVedio != null && Object.hasOwnProperty.call(message, "HasVedio"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.HasVedio);
                return writer;
            };

            /**
             * Encodes the specified MultiMsgAssist message, length delimited. Does not implicitly {@link Msg.MsgField.MultiMsgAssist.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {Msg.MsgField.IMultiMsgAssist} message MultiMsgAssist message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiMsgAssist.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MultiMsgAssist message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.MultiMsgAssist} MultiMsgAssist
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiMsgAssist.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.MultiMsgAssist();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.Repeatedrouting && message.Repeatedrouting.length))
                            message.Repeatedrouting = [];
                        message.Repeatedrouting.push($root.Msg.MsgField.RoutingHead.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.MsgUse = reader.int32();
                        break;
                    case 3:
                        message.TempId = reader.int64();
                        break;
                    case 4:
                        message.VedioLen = reader.int64();
                        break;
                    case 5:
                        message.RedBagid = reader.bytes();
                        break;
                    case 6:
                        message.RedBagamount = reader.int64();
                        break;
                    case 7:
                        message.HasReadbag = reader.int32();
                        break;
                    case 8:
                        message.HasVedio = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MultiMsgAssist message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.MultiMsgAssist} MultiMsgAssist
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiMsgAssist.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MultiMsgAssist message.
             * @function verify
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MultiMsgAssist.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Repeatedrouting != null && message.hasOwnProperty("Repeatedrouting")) {
                    if (!Array.isArray(message.Repeatedrouting))
                        return "Repeatedrouting: array expected";
                    for (var i = 0; i < message.Repeatedrouting.length; ++i) {
                        var error = $root.Msg.MsgField.RoutingHead.verify(message.Repeatedrouting[i]);
                        if (error)
                            return "Repeatedrouting." + error;
                    }
                }
                if (message.MsgUse != null && message.hasOwnProperty("MsgUse"))
                    if (!$util.isInteger(message.MsgUse))
                        return "MsgUse: integer expected";
                if (message.TempId != null && message.hasOwnProperty("TempId"))
                    if (!$util.isInteger(message.TempId) && !(message.TempId && $util.isInteger(message.TempId.low) && $util.isInteger(message.TempId.high)))
                        return "TempId: integer|Long expected";
                if (message.VedioLen != null && message.hasOwnProperty("VedioLen"))
                    if (!$util.isInteger(message.VedioLen) && !(message.VedioLen && $util.isInteger(message.VedioLen.low) && $util.isInteger(message.VedioLen.high)))
                        return "VedioLen: integer|Long expected";
                if (message.RedBagid != null && message.hasOwnProperty("RedBagid"))
                    if (!(message.RedBagid && typeof message.RedBagid.length === "number" || $util.isString(message.RedBagid)))
                        return "RedBagid: buffer expected";
                if (message.RedBagamount != null && message.hasOwnProperty("RedBagamount"))
                    if (!$util.isInteger(message.RedBagamount) && !(message.RedBagamount && $util.isInteger(message.RedBagamount.low) && $util.isInteger(message.RedBagamount.high)))
                        return "RedBagamount: integer|Long expected";
                if (message.HasReadbag != null && message.hasOwnProperty("HasReadbag"))
                    if (!$util.isInteger(message.HasReadbag))
                        return "HasReadbag: integer expected";
                if (message.HasVedio != null && message.hasOwnProperty("HasVedio"))
                    if (!$util.isInteger(message.HasVedio))
                        return "HasVedio: integer expected";
                return null;
            };

            /**
             * Creates a MultiMsgAssist message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.MultiMsgAssist} MultiMsgAssist
             */
            MultiMsgAssist.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.MultiMsgAssist)
                    return object;
                var message = new $root.Msg.MsgField.MultiMsgAssist();
                if (object.Repeatedrouting) {
                    if (!Array.isArray(object.Repeatedrouting))
                        throw TypeError(".Msg.MsgField.MultiMsgAssist.Repeatedrouting: array expected");
                    message.Repeatedrouting = [];
                    for (var i = 0; i < object.Repeatedrouting.length; ++i) {
                        if (typeof object.Repeatedrouting[i] !== "object")
                            throw TypeError(".Msg.MsgField.MultiMsgAssist.Repeatedrouting: object expected");
                        message.Repeatedrouting[i] = $root.Msg.MsgField.RoutingHead.fromObject(object.Repeatedrouting[i]);
                    }
                }
                if (object.MsgUse != null)
                    message.MsgUse = object.MsgUse | 0;
                if (object.TempId != null)
                    if ($util.Long)
                        (message.TempId = $util.Long.fromValue(object.TempId)).unsigned = false;
                    else if (typeof object.TempId === "string")
                        message.TempId = parseInt(object.TempId, 10);
                    else if (typeof object.TempId === "number")
                        message.TempId = object.TempId;
                    else if (typeof object.TempId === "object")
                        message.TempId = new $util.LongBits(object.TempId.low >>> 0, object.TempId.high >>> 0).toNumber();
                if (object.VedioLen != null)
                    if ($util.Long)
                        (message.VedioLen = $util.Long.fromValue(object.VedioLen)).unsigned = false;
                    else if (typeof object.VedioLen === "string")
                        message.VedioLen = parseInt(object.VedioLen, 10);
                    else if (typeof object.VedioLen === "number")
                        message.VedioLen = object.VedioLen;
                    else if (typeof object.VedioLen === "object")
                        message.VedioLen = new $util.LongBits(object.VedioLen.low >>> 0, object.VedioLen.high >>> 0).toNumber();
                if (object.RedBagid != null)
                    if (typeof object.RedBagid === "string")
                        $util.base64.decode(object.RedBagid, message.RedBagid = $util.newBuffer($util.base64.length(object.RedBagid)), 0);
                    else if (object.RedBagid.length)
                        message.RedBagid = object.RedBagid;
                if (object.RedBagamount != null)
                    if ($util.Long)
                        (message.RedBagamount = $util.Long.fromValue(object.RedBagamount)).unsigned = false;
                    else if (typeof object.RedBagamount === "string")
                        message.RedBagamount = parseInt(object.RedBagamount, 10);
                    else if (typeof object.RedBagamount === "number")
                        message.RedBagamount = object.RedBagamount;
                    else if (typeof object.RedBagamount === "object")
                        message.RedBagamount = new $util.LongBits(object.RedBagamount.low >>> 0, object.RedBagamount.high >>> 0).toNumber();
                if (object.HasReadbag != null)
                    message.HasReadbag = object.HasReadbag | 0;
                if (object.HasVedio != null)
                    message.HasVedio = object.HasVedio | 0;
                return message;
            };

            /**
             * Creates a plain object from a MultiMsgAssist message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.MultiMsgAssist
             * @static
             * @param {Msg.MsgField.MultiMsgAssist} message MultiMsgAssist
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MultiMsgAssist.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.Repeatedrouting = [];
                if (options.defaults) {
                    object.MsgUse = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.TempId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.TempId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.VedioLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.VedioLen = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.RedBagid = "";
                    else {
                        object.RedBagid = [];
                        if (options.bytes !== Array)
                            object.RedBagid = $util.newBuffer(object.RedBagid);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.RedBagamount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.RedBagamount = options.longs === String ? "0" : 0;
                    object.HasReadbag = 0;
                    object.HasVedio = 0;
                }
                if (message.Repeatedrouting && message.Repeatedrouting.length) {
                    object.Repeatedrouting = [];
                    for (var j = 0; j < message.Repeatedrouting.length; ++j)
                        object.Repeatedrouting[j] = $root.Msg.MsgField.RoutingHead.toObject(message.Repeatedrouting[j], options);
                }
                if (message.MsgUse != null && message.hasOwnProperty("MsgUse"))
                    object.MsgUse = message.MsgUse;
                if (message.TempId != null && message.hasOwnProperty("TempId"))
                    if (typeof message.TempId === "number")
                        object.TempId = options.longs === String ? String(message.TempId) : message.TempId;
                    else
                        object.TempId = options.longs === String ? $util.Long.prototype.toString.call(message.TempId) : options.longs === Number ? new $util.LongBits(message.TempId.low >>> 0, message.TempId.high >>> 0).toNumber() : message.TempId;
                if (message.VedioLen != null && message.hasOwnProperty("VedioLen"))
                    if (typeof message.VedioLen === "number")
                        object.VedioLen = options.longs === String ? String(message.VedioLen) : message.VedioLen;
                    else
                        object.VedioLen = options.longs === String ? $util.Long.prototype.toString.call(message.VedioLen) : options.longs === Number ? new $util.LongBits(message.VedioLen.low >>> 0, message.VedioLen.high >>> 0).toNumber() : message.VedioLen;
                if (message.RedBagid != null && message.hasOwnProperty("RedBagid"))
                    object.RedBagid = options.bytes === String ? $util.base64.encode(message.RedBagid, 0, message.RedBagid.length) : options.bytes === Array ? Array.prototype.slice.call(message.RedBagid) : message.RedBagid;
                if (message.RedBagamount != null && message.hasOwnProperty("RedBagamount"))
                    if (typeof message.RedBagamount === "number")
                        object.RedBagamount = options.longs === String ? String(message.RedBagamount) : message.RedBagamount;
                    else
                        object.RedBagamount = options.longs === String ? $util.Long.prototype.toString.call(message.RedBagamount) : options.longs === Number ? new $util.LongBits(message.RedBagamount.low >>> 0, message.RedBagamount.high >>> 0).toNumber() : message.RedBagamount;
                if (message.HasReadbag != null && message.hasOwnProperty("HasReadbag"))
                    object.HasReadbag = message.HasReadbag;
                if (message.HasVedio != null && message.hasOwnProperty("HasVedio"))
                    object.HasVedio = message.HasVedio;
                return object;
            };

            /**
             * Converts this MultiMsgAssist to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.MultiMsgAssist
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MultiMsgAssist.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MultiMsgAssist;
        })();

        MsgField.PbInputNotifyInfo = (function() {

            /**
             * Properties of a PbInputNotifyInfo.
             * @memberof Msg.MsgField
             * @interface IPbInputNotifyInfo
             * @property {number|Long|null} [Touin] PbInputNotifyInfo Touin
             * @property {number|null} [Ime] PbInputNotifyInfo Ime
             * @property {number|null} [Notifyflag] PbInputNotifyInfo Notifyflag
             * @property {Uint8Array|null} [Pbreserve] PbInputNotifyInfo Pbreserve
             * @property {Uint8Array|null} [Iospushwording] PbInputNotifyInfo Iospushwording
             */

            /**
             * Constructs a new PbInputNotifyInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents a PbInputNotifyInfo.
             * @implements IPbInputNotifyInfo
             * @constructor
             * @param {Msg.MsgField.IPbInputNotifyInfo=} [properties] Properties to set
             */
            function PbInputNotifyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PbInputNotifyInfo Touin.
             * @member {number|Long} Touin
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @instance
             */
            PbInputNotifyInfo.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PbInputNotifyInfo Ime.
             * @member {number} Ime
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @instance
             */
            PbInputNotifyInfo.prototype.Ime = 0;

            /**
             * PbInputNotifyInfo Notifyflag.
             * @member {number} Notifyflag
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @instance
             */
            PbInputNotifyInfo.prototype.Notifyflag = 0;

            /**
             * PbInputNotifyInfo Pbreserve.
             * @member {Uint8Array} Pbreserve
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @instance
             */
            PbInputNotifyInfo.prototype.Pbreserve = $util.newBuffer([]);

            /**
             * PbInputNotifyInfo Iospushwording.
             * @member {Uint8Array} Iospushwording
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @instance
             */
            PbInputNotifyInfo.prototype.Iospushwording = $util.newBuffer([]);

            /**
             * Creates a new PbInputNotifyInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {Msg.MsgField.IPbInputNotifyInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.PbInputNotifyInfo} PbInputNotifyInfo instance
             */
            PbInputNotifyInfo.create = function create(properties) {
                return new PbInputNotifyInfo(properties);
            };

            /**
             * Encodes the specified PbInputNotifyInfo message. Does not implicitly {@link Msg.MsgField.PbInputNotifyInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {Msg.MsgField.IPbInputNotifyInfo} message PbInputNotifyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbInputNotifyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Touin);
                if (message.Ime != null && Object.hasOwnProperty.call(message, "Ime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Ime);
                if (message.Notifyflag != null && Object.hasOwnProperty.call(message, "Notifyflag"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Notifyflag);
                if (message.Pbreserve != null && Object.hasOwnProperty.call(message, "Pbreserve"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Pbreserve);
                if (message.Iospushwording != null && Object.hasOwnProperty.call(message, "Iospushwording"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Iospushwording);
                return writer;
            };

            /**
             * Encodes the specified PbInputNotifyInfo message, length delimited. Does not implicitly {@link Msg.MsgField.PbInputNotifyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {Msg.MsgField.IPbInputNotifyInfo} message PbInputNotifyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbInputNotifyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PbInputNotifyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.PbInputNotifyInfo} PbInputNotifyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbInputNotifyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PbInputNotifyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Touin = reader.int64();
                        break;
                    case 2:
                        message.Ime = reader.int32();
                        break;
                    case 3:
                        message.Notifyflag = reader.int32();
                        break;
                    case 4:
                        message.Pbreserve = reader.bytes();
                        break;
                    case 5:
                        message.Iospushwording = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PbInputNotifyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.PbInputNotifyInfo} PbInputNotifyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbInputNotifyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PbInputNotifyInfo message.
             * @function verify
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PbInputNotifyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                        return "Touin: integer|Long expected";
                if (message.Ime != null && message.hasOwnProperty("Ime"))
                    if (!$util.isInteger(message.Ime))
                        return "Ime: integer expected";
                if (message.Notifyflag != null && message.hasOwnProperty("Notifyflag"))
                    if (!$util.isInteger(message.Notifyflag))
                        return "Notifyflag: integer expected";
                if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                    if (!(message.Pbreserve && typeof message.Pbreserve.length === "number" || $util.isString(message.Pbreserve)))
                        return "Pbreserve: buffer expected";
                if (message.Iospushwording != null && message.hasOwnProperty("Iospushwording"))
                    if (!(message.Iospushwording && typeof message.Iospushwording.length === "number" || $util.isString(message.Iospushwording)))
                        return "Iospushwording: buffer expected";
                return null;
            };

            /**
             * Creates a PbInputNotifyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.PbInputNotifyInfo} PbInputNotifyInfo
             */
            PbInputNotifyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.PbInputNotifyInfo)
                    return object;
                var message = new $root.Msg.MsgField.PbInputNotifyInfo();
                if (object.Touin != null)
                    if ($util.Long)
                        (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                    else if (typeof object.Touin === "string")
                        message.Touin = parseInt(object.Touin, 10);
                    else if (typeof object.Touin === "number")
                        message.Touin = object.Touin;
                    else if (typeof object.Touin === "object")
                        message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                if (object.Ime != null)
                    message.Ime = object.Ime | 0;
                if (object.Notifyflag != null)
                    message.Notifyflag = object.Notifyflag | 0;
                if (object.Pbreserve != null)
                    if (typeof object.Pbreserve === "string")
                        $util.base64.decode(object.Pbreserve, message.Pbreserve = $util.newBuffer($util.base64.length(object.Pbreserve)), 0);
                    else if (object.Pbreserve.length)
                        message.Pbreserve = object.Pbreserve;
                if (object.Iospushwording != null)
                    if (typeof object.Iospushwording === "string")
                        $util.base64.decode(object.Iospushwording, message.Iospushwording = $util.newBuffer($util.base64.length(object.Iospushwording)), 0);
                    else if (object.Iospushwording.length)
                        message.Iospushwording = object.Iospushwording;
                return message;
            };

            /**
             * Creates a plain object from a PbInputNotifyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @static
             * @param {Msg.MsgField.PbInputNotifyInfo} message PbInputNotifyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PbInputNotifyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Touin = options.longs === String ? "0" : 0;
                    object.Ime = 0;
                    object.Notifyflag = 0;
                    if (options.bytes === String)
                        object.Pbreserve = "";
                    else {
                        object.Pbreserve = [];
                        if (options.bytes !== Array)
                            object.Pbreserve = $util.newBuffer(object.Pbreserve);
                    }
                    if (options.bytes === String)
                        object.Iospushwording = "";
                    else {
                        object.Iospushwording = [];
                        if (options.bytes !== Array)
                            object.Iospushwording = $util.newBuffer(object.Iospushwording);
                    }
                }
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (typeof message.Touin === "number")
                        object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                    else
                        object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                if (message.Ime != null && message.hasOwnProperty("Ime"))
                    object.Ime = message.Ime;
                if (message.Notifyflag != null && message.hasOwnProperty("Notifyflag"))
                    object.Notifyflag = message.Notifyflag;
                if (message.Pbreserve != null && message.hasOwnProperty("Pbreserve"))
                    object.Pbreserve = options.bytes === String ? $util.base64.encode(message.Pbreserve, 0, message.Pbreserve.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pbreserve) : message.Pbreserve;
                if (message.Iospushwording != null && message.hasOwnProperty("Iospushwording"))
                    object.Iospushwording = options.bytes === String ? $util.base64.encode(message.Iospushwording, 0, message.Iospushwording.length) : options.bytes === Array ? Array.prototype.slice.call(message.Iospushwording) : message.Iospushwording;
                return object;
            };

            /**
             * Converts this PbInputNotifyInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.PbInputNotifyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PbInputNotifyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PbInputNotifyInfo;
        })();

        MsgField.ResvResvInfo = (function() {

            /**
             * Properties of a ResvResvInfo.
             * @memberof Msg.MsgField
             * @interface IResvResvInfo
             * @property {number|null} [Flag] ResvResvInfo Flag
             * @property {Uint8Array|null} [Reserv1] ResvResvInfo Reserv1
             * @property {number|Long|null} [Reserv2] ResvResvInfo Reserv2
             * @property {number|Long|null} [Reserv3] ResvResvInfo Reserv3
             * @property {number|null} [Createtime] ResvResvInfo Createtime
             * @property {number|null} [Picheight] ResvResvInfo Picheight
             * @property {number|null} [Picwidth] ResvResvInfo Picwidth
             * @property {number|null} [Resvflag] ResvResvInfo Resvflag
             */

            /**
             * Constructs a new ResvResvInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents a ResvResvInfo.
             * @implements IResvResvInfo
             * @constructor
             * @param {Msg.MsgField.IResvResvInfo=} [properties] Properties to set
             */
            function ResvResvInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResvResvInfo Flag.
             * @member {number} Flag
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Flag = 0;

            /**
             * ResvResvInfo Reserv1.
             * @member {Uint8Array} Reserv1
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Reserv1 = $util.newBuffer([]);

            /**
             * ResvResvInfo Reserv2.
             * @member {number|Long} Reserv2
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Reserv2 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ResvResvInfo Reserv3.
             * @member {number|Long} Reserv3
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Reserv3 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ResvResvInfo Createtime.
             * @member {number} Createtime
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Createtime = 0;

            /**
             * ResvResvInfo Picheight.
             * @member {number} Picheight
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Picheight = 0;

            /**
             * ResvResvInfo Picwidth.
             * @member {number} Picwidth
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Picwidth = 0;

            /**
             * ResvResvInfo Resvflag.
             * @member {number} Resvflag
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             */
            ResvResvInfo.prototype.Resvflag = 0;

            /**
             * Creates a new ResvResvInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {Msg.MsgField.IResvResvInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.ResvResvInfo} ResvResvInfo instance
             */
            ResvResvInfo.create = function create(properties) {
                return new ResvResvInfo(properties);
            };

            /**
             * Encodes the specified ResvResvInfo message. Does not implicitly {@link Msg.MsgField.ResvResvInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {Msg.MsgField.IResvResvInfo} message ResvResvInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResvResvInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Flag);
                if (message.Reserv1 != null && Object.hasOwnProperty.call(message, "Reserv1"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Reserv1);
                if (message.Reserv2 != null && Object.hasOwnProperty.call(message, "Reserv2"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.Reserv2);
                if (message.Reserv3 != null && Object.hasOwnProperty.call(message, "Reserv3"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.Reserv3);
                if (message.Createtime != null && Object.hasOwnProperty.call(message, "Createtime"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Createtime);
                if (message.Picheight != null && Object.hasOwnProperty.call(message, "Picheight"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Picheight);
                if (message.Picwidth != null && Object.hasOwnProperty.call(message, "Picwidth"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Picwidth);
                if (message.Resvflag != null && Object.hasOwnProperty.call(message, "Resvflag"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Resvflag);
                return writer;
            };

            /**
             * Encodes the specified ResvResvInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ResvResvInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {Msg.MsgField.IResvResvInfo} message ResvResvInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResvResvInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ResvResvInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.ResvResvInfo} ResvResvInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResvResvInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ResvResvInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Flag = reader.int32();
                        break;
                    case 2:
                        message.Reserv1 = reader.bytes();
                        break;
                    case 3:
                        message.Reserv2 = reader.int64();
                        break;
                    case 4:
                        message.Reserv3 = reader.int64();
                        break;
                    case 5:
                        message.Createtime = reader.int32();
                        break;
                    case 6:
                        message.Picheight = reader.int32();
                        break;
                    case 7:
                        message.Picwidth = reader.int32();
                        break;
                    case 8:
                        message.Resvflag = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ResvResvInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.ResvResvInfo} ResvResvInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResvResvInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ResvResvInfo message.
             * @function verify
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResvResvInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Flag != null && message.hasOwnProperty("Flag"))
                    if (!$util.isInteger(message.Flag))
                        return "Flag: integer expected";
                if (message.Reserv1 != null && message.hasOwnProperty("Reserv1"))
                    if (!(message.Reserv1 && typeof message.Reserv1.length === "number" || $util.isString(message.Reserv1)))
                        return "Reserv1: buffer expected";
                if (message.Reserv2 != null && message.hasOwnProperty("Reserv2"))
                    if (!$util.isInteger(message.Reserv2) && !(message.Reserv2 && $util.isInteger(message.Reserv2.low) && $util.isInteger(message.Reserv2.high)))
                        return "Reserv2: integer|Long expected";
                if (message.Reserv3 != null && message.hasOwnProperty("Reserv3"))
                    if (!$util.isInteger(message.Reserv3) && !(message.Reserv3 && $util.isInteger(message.Reserv3.low) && $util.isInteger(message.Reserv3.high)))
                        return "Reserv3: integer|Long expected";
                if (message.Createtime != null && message.hasOwnProperty("Createtime"))
                    if (!$util.isInteger(message.Createtime))
                        return "Createtime: integer expected";
                if (message.Picheight != null && message.hasOwnProperty("Picheight"))
                    if (!$util.isInteger(message.Picheight))
                        return "Picheight: integer expected";
                if (message.Picwidth != null && message.hasOwnProperty("Picwidth"))
                    if (!$util.isInteger(message.Picwidth))
                        return "Picwidth: integer expected";
                if (message.Resvflag != null && message.hasOwnProperty("Resvflag"))
                    if (!$util.isInteger(message.Resvflag))
                        return "Resvflag: integer expected";
                return null;
            };

            /**
             * Creates a ResvResvInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.ResvResvInfo} ResvResvInfo
             */
            ResvResvInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.ResvResvInfo)
                    return object;
                var message = new $root.Msg.MsgField.ResvResvInfo();
                if (object.Flag != null)
                    message.Flag = object.Flag | 0;
                if (object.Reserv1 != null)
                    if (typeof object.Reserv1 === "string")
                        $util.base64.decode(object.Reserv1, message.Reserv1 = $util.newBuffer($util.base64.length(object.Reserv1)), 0);
                    else if (object.Reserv1.length)
                        message.Reserv1 = object.Reserv1;
                if (object.Reserv2 != null)
                    if ($util.Long)
                        (message.Reserv2 = $util.Long.fromValue(object.Reserv2)).unsigned = false;
                    else if (typeof object.Reserv2 === "string")
                        message.Reserv2 = parseInt(object.Reserv2, 10);
                    else if (typeof object.Reserv2 === "number")
                        message.Reserv2 = object.Reserv2;
                    else if (typeof object.Reserv2 === "object")
                        message.Reserv2 = new $util.LongBits(object.Reserv2.low >>> 0, object.Reserv2.high >>> 0).toNumber();
                if (object.Reserv3 != null)
                    if ($util.Long)
                        (message.Reserv3 = $util.Long.fromValue(object.Reserv3)).unsigned = false;
                    else if (typeof object.Reserv3 === "string")
                        message.Reserv3 = parseInt(object.Reserv3, 10);
                    else if (typeof object.Reserv3 === "number")
                        message.Reserv3 = object.Reserv3;
                    else if (typeof object.Reserv3 === "object")
                        message.Reserv3 = new $util.LongBits(object.Reserv3.low >>> 0, object.Reserv3.high >>> 0).toNumber();
                if (object.Createtime != null)
                    message.Createtime = object.Createtime | 0;
                if (object.Picheight != null)
                    message.Picheight = object.Picheight | 0;
                if (object.Picwidth != null)
                    message.Picwidth = object.Picwidth | 0;
                if (object.Resvflag != null)
                    message.Resvflag = object.Resvflag | 0;
                return message;
            };

            /**
             * Creates a plain object from a ResvResvInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.ResvResvInfo
             * @static
             * @param {Msg.MsgField.ResvResvInfo} message ResvResvInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResvResvInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Flag = 0;
                    if (options.bytes === String)
                        object.Reserv1 = "";
                    else {
                        object.Reserv1 = [];
                        if (options.bytes !== Array)
                            object.Reserv1 = $util.newBuffer(object.Reserv1);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Reserv2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Reserv2 = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Reserv3 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Reserv3 = options.longs === String ? "0" : 0;
                    object.Createtime = 0;
                    object.Picheight = 0;
                    object.Picwidth = 0;
                    object.Resvflag = 0;
                }
                if (message.Flag != null && message.hasOwnProperty("Flag"))
                    object.Flag = message.Flag;
                if (message.Reserv1 != null && message.hasOwnProperty("Reserv1"))
                    object.Reserv1 = options.bytes === String ? $util.base64.encode(message.Reserv1, 0, message.Reserv1.length) : options.bytes === Array ? Array.prototype.slice.call(message.Reserv1) : message.Reserv1;
                if (message.Reserv2 != null && message.hasOwnProperty("Reserv2"))
                    if (typeof message.Reserv2 === "number")
                        object.Reserv2 = options.longs === String ? String(message.Reserv2) : message.Reserv2;
                    else
                        object.Reserv2 = options.longs === String ? $util.Long.prototype.toString.call(message.Reserv2) : options.longs === Number ? new $util.LongBits(message.Reserv2.low >>> 0, message.Reserv2.high >>> 0).toNumber() : message.Reserv2;
                if (message.Reserv3 != null && message.hasOwnProperty("Reserv3"))
                    if (typeof message.Reserv3 === "number")
                        object.Reserv3 = options.longs === String ? String(message.Reserv3) : message.Reserv3;
                    else
                        object.Reserv3 = options.longs === String ? $util.Long.prototype.toString.call(message.Reserv3) : options.longs === Number ? new $util.LongBits(message.Reserv3.low >>> 0, message.Reserv3.high >>> 0).toNumber() : message.Reserv3;
                if (message.Createtime != null && message.hasOwnProperty("Createtime"))
                    object.Createtime = message.Createtime;
                if (message.Picheight != null && message.hasOwnProperty("Picheight"))
                    object.Picheight = message.Picheight;
                if (message.Picwidth != null && message.hasOwnProperty("Picwidth"))
                    object.Picwidth = message.Picwidth;
                if (message.Resvflag != null && message.hasOwnProperty("Resvflag"))
                    object.Resvflag = message.Resvflag;
                return object;
            };

            /**
             * Converts this ResvResvInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.ResvResvInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResvResvInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ResvResvInfo;
        })();

        MsgField.MsgCtrl = (function() {

            /**
             * Properties of a MsgCtrl.
             * @memberof Msg.MsgField
             * @interface IMsgCtrl
             * @property {number|null} [MsgFlag] MsgCtrl MsgFlag
             * @property {Msg.MsgField.IResvResvInfo|null} [ResvResvInfo] MsgCtrl ResvResvInfo
             */

            /**
             * Constructs a new MsgCtrl.
             * @memberof Msg.MsgField
             * @classdesc Represents a MsgCtrl.
             * @implements IMsgCtrl
             * @constructor
             * @param {Msg.MsgField.IMsgCtrl=} [properties] Properties to set
             */
            function MsgCtrl(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgCtrl MsgFlag.
             * @member {number} MsgFlag
             * @memberof Msg.MsgField.MsgCtrl
             * @instance
             */
            MsgCtrl.prototype.MsgFlag = 0;

            /**
             * MsgCtrl ResvResvInfo.
             * @member {Msg.MsgField.IResvResvInfo|null|undefined} ResvResvInfo
             * @memberof Msg.MsgField.MsgCtrl
             * @instance
             */
            MsgCtrl.prototype.ResvResvInfo = null;

            /**
             * Creates a new MsgCtrl instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {Msg.MsgField.IMsgCtrl=} [properties] Properties to set
             * @returns {Msg.MsgField.MsgCtrl} MsgCtrl instance
             */
            MsgCtrl.create = function create(properties) {
                return new MsgCtrl(properties);
            };

            /**
             * Encodes the specified MsgCtrl message. Does not implicitly {@link Msg.MsgField.MsgCtrl.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {Msg.MsgField.IMsgCtrl} message MsgCtrl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgCtrl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.MsgFlag != null && Object.hasOwnProperty.call(message, "MsgFlag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MsgFlag);
                if (message.ResvResvInfo != null && Object.hasOwnProperty.call(message, "ResvResvInfo"))
                    $root.Msg.MsgField.ResvResvInfo.encode(message.ResvResvInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgCtrl message, length delimited. Does not implicitly {@link Msg.MsgField.MsgCtrl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {Msg.MsgField.IMsgCtrl} message MsgCtrl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgCtrl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgCtrl message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.MsgCtrl} MsgCtrl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgCtrl.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.MsgCtrl();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.MsgFlag = reader.int32();
                        break;
                    case 2:
                        message.ResvResvInfo = $root.Msg.MsgField.ResvResvInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgCtrl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.MsgCtrl} MsgCtrl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgCtrl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgCtrl message.
             * @function verify
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgCtrl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.MsgFlag != null && message.hasOwnProperty("MsgFlag"))
                    if (!$util.isInteger(message.MsgFlag))
                        return "MsgFlag: integer expected";
                if (message.ResvResvInfo != null && message.hasOwnProperty("ResvResvInfo")) {
                    var error = $root.Msg.MsgField.ResvResvInfo.verify(message.ResvResvInfo);
                    if (error)
                        return "ResvResvInfo." + error;
                }
                return null;
            };

            /**
             * Creates a MsgCtrl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.MsgCtrl} MsgCtrl
             */
            MsgCtrl.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.MsgCtrl)
                    return object;
                var message = new $root.Msg.MsgField.MsgCtrl();
                if (object.MsgFlag != null)
                    message.MsgFlag = object.MsgFlag | 0;
                if (object.ResvResvInfo != null) {
                    if (typeof object.ResvResvInfo !== "object")
                        throw TypeError(".Msg.MsgField.MsgCtrl.ResvResvInfo: object expected");
                    message.ResvResvInfo = $root.Msg.MsgField.ResvResvInfo.fromObject(object.ResvResvInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgCtrl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.MsgCtrl
             * @static
             * @param {Msg.MsgField.MsgCtrl} message MsgCtrl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgCtrl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.MsgFlag = 0;
                    object.ResvResvInfo = null;
                }
                if (message.MsgFlag != null && message.hasOwnProperty("MsgFlag"))
                    object.MsgFlag = message.MsgFlag;
                if (message.ResvResvInfo != null && message.hasOwnProperty("ResvResvInfo"))
                    object.ResvResvInfo = $root.Msg.MsgField.ResvResvInfo.toObject(message.ResvResvInfo, options);
                return object;
            };

            /**
             * Converts this MsgCtrl to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.MsgCtrl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgCtrl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgCtrl;
        })();

        MsgField.ImReceipt = (function() {

            /**
             * Properties of an ImReceipt.
             * @memberof Msg.MsgField
             * @interface IImReceipt
             */

            /**
             * Constructs a new ImReceipt.
             * @memberof Msg.MsgField
             * @classdesc Represents an ImReceipt.
             * @implements IImReceipt
             * @constructor
             * @param {Msg.MsgField.IImReceipt=} [properties] Properties to set
             */
            function ImReceipt(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ImReceipt instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {Msg.MsgField.IImReceipt=} [properties] Properties to set
             * @returns {Msg.MsgField.ImReceipt} ImReceipt instance
             */
            ImReceipt.create = function create(properties) {
                return new ImReceipt(properties);
            };

            /**
             * Encodes the specified ImReceipt message. Does not implicitly {@link Msg.MsgField.ImReceipt.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {Msg.MsgField.IImReceipt} message ImReceipt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImReceipt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ImReceipt message, length delimited. Does not implicitly {@link Msg.MsgField.ImReceipt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {Msg.MsgField.IImReceipt} message ImReceipt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImReceipt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImReceipt message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.ImReceipt} ImReceipt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImReceipt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImReceipt();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImReceipt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.ImReceipt} ImReceipt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImReceipt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImReceipt message.
             * @function verify
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImReceipt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ImReceipt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.ImReceipt} ImReceipt
             */
            ImReceipt.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.ImReceipt)
                    return object;
                return new $root.Msg.MsgField.ImReceipt();
            };

            /**
             * Creates a plain object from an ImReceipt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.ImReceipt
             * @static
             * @param {Msg.MsgField.ImReceipt} message ImReceipt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImReceipt.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ImReceipt to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.ImReceipt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImReceipt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ImReceipt.MsgInfo = (function() {

                /**
                 * Properties of a MsgInfo.
                 * @memberof Msg.MsgField.ImReceipt
                 * @interface IMsgInfo
                 * @property {number|Long|null} [FromUin] MsgInfo FromUin
                 * @property {number|Long|null} [ToUin] MsgInfo ToUin
                 * @property {number|null} [MsgSeq] MsgInfo MsgSeq
                 * @property {number|null} [MsgRandom] MsgInfo MsgRandom
                 */

                /**
                 * Constructs a new MsgInfo.
                 * @memberof Msg.MsgField.ImReceipt
                 * @classdesc Represents a MsgInfo.
                 * @implements IMsgInfo
                 * @constructor
                 * @param {Msg.MsgField.ImReceipt.IMsgInfo=} [properties] Properties to set
                 */
                function MsgInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgInfo FromUin.
                 * @member {number|Long} FromUin
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.FromUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgInfo ToUin.
                 * @member {number|Long} ToUin
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgInfo MsgSeq.
                 * @member {number} MsgSeq
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.MsgSeq = 0;

                /**
                 * MsgInfo MsgRandom.
                 * @member {number} MsgRandom
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.MsgRandom = 0;

                /**
                 * Creates a new MsgInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IMsgInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImReceipt.MsgInfo} MsgInfo instance
                 */
                MsgInfo.create = function create(properties) {
                    return new MsgInfo(properties);
                };

                /**
                 * Encodes the specified MsgInfo message. Does not implicitly {@link Msg.MsgField.ImReceipt.MsgInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IMsgInfo} message MsgInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.FromUin != null && Object.hasOwnProperty.call(message, "FromUin"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.FromUin);
                    if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ToUin);
                    if (message.MsgSeq != null && Object.hasOwnProperty.call(message, "MsgSeq"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MsgSeq);
                    if (message.MsgRandom != null && Object.hasOwnProperty.call(message, "MsgRandom"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MsgRandom);
                    return writer;
                };

                /**
                 * Encodes the specified MsgInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImReceipt.MsgInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IMsgInfo} message MsgInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImReceipt.MsgInfo} MsgInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImReceipt.MsgInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.FromUin = reader.int64();
                            break;
                        case 2:
                            message.ToUin = reader.int64();
                            break;
                        case 3:
                            message.MsgSeq = reader.int32();
                            break;
                        case 4:
                            message.MsgRandom = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImReceipt.MsgInfo} MsgInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                        if (!$util.isInteger(message.FromUin) && !(message.FromUin && $util.isInteger(message.FromUin.low) && $util.isInteger(message.FromUin.high)))
                            return "FromUin: integer|Long expected";
                    if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                        if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                            return "ToUin: integer|Long expected";
                    if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                        if (!$util.isInteger(message.MsgSeq))
                            return "MsgSeq: integer expected";
                    if (message.MsgRandom != null && message.hasOwnProperty("MsgRandom"))
                        if (!$util.isInteger(message.MsgRandom))
                            return "MsgRandom: integer expected";
                    return null;
                };

                /**
                 * Creates a MsgInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImReceipt.MsgInfo} MsgInfo
                 */
                MsgInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImReceipt.MsgInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImReceipt.MsgInfo();
                    if (object.FromUin != null)
                        if ($util.Long)
                            (message.FromUin = $util.Long.fromValue(object.FromUin)).unsigned = false;
                        else if (typeof object.FromUin === "string")
                            message.FromUin = parseInt(object.FromUin, 10);
                        else if (typeof object.FromUin === "number")
                            message.FromUin = object.FromUin;
                        else if (typeof object.FromUin === "object")
                            message.FromUin = new $util.LongBits(object.FromUin.low >>> 0, object.FromUin.high >>> 0).toNumber();
                    if (object.ToUin != null)
                        if ($util.Long)
                            (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                        else if (typeof object.ToUin === "string")
                            message.ToUin = parseInt(object.ToUin, 10);
                        else if (typeof object.ToUin === "number")
                            message.ToUin = object.ToUin;
                        else if (typeof object.ToUin === "object")
                            message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
                    if (object.MsgSeq != null)
                        message.MsgSeq = object.MsgSeq | 0;
                    if (object.MsgRandom != null)
                        message.MsgRandom = object.MsgRandom | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MsgInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.MsgInfo} message MsgInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.FromUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.FromUin = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.ToUin = options.longs === String ? "0" : 0;
                        object.MsgSeq = 0;
                        object.MsgRandom = 0;
                    }
                    if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                        if (typeof message.FromUin === "number")
                            object.FromUin = options.longs === String ? String(message.FromUin) : message.FromUin;
                        else
                            object.FromUin = options.longs === String ? $util.Long.prototype.toString.call(message.FromUin) : options.longs === Number ? new $util.LongBits(message.FromUin.low >>> 0, message.FromUin.high >>> 0).toNumber() : message.FromUin;
                    if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                        if (typeof message.ToUin === "number")
                            object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                        else
                            object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
                    if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                        object.MsgSeq = message.MsgSeq;
                    if (message.MsgRandom != null && message.hasOwnProperty("MsgRandom"))
                        object.MsgRandom = message.MsgRandom;
                    return object;
                };

                /**
                 * Converts this MsgInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImReceipt.MsgInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MsgInfo;
            })();

            ImReceipt.ReceiptReq = (function() {

                /**
                 * Properties of a ReceiptReq.
                 * @memberof Msg.MsgField.ImReceipt
                 * @interface IReceiptReq
                 * @property {number|null} [Command] ReceiptReq Command
                 * @property {Msg.MsgField.ImReceipt.IMsgInfo|null} [MsgInfo] ReceiptReq MsgInfo
                 */

                /**
                 * Constructs a new ReceiptReq.
                 * @memberof Msg.MsgField.ImReceipt
                 * @classdesc Represents a ReceiptReq.
                 * @implements IReceiptReq
                 * @constructor
                 * @param {Msg.MsgField.ImReceipt.IReceiptReq=} [properties] Properties to set
                 */
                function ReceiptReq(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReceiptReq Command.
                 * @member {number} Command
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @instance
                 */
                ReceiptReq.prototype.Command = 0;

                /**
                 * ReceiptReq MsgInfo.
                 * @member {Msg.MsgField.ImReceipt.IMsgInfo|null|undefined} MsgInfo
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @instance
                 */
                ReceiptReq.prototype.MsgInfo = null;

                /**
                 * Creates a new ReceiptReq instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptReq=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImReceipt.ReceiptReq} ReceiptReq instance
                 */
                ReceiptReq.create = function create(properties) {
                    return new ReceiptReq(properties);
                };

                /**
                 * Encodes the specified ReceiptReq message. Does not implicitly {@link Msg.MsgField.ImReceipt.ReceiptReq.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptReq} message ReceiptReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReceiptReq.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Command != null && Object.hasOwnProperty.call(message, "Command"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Command);
                    if (message.MsgInfo != null && Object.hasOwnProperty.call(message, "MsgInfo"))
                        $root.Msg.MsgField.ImReceipt.MsgInfo.encode(message.MsgInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ReceiptReq message, length delimited. Does not implicitly {@link Msg.MsgField.ImReceipt.ReceiptReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptReq} message ReceiptReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReceiptReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReceiptReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImReceipt.ReceiptReq} ReceiptReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReceiptReq.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImReceipt.ReceiptReq();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Command = reader.int32();
                            break;
                        case 2:
                            message.MsgInfo = $root.Msg.MsgField.ImReceipt.MsgInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReceiptReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImReceipt.ReceiptReq} ReceiptReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReceiptReq.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReceiptReq message.
                 * @function verify
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReceiptReq.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Command != null && message.hasOwnProperty("Command"))
                        if (!$util.isInteger(message.Command))
                            return "Command: integer expected";
                    if (message.MsgInfo != null && message.hasOwnProperty("MsgInfo")) {
                        var error = $root.Msg.MsgField.ImReceipt.MsgInfo.verify(message.MsgInfo);
                        if (error)
                            return "MsgInfo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ReceiptReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImReceipt.ReceiptReq} ReceiptReq
                 */
                ReceiptReq.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImReceipt.ReceiptReq)
                        return object;
                    var message = new $root.Msg.MsgField.ImReceipt.ReceiptReq();
                    if (object.Command != null)
                        message.Command = object.Command | 0;
                    if (object.MsgInfo != null) {
                        if (typeof object.MsgInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImReceipt.ReceiptReq.MsgInfo: object expected");
                        message.MsgInfo = $root.Msg.MsgField.ImReceipt.MsgInfo.fromObject(object.MsgInfo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReceiptReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @static
                 * @param {Msg.MsgField.ImReceipt.ReceiptReq} message ReceiptReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReceiptReq.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Command = 0;
                        object.MsgInfo = null;
                    }
                    if (message.Command != null && message.hasOwnProperty("Command"))
                        object.Command = message.Command;
                    if (message.MsgInfo != null && message.hasOwnProperty("MsgInfo"))
                        object.MsgInfo = $root.Msg.MsgField.ImReceipt.MsgInfo.toObject(message.MsgInfo, options);
                    return object;
                };

                /**
                 * Converts this ReceiptReq to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImReceipt.ReceiptReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReceiptReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReceiptReq;
            })();

            ImReceipt.ReceiptInfo = (function() {

                /**
                 * Properties of a ReceiptInfo.
                 * @memberof Msg.MsgField.ImReceipt
                 * @interface IReceiptInfo
                 * @property {number|Long|null} [ReadTime] ReceiptInfo ReadTime
                 */

                /**
                 * Constructs a new ReceiptInfo.
                 * @memberof Msg.MsgField.ImReceipt
                 * @classdesc Represents a ReceiptInfo.
                 * @implements IReceiptInfo
                 * @constructor
                 * @param {Msg.MsgField.ImReceipt.IReceiptInfo=} [properties] Properties to set
                 */
                function ReceiptInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReceiptInfo ReadTime.
                 * @member {number|Long} ReadTime
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @instance
                 */
                ReceiptInfo.prototype.ReadTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ReceiptInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImReceipt.ReceiptInfo} ReceiptInfo instance
                 */
                ReceiptInfo.create = function create(properties) {
                    return new ReceiptInfo(properties);
                };

                /**
                 * Encodes the specified ReceiptInfo message. Does not implicitly {@link Msg.MsgField.ImReceipt.ReceiptInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptInfo} message ReceiptInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReceiptInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ReadTime != null && Object.hasOwnProperty.call(message, "ReadTime"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ReadTime);
                    return writer;
                };

                /**
                 * Encodes the specified ReceiptInfo message, length delimited. Does not implicitly {@link Msg.MsgField.ImReceipt.ReceiptInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptInfo} message ReceiptInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReceiptInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReceiptInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImReceipt.ReceiptInfo} ReceiptInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReceiptInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImReceipt.ReceiptInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ReadTime = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReceiptInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImReceipt.ReceiptInfo} ReceiptInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReceiptInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReceiptInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReceiptInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ReadTime != null && message.hasOwnProperty("ReadTime"))
                        if (!$util.isInteger(message.ReadTime) && !(message.ReadTime && $util.isInteger(message.ReadTime.low) && $util.isInteger(message.ReadTime.high)))
                            return "ReadTime: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ReceiptInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImReceipt.ReceiptInfo} ReceiptInfo
                 */
                ReceiptInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImReceipt.ReceiptInfo)
                        return object;
                    var message = new $root.Msg.MsgField.ImReceipt.ReceiptInfo();
                    if (object.ReadTime != null)
                        if ($util.Long)
                            (message.ReadTime = $util.Long.fromValue(object.ReadTime)).unsigned = false;
                        else if (typeof object.ReadTime === "string")
                            message.ReadTime = parseInt(object.ReadTime, 10);
                        else if (typeof object.ReadTime === "number")
                            message.ReadTime = object.ReadTime;
                        else if (typeof object.ReadTime === "object")
                            message.ReadTime = new $util.LongBits(object.ReadTime.low >>> 0, object.ReadTime.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a ReceiptInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @static
                 * @param {Msg.MsgField.ImReceipt.ReceiptInfo} message ReceiptInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReceiptInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.ReadTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.ReadTime = options.longs === String ? "0" : 0;
                    if (message.ReadTime != null && message.hasOwnProperty("ReadTime"))
                        if (typeof message.ReadTime === "number")
                            object.ReadTime = options.longs === String ? String(message.ReadTime) : message.ReadTime;
                        else
                            object.ReadTime = options.longs === String ? $util.Long.prototype.toString.call(message.ReadTime) : options.longs === Number ? new $util.LongBits(message.ReadTime.low >>> 0, message.ReadTime.high >>> 0).toNumber() : message.ReadTime;
                    return object;
                };

                /**
                 * Converts this ReceiptInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImReceipt.ReceiptInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReceiptInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReceiptInfo;
            })();

            ImReceipt.ReceiptResp = (function() {

                /**
                 * Properties of a ReceiptResp.
                 * @memberof Msg.MsgField.ImReceipt
                 * @interface IReceiptResp
                 * @property {number|null} [Command] ReceiptResp Command
                 * @property {Msg.MsgField.ImReceipt.IReceiptInfo|null} [ReceiptInfo] ReceiptResp ReceiptInfo
                 */

                /**
                 * Constructs a new ReceiptResp.
                 * @memberof Msg.MsgField.ImReceipt
                 * @classdesc Represents a ReceiptResp.
                 * @implements IReceiptResp
                 * @constructor
                 * @param {Msg.MsgField.ImReceipt.IReceiptResp=} [properties] Properties to set
                 */
                function ReceiptResp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReceiptResp Command.
                 * @member {number} Command
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @instance
                 */
                ReceiptResp.prototype.Command = 0;

                /**
                 * ReceiptResp ReceiptInfo.
                 * @member {Msg.MsgField.ImReceipt.IReceiptInfo|null|undefined} ReceiptInfo
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @instance
                 */
                ReceiptResp.prototype.ReceiptInfo = null;

                /**
                 * Creates a new ReceiptResp instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptResp=} [properties] Properties to set
                 * @returns {Msg.MsgField.ImReceipt.ReceiptResp} ReceiptResp instance
                 */
                ReceiptResp.create = function create(properties) {
                    return new ReceiptResp(properties);
                };

                /**
                 * Encodes the specified ReceiptResp message. Does not implicitly {@link Msg.MsgField.ImReceipt.ReceiptResp.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptResp} message ReceiptResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReceiptResp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Command != null && Object.hasOwnProperty.call(message, "Command"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Command);
                    if (message.ReceiptInfo != null && Object.hasOwnProperty.call(message, "ReceiptInfo"))
                        $root.Msg.MsgField.ImReceipt.ReceiptInfo.encode(message.ReceiptInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ReceiptResp message, length delimited. Does not implicitly {@link Msg.MsgField.ImReceipt.ReceiptResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {Msg.MsgField.ImReceipt.IReceiptResp} message ReceiptResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReceiptResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReceiptResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.ImReceipt.ReceiptResp} ReceiptResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReceiptResp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.ImReceipt.ReceiptResp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Command = reader.int32();
                            break;
                        case 2:
                            message.ReceiptInfo = $root.Msg.MsgField.ImReceipt.ReceiptInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReceiptResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.ImReceipt.ReceiptResp} ReceiptResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReceiptResp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReceiptResp message.
                 * @function verify
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReceiptResp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Command != null && message.hasOwnProperty("Command"))
                        if (!$util.isInteger(message.Command))
                            return "Command: integer expected";
                    if (message.ReceiptInfo != null && message.hasOwnProperty("ReceiptInfo")) {
                        var error = $root.Msg.MsgField.ImReceipt.ReceiptInfo.verify(message.ReceiptInfo);
                        if (error)
                            return "ReceiptInfo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ReceiptResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.ImReceipt.ReceiptResp} ReceiptResp
                 */
                ReceiptResp.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.ImReceipt.ReceiptResp)
                        return object;
                    var message = new $root.Msg.MsgField.ImReceipt.ReceiptResp();
                    if (object.Command != null)
                        message.Command = object.Command | 0;
                    if (object.ReceiptInfo != null) {
                        if (typeof object.ReceiptInfo !== "object")
                            throw TypeError(".Msg.MsgField.ImReceipt.ReceiptResp.ReceiptInfo: object expected");
                        message.ReceiptInfo = $root.Msg.MsgField.ImReceipt.ReceiptInfo.fromObject(object.ReceiptInfo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReceiptResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @static
                 * @param {Msg.MsgField.ImReceipt.ReceiptResp} message ReceiptResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReceiptResp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Command = 0;
                        object.ReceiptInfo = null;
                    }
                    if (message.Command != null && message.hasOwnProperty("Command"))
                        object.Command = message.Command;
                    if (message.ReceiptInfo != null && message.hasOwnProperty("ReceiptInfo"))
                        object.ReceiptInfo = $root.Msg.MsgField.ImReceipt.ReceiptInfo.toObject(message.ReceiptInfo, options);
                    return object;
                };

                /**
                 * Converts this ReceiptResp to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.ImReceipt.ReceiptResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReceiptResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReceiptResp;
            })();

            return ImReceipt;
        })();

        MsgField.PbC2CMsgWithDrawReq = (function() {

            /**
             * Properties of a PbC2CMsgWithDrawReq.
             * @memberof Msg.MsgField
             * @interface IPbC2CMsgWithDrawReq
             * @property {Array.<Msg.MsgField.PbC2CMsgWithDrawReq.IMsgInfo>|null} [MsgInfoList] PbC2CMsgWithDrawReq MsgInfoList
             * @property {number|null} [LongMessageFlag] PbC2CMsgWithDrawReq LongMessageFlag
             * @property {Uint8Array|null} [Reserved] PbC2CMsgWithDrawReq Reserved
             * @property {number|null} [SubCmd] PbC2CMsgWithDrawReq SubCmd
             */

            /**
             * Constructs a new PbC2CMsgWithDrawReq.
             * @memberof Msg.MsgField
             * @classdesc Represents a PbC2CMsgWithDrawReq.
             * @implements IPbC2CMsgWithDrawReq
             * @constructor
             * @param {Msg.MsgField.IPbC2CMsgWithDrawReq=} [properties] Properties to set
             */
            function PbC2CMsgWithDrawReq(properties) {
                this.MsgInfoList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PbC2CMsgWithDrawReq MsgInfoList.
             * @member {Array.<Msg.MsgField.PbC2CMsgWithDrawReq.IMsgInfo>} MsgInfoList
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @instance
             */
            PbC2CMsgWithDrawReq.prototype.MsgInfoList = $util.emptyArray;

            /**
             * PbC2CMsgWithDrawReq LongMessageFlag.
             * @member {number} LongMessageFlag
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @instance
             */
            PbC2CMsgWithDrawReq.prototype.LongMessageFlag = 0;

            /**
             * PbC2CMsgWithDrawReq Reserved.
             * @member {Uint8Array} Reserved
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @instance
             */
            PbC2CMsgWithDrawReq.prototype.Reserved = $util.newBuffer([]);

            /**
             * PbC2CMsgWithDrawReq SubCmd.
             * @member {number} SubCmd
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @instance
             */
            PbC2CMsgWithDrawReq.prototype.SubCmd = 0;

            /**
             * Creates a new PbC2CMsgWithDrawReq instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.IPbC2CMsgWithDrawReq=} [properties] Properties to set
             * @returns {Msg.MsgField.PbC2CMsgWithDrawReq} PbC2CMsgWithDrawReq instance
             */
            PbC2CMsgWithDrawReq.create = function create(properties) {
                return new PbC2CMsgWithDrawReq(properties);
            };

            /**
             * Encodes the specified PbC2CMsgWithDrawReq message. Does not implicitly {@link Msg.MsgField.PbC2CMsgWithDrawReq.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.IPbC2CMsgWithDrawReq} message PbC2CMsgWithDrawReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbC2CMsgWithDrawReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.MsgInfoList != null && message.MsgInfoList.length)
                    for (var i = 0; i < message.MsgInfoList.length; ++i)
                        $root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.encode(message.MsgInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.LongMessageFlag != null && Object.hasOwnProperty.call(message, "LongMessageFlag"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.LongMessageFlag);
                if (message.Reserved != null && Object.hasOwnProperty.call(message, "Reserved"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.Reserved);
                if (message.SubCmd != null && Object.hasOwnProperty.call(message, "SubCmd"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.SubCmd);
                return writer;
            };

            /**
             * Encodes the specified PbC2CMsgWithDrawReq message, length delimited. Does not implicitly {@link Msg.MsgField.PbC2CMsgWithDrawReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.IPbC2CMsgWithDrawReq} message PbC2CMsgWithDrawReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbC2CMsgWithDrawReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PbC2CMsgWithDrawReq message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.PbC2CMsgWithDrawReq} PbC2CMsgWithDrawReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbC2CMsgWithDrawReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PbC2CMsgWithDrawReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.MsgInfoList && message.MsgInfoList.length))
                            message.MsgInfoList = [];
                        message.MsgInfoList.push($root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.LongMessageFlag = reader.int32();
                        break;
                    case 3:
                        message.Reserved = reader.bytes();
                        break;
                    case 4:
                        message.SubCmd = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PbC2CMsgWithDrawReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.PbC2CMsgWithDrawReq} PbC2CMsgWithDrawReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbC2CMsgWithDrawReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PbC2CMsgWithDrawReq message.
             * @function verify
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PbC2CMsgWithDrawReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.MsgInfoList != null && message.hasOwnProperty("MsgInfoList")) {
                    if (!Array.isArray(message.MsgInfoList))
                        return "MsgInfoList: array expected";
                    for (var i = 0; i < message.MsgInfoList.length; ++i) {
                        var error = $root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.verify(message.MsgInfoList[i]);
                        if (error)
                            return "MsgInfoList." + error;
                    }
                }
                if (message.LongMessageFlag != null && message.hasOwnProperty("LongMessageFlag"))
                    if (!$util.isInteger(message.LongMessageFlag))
                        return "LongMessageFlag: integer expected";
                if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                    if (!(message.Reserved && typeof message.Reserved.length === "number" || $util.isString(message.Reserved)))
                        return "Reserved: buffer expected";
                if (message.SubCmd != null && message.hasOwnProperty("SubCmd"))
                    if (!$util.isInteger(message.SubCmd))
                        return "SubCmd: integer expected";
                return null;
            };

            /**
             * Creates a PbC2CMsgWithDrawReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.PbC2CMsgWithDrawReq} PbC2CMsgWithDrawReq
             */
            PbC2CMsgWithDrawReq.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.PbC2CMsgWithDrawReq)
                    return object;
                var message = new $root.Msg.MsgField.PbC2CMsgWithDrawReq();
                if (object.MsgInfoList) {
                    if (!Array.isArray(object.MsgInfoList))
                        throw TypeError(".Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfoList: array expected");
                    message.MsgInfoList = [];
                    for (var i = 0; i < object.MsgInfoList.length; ++i) {
                        if (typeof object.MsgInfoList[i] !== "object")
                            throw TypeError(".Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfoList: object expected");
                        message.MsgInfoList[i] = $root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.fromObject(object.MsgInfoList[i]);
                    }
                }
                if (object.LongMessageFlag != null)
                    message.LongMessageFlag = object.LongMessageFlag | 0;
                if (object.Reserved != null)
                    if (typeof object.Reserved === "string")
                        $util.base64.decode(object.Reserved, message.Reserved = $util.newBuffer($util.base64.length(object.Reserved)), 0);
                    else if (object.Reserved.length)
                        message.Reserved = object.Reserved;
                if (object.SubCmd != null)
                    message.SubCmd = object.SubCmd | 0;
                return message;
            };

            /**
             * Creates a plain object from a PbC2CMsgWithDrawReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.PbC2CMsgWithDrawReq} message PbC2CMsgWithDrawReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PbC2CMsgWithDrawReq.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.MsgInfoList = [];
                if (options.defaults) {
                    object.LongMessageFlag = 0;
                    if (options.bytes === String)
                        object.Reserved = "";
                    else {
                        object.Reserved = [];
                        if (options.bytes !== Array)
                            object.Reserved = $util.newBuffer(object.Reserved);
                    }
                    object.SubCmd = 0;
                }
                if (message.MsgInfoList && message.MsgInfoList.length) {
                    object.MsgInfoList = [];
                    for (var j = 0; j < message.MsgInfoList.length; ++j)
                        object.MsgInfoList[j] = $root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.toObject(message.MsgInfoList[j], options);
                }
                if (message.LongMessageFlag != null && message.hasOwnProperty("LongMessageFlag"))
                    object.LongMessageFlag = message.LongMessageFlag;
                if (message.Reserved != null && message.hasOwnProperty("Reserved"))
                    object.Reserved = options.bytes === String ? $util.base64.encode(message.Reserved, 0, message.Reserved.length) : options.bytes === Array ? Array.prototype.slice.call(message.Reserved) : message.Reserved;
                if (message.SubCmd != null && message.hasOwnProperty("SubCmd"))
                    object.SubCmd = message.SubCmd;
                return object;
            };

            /**
             * Converts this PbC2CMsgWithDrawReq to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PbC2CMsgWithDrawReq.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PbC2CMsgWithDrawReq.MsgInfo = (function() {

                /**
                 * Properties of a MsgInfo.
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
                 * @interface IMsgInfo
                 * @property {number|Long|null} [Fromuin] MsgInfo Fromuin
                 * @property {number|Long|null} [Touin] MsgInfo Touin
                 * @property {number|null} [Msgseq] MsgInfo Msgseq
                 * @property {number|Long|null} [Msguid] MsgInfo Msguid
                 * @property {number|Long|null} [Msgtime] MsgInfo Msgtime
                 * @property {number|null} [Msgrandom] MsgInfo Msgrandom
                 * @property {number|null} [Pkgnum] MsgInfo Pkgnum
                 * @property {number|null} [Pkgindex] MsgInfo Pkgindex
                 * @property {number|null} [Divseq] MsgInfo Divseq
                 * @property {number|null} [Msgtype] MsgInfo Msgtype
                 * @property {Msg.MsgField.IRoutingHead|null} [Routinghead] MsgInfo Routinghead
                 */

                /**
                 * Constructs a new MsgInfo.
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq
                 * @classdesc Represents a MsgInfo.
                 * @implements IMsgInfo
                 * @constructor
                 * @param {Msg.MsgField.PbC2CMsgWithDrawReq.IMsgInfo=} [properties] Properties to set
                 */
                function MsgInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MsgInfo Fromuin.
                 * @member {number|Long} Fromuin
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Fromuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgInfo Touin.
                 * @member {number|Long} Touin
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgInfo Msgseq.
                 * @member {number} Msgseq
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Msgseq = 0;

                /**
                 * MsgInfo Msguid.
                 * @member {number|Long} Msguid
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Msguid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgInfo Msgtime.
                 * @member {number|Long} Msgtime
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Msgtime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MsgInfo Msgrandom.
                 * @member {number} Msgrandom
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Msgrandom = 0;

                /**
                 * MsgInfo Pkgnum.
                 * @member {number} Pkgnum
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Pkgnum = 0;

                /**
                 * MsgInfo Pkgindex.
                 * @member {number} Pkgindex
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Pkgindex = 0;

                /**
                 * MsgInfo Divseq.
                 * @member {number} Divseq
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Divseq = 0;

                /**
                 * MsgInfo Msgtype.
                 * @member {number} Msgtype
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Msgtype = 0;

                /**
                 * MsgInfo Routinghead.
                 * @member {Msg.MsgField.IRoutingHead|null|undefined} Routinghead
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 */
                MsgInfo.prototype.Routinghead = null;

                /**
                 * Creates a new MsgInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {Msg.MsgField.PbC2CMsgWithDrawReq.IMsgInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo} MsgInfo instance
                 */
                MsgInfo.create = function create(properties) {
                    return new MsgInfo(properties);
                };

                /**
                 * Encodes the specified MsgInfo message. Does not implicitly {@link Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {Msg.MsgField.PbC2CMsgWithDrawReq.IMsgInfo} message MsgInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Fromuin != null && Object.hasOwnProperty.call(message, "Fromuin"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Fromuin);
                    if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Touin);
                    if (message.Msgseq != null && Object.hasOwnProperty.call(message, "Msgseq"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Msgseq);
                    if (message.Msguid != null && Object.hasOwnProperty.call(message, "Msguid"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.Msguid);
                    if (message.Msgtime != null && Object.hasOwnProperty.call(message, "Msgtime"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.Msgtime);
                    if (message.Msgrandom != null && Object.hasOwnProperty.call(message, "Msgrandom"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Msgrandom);
                    if (message.Pkgnum != null && Object.hasOwnProperty.call(message, "Pkgnum"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Pkgnum);
                    if (message.Pkgindex != null && Object.hasOwnProperty.call(message, "Pkgindex"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Pkgindex);
                    if (message.Divseq != null && Object.hasOwnProperty.call(message, "Divseq"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Divseq);
                    if (message.Msgtype != null && Object.hasOwnProperty.call(message, "Msgtype"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Msgtype);
                    if (message.Routinghead != null && Object.hasOwnProperty.call(message, "Routinghead"))
                        $root.Msg.MsgField.RoutingHead.encode(message.Routinghead, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MsgInfo message, length delimited. Does not implicitly {@link Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {Msg.MsgField.PbC2CMsgWithDrawReq.IMsgInfo} message MsgInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MsgInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MsgInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo} MsgInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Fromuin = reader.int64();
                            break;
                        case 2:
                            message.Touin = reader.int64();
                            break;
                        case 3:
                            message.Msgseq = reader.int32();
                            break;
                        case 4:
                            message.Msguid = reader.int64();
                            break;
                        case 5:
                            message.Msgtime = reader.int64();
                            break;
                        case 6:
                            message.Msgrandom = reader.int32();
                            break;
                        case 7:
                            message.Pkgnum = reader.int32();
                            break;
                        case 8:
                            message.Pkgindex = reader.int32();
                            break;
                        case 9:
                            message.Divseq = reader.int32();
                            break;
                        case 10:
                            message.Msgtype = reader.int32();
                            break;
                        case 20:
                            message.Routinghead = $root.Msg.MsgField.RoutingHead.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MsgInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo} MsgInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MsgInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MsgInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MsgInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.Fromuin != null && message.hasOwnProperty("Fromuin"))
                        if (!$util.isInteger(message.Fromuin) && !(message.Fromuin && $util.isInteger(message.Fromuin.low) && $util.isInteger(message.Fromuin.high)))
                            return "Fromuin: integer|Long expected";
                    if (message.Touin != null && message.hasOwnProperty("Touin"))
                        if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                            return "Touin: integer|Long expected";
                    if (message.Msgseq != null && message.hasOwnProperty("Msgseq"))
                        if (!$util.isInteger(message.Msgseq))
                            return "Msgseq: integer expected";
                    if (message.Msguid != null && message.hasOwnProperty("Msguid"))
                        if (!$util.isInteger(message.Msguid) && !(message.Msguid && $util.isInteger(message.Msguid.low) && $util.isInteger(message.Msguid.high)))
                            return "Msguid: integer|Long expected";
                    if (message.Msgtime != null && message.hasOwnProperty("Msgtime"))
                        if (!$util.isInteger(message.Msgtime) && !(message.Msgtime && $util.isInteger(message.Msgtime.low) && $util.isInteger(message.Msgtime.high)))
                            return "Msgtime: integer|Long expected";
                    if (message.Msgrandom != null && message.hasOwnProperty("Msgrandom"))
                        if (!$util.isInteger(message.Msgrandom))
                            return "Msgrandom: integer expected";
                    if (message.Pkgnum != null && message.hasOwnProperty("Pkgnum"))
                        if (!$util.isInteger(message.Pkgnum))
                            return "Pkgnum: integer expected";
                    if (message.Pkgindex != null && message.hasOwnProperty("Pkgindex"))
                        if (!$util.isInteger(message.Pkgindex))
                            return "Pkgindex: integer expected";
                    if (message.Divseq != null && message.hasOwnProperty("Divseq"))
                        if (!$util.isInteger(message.Divseq))
                            return "Divseq: integer expected";
                    if (message.Msgtype != null && message.hasOwnProperty("Msgtype"))
                        if (!$util.isInteger(message.Msgtype))
                            return "Msgtype: integer expected";
                    if (message.Routinghead != null && message.hasOwnProperty("Routinghead")) {
                        var error = $root.Msg.MsgField.RoutingHead.verify(message.Routinghead);
                        if (error)
                            return "Routinghead." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MsgInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo} MsgInfo
                 */
                MsgInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo)
                        return object;
                    var message = new $root.Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo();
                    if (object.Fromuin != null)
                        if ($util.Long)
                            (message.Fromuin = $util.Long.fromValue(object.Fromuin)).unsigned = false;
                        else if (typeof object.Fromuin === "string")
                            message.Fromuin = parseInt(object.Fromuin, 10);
                        else if (typeof object.Fromuin === "number")
                            message.Fromuin = object.Fromuin;
                        else if (typeof object.Fromuin === "object")
                            message.Fromuin = new $util.LongBits(object.Fromuin.low >>> 0, object.Fromuin.high >>> 0).toNumber();
                    if (object.Touin != null)
                        if ($util.Long)
                            (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                        else if (typeof object.Touin === "string")
                            message.Touin = parseInt(object.Touin, 10);
                        else if (typeof object.Touin === "number")
                            message.Touin = object.Touin;
                        else if (typeof object.Touin === "object")
                            message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                    if (object.Msgseq != null)
                        message.Msgseq = object.Msgseq | 0;
                    if (object.Msguid != null)
                        if ($util.Long)
                            (message.Msguid = $util.Long.fromValue(object.Msguid)).unsigned = false;
                        else if (typeof object.Msguid === "string")
                            message.Msguid = parseInt(object.Msguid, 10);
                        else if (typeof object.Msguid === "number")
                            message.Msguid = object.Msguid;
                        else if (typeof object.Msguid === "object")
                            message.Msguid = new $util.LongBits(object.Msguid.low >>> 0, object.Msguid.high >>> 0).toNumber();
                    if (object.Msgtime != null)
                        if ($util.Long)
                            (message.Msgtime = $util.Long.fromValue(object.Msgtime)).unsigned = false;
                        else if (typeof object.Msgtime === "string")
                            message.Msgtime = parseInt(object.Msgtime, 10);
                        else if (typeof object.Msgtime === "number")
                            message.Msgtime = object.Msgtime;
                        else if (typeof object.Msgtime === "object")
                            message.Msgtime = new $util.LongBits(object.Msgtime.low >>> 0, object.Msgtime.high >>> 0).toNumber();
                    if (object.Msgrandom != null)
                        message.Msgrandom = object.Msgrandom | 0;
                    if (object.Pkgnum != null)
                        message.Pkgnum = object.Pkgnum | 0;
                    if (object.Pkgindex != null)
                        message.Pkgindex = object.Pkgindex | 0;
                    if (object.Divseq != null)
                        message.Divseq = object.Divseq | 0;
                    if (object.Msgtype != null)
                        message.Msgtype = object.Msgtype | 0;
                    if (object.Routinghead != null) {
                        if (typeof object.Routinghead !== "object")
                            throw TypeError(".Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo.Routinghead: object expected");
                        message.Routinghead = $root.Msg.MsgField.RoutingHead.fromObject(object.Routinghead);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MsgInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @static
                 * @param {Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo} message MsgInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MsgInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Fromuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Fromuin = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Touin = options.longs === String ? "0" : 0;
                        object.Msgseq = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Msguid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Msguid = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.Msgtime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.Msgtime = options.longs === String ? "0" : 0;
                        object.Msgrandom = 0;
                        object.Pkgnum = 0;
                        object.Pkgindex = 0;
                        object.Divseq = 0;
                        object.Msgtype = 0;
                        object.Routinghead = null;
                    }
                    if (message.Fromuin != null && message.hasOwnProperty("Fromuin"))
                        if (typeof message.Fromuin === "number")
                            object.Fromuin = options.longs === String ? String(message.Fromuin) : message.Fromuin;
                        else
                            object.Fromuin = options.longs === String ? $util.Long.prototype.toString.call(message.Fromuin) : options.longs === Number ? new $util.LongBits(message.Fromuin.low >>> 0, message.Fromuin.high >>> 0).toNumber() : message.Fromuin;
                    if (message.Touin != null && message.hasOwnProperty("Touin"))
                        if (typeof message.Touin === "number")
                            object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                        else
                            object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                    if (message.Msgseq != null && message.hasOwnProperty("Msgseq"))
                        object.Msgseq = message.Msgseq;
                    if (message.Msguid != null && message.hasOwnProperty("Msguid"))
                        if (typeof message.Msguid === "number")
                            object.Msguid = options.longs === String ? String(message.Msguid) : message.Msguid;
                        else
                            object.Msguid = options.longs === String ? $util.Long.prototype.toString.call(message.Msguid) : options.longs === Number ? new $util.LongBits(message.Msguid.low >>> 0, message.Msguid.high >>> 0).toNumber() : message.Msguid;
                    if (message.Msgtime != null && message.hasOwnProperty("Msgtime"))
                        if (typeof message.Msgtime === "number")
                            object.Msgtime = options.longs === String ? String(message.Msgtime) : message.Msgtime;
                        else
                            object.Msgtime = options.longs === String ? $util.Long.prototype.toString.call(message.Msgtime) : options.longs === Number ? new $util.LongBits(message.Msgtime.low >>> 0, message.Msgtime.high >>> 0).toNumber() : message.Msgtime;
                    if (message.Msgrandom != null && message.hasOwnProperty("Msgrandom"))
                        object.Msgrandom = message.Msgrandom;
                    if (message.Pkgnum != null && message.hasOwnProperty("Pkgnum"))
                        object.Pkgnum = message.Pkgnum;
                    if (message.Pkgindex != null && message.hasOwnProperty("Pkgindex"))
                        object.Pkgindex = message.Pkgindex;
                    if (message.Divseq != null && message.hasOwnProperty("Divseq"))
                        object.Divseq = message.Divseq;
                    if (message.Msgtype != null && message.hasOwnProperty("Msgtype"))
                        object.Msgtype = message.Msgtype;
                    if (message.Routinghead != null && message.hasOwnProperty("Routinghead"))
                        object.Routinghead = $root.Msg.MsgField.RoutingHead.toObject(message.Routinghead, options);
                    return object;
                };

                /**
                 * Converts this MsgInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.PbC2CMsgWithDrawReq.MsgInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MsgInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MsgInfo;
            })();

            return PbC2CMsgWithDrawReq;
        })();

        MsgField.MsgSendInfo = (function() {

            /**
             * Properties of a MsgSendInfo.
             * @memberof Msg.MsgField
             * @interface IMsgSendInfo
             * @property {number|null} [Receiver] MsgSendInfo Receiver
             */

            /**
             * Constructs a new MsgSendInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents a MsgSendInfo.
             * @implements IMsgSendInfo
             * @constructor
             * @param {Msg.MsgField.IMsgSendInfo=} [properties] Properties to set
             */
            function MsgSendInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgSendInfo Receiver.
             * @member {number} Receiver
             * @memberof Msg.MsgField.MsgSendInfo
             * @instance
             */
            MsgSendInfo.prototype.Receiver = 0;

            /**
             * Creates a new MsgSendInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {Msg.MsgField.IMsgSendInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.MsgSendInfo} MsgSendInfo instance
             */
            MsgSendInfo.create = function create(properties) {
                return new MsgSendInfo(properties);
            };

            /**
             * Encodes the specified MsgSendInfo message. Does not implicitly {@link Msg.MsgField.MsgSendInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {Msg.MsgField.IMsgSendInfo} message MsgSendInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Receiver != null && Object.hasOwnProperty.call(message, "Receiver"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Receiver);
                return writer;
            };

            /**
             * Encodes the specified MsgSendInfo message, length delimited. Does not implicitly {@link Msg.MsgField.MsgSendInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {Msg.MsgField.IMsgSendInfo} message MsgSendInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSendInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.MsgSendInfo} MsgSendInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.MsgSendInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Receiver = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSendInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.MsgSendInfo} MsgSendInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSendInfo message.
             * @function verify
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSendInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Receiver != null && message.hasOwnProperty("Receiver"))
                    if (!$util.isInteger(message.Receiver))
                        return "Receiver: integer expected";
                return null;
            };

            /**
             * Creates a MsgSendInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.MsgSendInfo} MsgSendInfo
             */
            MsgSendInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.MsgSendInfo)
                    return object;
                var message = new $root.Msg.MsgField.MsgSendInfo();
                if (object.Receiver != null)
                    message.Receiver = object.Receiver | 0;
                return message;
            };

            /**
             * Creates a plain object from a MsgSendInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.MsgSendInfo
             * @static
             * @param {Msg.MsgField.MsgSendInfo} message MsgSendInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSendInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.Receiver = 0;
                if (message.Receiver != null && message.hasOwnProperty("Receiver"))
                    object.Receiver = message.Receiver;
                return object;
            };

            /**
             * Converts this MsgSendInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.MsgSendInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSendInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSendInfo;
        })();

        MsgField.TransSvrInfo = (function() {

            /**
             * Properties of a TransSvrInfo.
             * @memberof Msg.MsgField
             * @interface ITransSvrInfo
             * @property {number|null} [SubType] TransSvrInfo SubType
             * @property {number|null} [Int32RetCode] TransSvrInfo Int32RetCode
             * @property {Uint8Array|null} [ErrMsg] TransSvrInfo ErrMsg
             * @property {Uint8Array|null} [TransInfo] TransSvrInfo TransInfo
             */

            /**
             * Constructs a new TransSvrInfo.
             * @memberof Msg.MsgField
             * @classdesc Represents a TransSvrInfo.
             * @implements ITransSvrInfo
             * @constructor
             * @param {Msg.MsgField.ITransSvrInfo=} [properties] Properties to set
             */
            function TransSvrInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransSvrInfo SubType.
             * @member {number} SubType
             * @memberof Msg.MsgField.TransSvrInfo
             * @instance
             */
            TransSvrInfo.prototype.SubType = 0;

            /**
             * TransSvrInfo Int32RetCode.
             * @member {number} Int32RetCode
             * @memberof Msg.MsgField.TransSvrInfo
             * @instance
             */
            TransSvrInfo.prototype.Int32RetCode = 0;

            /**
             * TransSvrInfo ErrMsg.
             * @member {Uint8Array} ErrMsg
             * @memberof Msg.MsgField.TransSvrInfo
             * @instance
             */
            TransSvrInfo.prototype.ErrMsg = $util.newBuffer([]);

            /**
             * TransSvrInfo TransInfo.
             * @member {Uint8Array} TransInfo
             * @memberof Msg.MsgField.TransSvrInfo
             * @instance
             */
            TransSvrInfo.prototype.TransInfo = $util.newBuffer([]);

            /**
             * Creates a new TransSvrInfo instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {Msg.MsgField.ITransSvrInfo=} [properties] Properties to set
             * @returns {Msg.MsgField.TransSvrInfo} TransSvrInfo instance
             */
            TransSvrInfo.create = function create(properties) {
                return new TransSvrInfo(properties);
            };

            /**
             * Encodes the specified TransSvrInfo message. Does not implicitly {@link Msg.MsgField.TransSvrInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {Msg.MsgField.ITransSvrInfo} message TransSvrInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransSvrInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.SubType != null && Object.hasOwnProperty.call(message, "SubType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.SubType);
                if (message.Int32RetCode != null && Object.hasOwnProperty.call(message, "Int32RetCode"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Int32RetCode);
                if (message.ErrMsg != null && Object.hasOwnProperty.call(message, "ErrMsg"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ErrMsg);
                if (message.TransInfo != null && Object.hasOwnProperty.call(message, "TransInfo"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.TransInfo);
                return writer;
            };

            /**
             * Encodes the specified TransSvrInfo message, length delimited. Does not implicitly {@link Msg.MsgField.TransSvrInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {Msg.MsgField.ITransSvrInfo} message TransSvrInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransSvrInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransSvrInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.TransSvrInfo} TransSvrInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransSvrInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.TransSvrInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.SubType = reader.int32();
                        break;
                    case 2:
                        message.Int32RetCode = reader.int32();
                        break;
                    case 3:
                        message.ErrMsg = reader.bytes();
                        break;
                    case 4:
                        message.TransInfo = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransSvrInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.TransSvrInfo} TransSvrInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransSvrInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransSvrInfo message.
             * @function verify
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransSvrInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.SubType != null && message.hasOwnProperty("SubType"))
                    if (!$util.isInteger(message.SubType))
                        return "SubType: integer expected";
                if (message.Int32RetCode != null && message.hasOwnProperty("Int32RetCode"))
                    if (!$util.isInteger(message.Int32RetCode))
                        return "Int32RetCode: integer expected";
                if (message.ErrMsg != null && message.hasOwnProperty("ErrMsg"))
                    if (!(message.ErrMsg && typeof message.ErrMsg.length === "number" || $util.isString(message.ErrMsg)))
                        return "ErrMsg: buffer expected";
                if (message.TransInfo != null && message.hasOwnProperty("TransInfo"))
                    if (!(message.TransInfo && typeof message.TransInfo.length === "number" || $util.isString(message.TransInfo)))
                        return "TransInfo: buffer expected";
                return null;
            };

            /**
             * Creates a TransSvrInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.TransSvrInfo} TransSvrInfo
             */
            TransSvrInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.TransSvrInfo)
                    return object;
                var message = new $root.Msg.MsgField.TransSvrInfo();
                if (object.SubType != null)
                    message.SubType = object.SubType | 0;
                if (object.Int32RetCode != null)
                    message.Int32RetCode = object.Int32RetCode | 0;
                if (object.ErrMsg != null)
                    if (typeof object.ErrMsg === "string")
                        $util.base64.decode(object.ErrMsg, message.ErrMsg = $util.newBuffer($util.base64.length(object.ErrMsg)), 0);
                    else if (object.ErrMsg.length)
                        message.ErrMsg = object.ErrMsg;
                if (object.TransInfo != null)
                    if (typeof object.TransInfo === "string")
                        $util.base64.decode(object.TransInfo, message.TransInfo = $util.newBuffer($util.base64.length(object.TransInfo)), 0);
                    else if (object.TransInfo.length)
                        message.TransInfo = object.TransInfo;
                return message;
            };

            /**
             * Creates a plain object from a TransSvrInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.TransSvrInfo
             * @static
             * @param {Msg.MsgField.TransSvrInfo} message TransSvrInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransSvrInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.SubType = 0;
                    object.Int32RetCode = 0;
                    if (options.bytes === String)
                        object.ErrMsg = "";
                    else {
                        object.ErrMsg = [];
                        if (options.bytes !== Array)
                            object.ErrMsg = $util.newBuffer(object.ErrMsg);
                    }
                    if (options.bytes === String)
                        object.TransInfo = "";
                    else {
                        object.TransInfo = [];
                        if (options.bytes !== Array)
                            object.TransInfo = $util.newBuffer(object.TransInfo);
                    }
                }
                if (message.SubType != null && message.hasOwnProperty("SubType"))
                    object.SubType = message.SubType;
                if (message.Int32RetCode != null && message.hasOwnProperty("Int32RetCode"))
                    object.Int32RetCode = message.Int32RetCode;
                if (message.ErrMsg != null && message.hasOwnProperty("ErrMsg"))
                    object.ErrMsg = options.bytes === String ? $util.base64.encode(message.ErrMsg, 0, message.ErrMsg.length) : options.bytes === Array ? Array.prototype.slice.call(message.ErrMsg) : message.ErrMsg;
                if (message.TransInfo != null && message.hasOwnProperty("TransInfo"))
                    object.TransInfo = options.bytes === String ? $util.base64.encode(message.TransInfo, 0, message.TransInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.TransInfo) : message.TransInfo;
                return object;
            };

            /**
             * Converts this TransSvrInfo to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.TransSvrInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransSvrInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransSvrInfo;
        })();

        MsgField.PbGroupMsgWithDrawReq = (function() {

            /**
             * Properties of a PbGroupMsgWithDrawReq.
             * @memberof Msg.MsgField
             * @interface IPbGroupMsgWithDrawReq
             * @property {number|null} [Subcmd] PbGroupMsgWithDrawReq Subcmd
             * @property {number|null} [Grouptype] PbGroupMsgWithDrawReq Grouptype
             * @property {number|Long|null} [Groupcode] PbGroupMsgWithDrawReq Groupcode
             * @property {Array.<Msg.MsgField.PbGroupMsgWithDrawReq.IMessageInfo>|null} [Msglist] PbGroupMsgWithDrawReq Msglist
             * @property {Uint8Array|null} [Userdef] PbGroupMsgWithDrawReq Userdef
             */

            /**
             * Constructs a new PbGroupMsgWithDrawReq.
             * @memberof Msg.MsgField
             * @classdesc Represents a PbGroupMsgWithDrawReq.
             * @implements IPbGroupMsgWithDrawReq
             * @constructor
             * @param {Msg.MsgField.IPbGroupMsgWithDrawReq=} [properties] Properties to set
             */
            function PbGroupMsgWithDrawReq(properties) {
                this.Msglist = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PbGroupMsgWithDrawReq Subcmd.
             * @member {number} Subcmd
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @instance
             */
            PbGroupMsgWithDrawReq.prototype.Subcmd = 0;

            /**
             * PbGroupMsgWithDrawReq Grouptype.
             * @member {number} Grouptype
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @instance
             */
            PbGroupMsgWithDrawReq.prototype.Grouptype = 0;

            /**
             * PbGroupMsgWithDrawReq Groupcode.
             * @member {number|Long} Groupcode
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @instance
             */
            PbGroupMsgWithDrawReq.prototype.Groupcode = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PbGroupMsgWithDrawReq Msglist.
             * @member {Array.<Msg.MsgField.PbGroupMsgWithDrawReq.IMessageInfo>} Msglist
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @instance
             */
            PbGroupMsgWithDrawReq.prototype.Msglist = $util.emptyArray;

            /**
             * PbGroupMsgWithDrawReq Userdef.
             * @member {Uint8Array} Userdef
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @instance
             */
            PbGroupMsgWithDrawReq.prototype.Userdef = $util.newBuffer([]);

            /**
             * Creates a new PbGroupMsgWithDrawReq instance using the specified properties.
             * @function create
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.IPbGroupMsgWithDrawReq=} [properties] Properties to set
             * @returns {Msg.MsgField.PbGroupMsgWithDrawReq} PbGroupMsgWithDrawReq instance
             */
            PbGroupMsgWithDrawReq.create = function create(properties) {
                return new PbGroupMsgWithDrawReq(properties);
            };

            /**
             * Encodes the specified PbGroupMsgWithDrawReq message. Does not implicitly {@link Msg.MsgField.PbGroupMsgWithDrawReq.verify|verify} messages.
             * @function encode
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.IPbGroupMsgWithDrawReq} message PbGroupMsgWithDrawReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbGroupMsgWithDrawReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Subcmd != null && Object.hasOwnProperty.call(message, "Subcmd"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Subcmd);
                if (message.Grouptype != null && Object.hasOwnProperty.call(message, "Grouptype"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Grouptype);
                if (message.Groupcode != null && Object.hasOwnProperty.call(message, "Groupcode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.Groupcode);
                if (message.Msglist != null && message.Msglist.length)
                    for (var i = 0; i < message.Msglist.length; ++i)
                        $root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo.encode(message.Msglist[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.Userdef != null && Object.hasOwnProperty.call(message, "Userdef"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Userdef);
                return writer;
            };

            /**
             * Encodes the specified PbGroupMsgWithDrawReq message, length delimited. Does not implicitly {@link Msg.MsgField.PbGroupMsgWithDrawReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.IPbGroupMsgWithDrawReq} message PbGroupMsgWithDrawReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbGroupMsgWithDrawReq.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PbGroupMsgWithDrawReq message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.MsgField.PbGroupMsgWithDrawReq} PbGroupMsgWithDrawReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbGroupMsgWithDrawReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PbGroupMsgWithDrawReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Subcmd = reader.int32();
                        break;
                    case 2:
                        message.Grouptype = reader.int32();
                        break;
                    case 3:
                        message.Groupcode = reader.int64();
                        break;
                    case 4:
                        if (!(message.Msglist && message.Msglist.length))
                            message.Msglist = [];
                        message.Msglist.push($root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.Userdef = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PbGroupMsgWithDrawReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.MsgField.PbGroupMsgWithDrawReq} PbGroupMsgWithDrawReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbGroupMsgWithDrawReq.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PbGroupMsgWithDrawReq message.
             * @function verify
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PbGroupMsgWithDrawReq.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Subcmd != null && message.hasOwnProperty("Subcmd"))
                    if (!$util.isInteger(message.Subcmd))
                        return "Subcmd: integer expected";
                if (message.Grouptype != null && message.hasOwnProperty("Grouptype"))
                    if (!$util.isInteger(message.Grouptype))
                        return "Grouptype: integer expected";
                if (message.Groupcode != null && message.hasOwnProperty("Groupcode"))
                    if (!$util.isInteger(message.Groupcode) && !(message.Groupcode && $util.isInteger(message.Groupcode.low) && $util.isInteger(message.Groupcode.high)))
                        return "Groupcode: integer|Long expected";
                if (message.Msglist != null && message.hasOwnProperty("Msglist")) {
                    if (!Array.isArray(message.Msglist))
                        return "Msglist: array expected";
                    for (var i = 0; i < message.Msglist.length; ++i) {
                        var error = $root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo.verify(message.Msglist[i]);
                        if (error)
                            return "Msglist." + error;
                    }
                }
                if (message.Userdef != null && message.hasOwnProperty("Userdef"))
                    if (!(message.Userdef && typeof message.Userdef.length === "number" || $util.isString(message.Userdef)))
                        return "Userdef: buffer expected";
                return null;
            };

            /**
             * Creates a PbGroupMsgWithDrawReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.MsgField.PbGroupMsgWithDrawReq} PbGroupMsgWithDrawReq
             */
            PbGroupMsgWithDrawReq.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.MsgField.PbGroupMsgWithDrawReq)
                    return object;
                var message = new $root.Msg.MsgField.PbGroupMsgWithDrawReq();
                if (object.Subcmd != null)
                    message.Subcmd = object.Subcmd | 0;
                if (object.Grouptype != null)
                    message.Grouptype = object.Grouptype | 0;
                if (object.Groupcode != null)
                    if ($util.Long)
                        (message.Groupcode = $util.Long.fromValue(object.Groupcode)).unsigned = false;
                    else if (typeof object.Groupcode === "string")
                        message.Groupcode = parseInt(object.Groupcode, 10);
                    else if (typeof object.Groupcode === "number")
                        message.Groupcode = object.Groupcode;
                    else if (typeof object.Groupcode === "object")
                        message.Groupcode = new $util.LongBits(object.Groupcode.low >>> 0, object.Groupcode.high >>> 0).toNumber();
                if (object.Msglist) {
                    if (!Array.isArray(object.Msglist))
                        throw TypeError(".Msg.MsgField.PbGroupMsgWithDrawReq.Msglist: array expected");
                    message.Msglist = [];
                    for (var i = 0; i < object.Msglist.length; ++i) {
                        if (typeof object.Msglist[i] !== "object")
                            throw TypeError(".Msg.MsgField.PbGroupMsgWithDrawReq.Msglist: object expected");
                        message.Msglist[i] = $root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo.fromObject(object.Msglist[i]);
                    }
                }
                if (object.Userdef != null)
                    if (typeof object.Userdef === "string")
                        $util.base64.decode(object.Userdef, message.Userdef = $util.newBuffer($util.base64.length(object.Userdef)), 0);
                    else if (object.Userdef.length)
                        message.Userdef = object.Userdef;
                return message;
            };

            /**
             * Creates a plain object from a PbGroupMsgWithDrawReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @static
             * @param {Msg.MsgField.PbGroupMsgWithDrawReq} message PbGroupMsgWithDrawReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PbGroupMsgWithDrawReq.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.Msglist = [];
                if (options.defaults) {
                    object.Subcmd = 0;
                    object.Grouptype = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Groupcode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Groupcode = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.Userdef = "";
                    else {
                        object.Userdef = [];
                        if (options.bytes !== Array)
                            object.Userdef = $util.newBuffer(object.Userdef);
                    }
                }
                if (message.Subcmd != null && message.hasOwnProperty("Subcmd"))
                    object.Subcmd = message.Subcmd;
                if (message.Grouptype != null && message.hasOwnProperty("Grouptype"))
                    object.Grouptype = message.Grouptype;
                if (message.Groupcode != null && message.hasOwnProperty("Groupcode"))
                    if (typeof message.Groupcode === "number")
                        object.Groupcode = options.longs === String ? String(message.Groupcode) : message.Groupcode;
                    else
                        object.Groupcode = options.longs === String ? $util.Long.prototype.toString.call(message.Groupcode) : options.longs === Number ? new $util.LongBits(message.Groupcode.low >>> 0, message.Groupcode.high >>> 0).toNumber() : message.Groupcode;
                if (message.Msglist && message.Msglist.length) {
                    object.Msglist = [];
                    for (var j = 0; j < message.Msglist.length; ++j)
                        object.Msglist[j] = $root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo.toObject(message.Msglist[j], options);
                }
                if (message.Userdef != null && message.hasOwnProperty("Userdef"))
                    object.Userdef = options.bytes === String ? $util.base64.encode(message.Userdef, 0, message.Userdef.length) : options.bytes === Array ? Array.prototype.slice.call(message.Userdef) : message.Userdef;
                return object;
            };

            /**
             * Converts this PbGroupMsgWithDrawReq to JSON.
             * @function toJSON
             * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PbGroupMsgWithDrawReq.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            PbGroupMsgWithDrawReq.MessageInfo = (function() {

                /**
                 * Properties of a MessageInfo.
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
                 * @interface IMessageInfo
                 * @property {number|null} [MsgSeq] MessageInfo MsgSeq
                 * @property {number|null} [MsgRandom] MessageInfo MsgRandom
                 * @property {number|null} [MsgType] MessageInfo MsgType
                 */

                /**
                 * Constructs a new MessageInfo.
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq
                 * @classdesc Represents a MessageInfo.
                 * @implements IMessageInfo
                 * @constructor
                 * @param {Msg.MsgField.PbGroupMsgWithDrawReq.IMessageInfo=} [properties] Properties to set
                 */
                function MessageInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageInfo MsgSeq.
                 * @member {number} MsgSeq
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @instance
                 */
                MessageInfo.prototype.MsgSeq = 0;

                /**
                 * MessageInfo MsgRandom.
                 * @member {number} MsgRandom
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @instance
                 */
                MessageInfo.prototype.MsgRandom = 0;

                /**
                 * MessageInfo MsgType.
                 * @member {number} MsgType
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @instance
                 */
                MessageInfo.prototype.MsgType = 0;

                /**
                 * Creates a new MessageInfo instance using the specified properties.
                 * @function create
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {Msg.MsgField.PbGroupMsgWithDrawReq.IMessageInfo=} [properties] Properties to set
                 * @returns {Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo} MessageInfo instance
                 */
                MessageInfo.create = function create(properties) {
                    return new MessageInfo(properties);
                };

                /**
                 * Encodes the specified MessageInfo message. Does not implicitly {@link Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo.verify|verify} messages.
                 * @function encode
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {Msg.MsgField.PbGroupMsgWithDrawReq.IMessageInfo} message MessageInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.MsgSeq != null && Object.hasOwnProperty.call(message, "MsgSeq"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MsgSeq);
                    if (message.MsgRandom != null && Object.hasOwnProperty.call(message, "MsgRandom"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.MsgRandom);
                    if (message.MsgType != null && Object.hasOwnProperty.call(message, "MsgType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MsgType);
                    return writer;
                };

                /**
                 * Encodes the specified MessageInfo message, length delimited. Does not implicitly {@link Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {Msg.MsgField.PbGroupMsgWithDrawReq.IMessageInfo} message MessageInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo} MessageInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.MsgSeq = reader.int32();
                            break;
                        case 2:
                            message.MsgRandom = reader.int32();
                            break;
                        case 3:
                            message.MsgType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo} MessageInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageInfo message.
                 * @function verify
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                        if (!$util.isInteger(message.MsgSeq))
                            return "MsgSeq: integer expected";
                    if (message.MsgRandom != null && message.hasOwnProperty("MsgRandom"))
                        if (!$util.isInteger(message.MsgRandom))
                            return "MsgRandom: integer expected";
                    if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                        if (!$util.isInteger(message.MsgType))
                            return "MsgType: integer expected";
                    return null;
                };

                /**
                 * Creates a MessageInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo} MessageInfo
                 */
                MessageInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo)
                        return object;
                    var message = new $root.Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo();
                    if (object.MsgSeq != null)
                        message.MsgSeq = object.MsgSeq | 0;
                    if (object.MsgRandom != null)
                        message.MsgRandom = object.MsgRandom | 0;
                    if (object.MsgType != null)
                        message.MsgType = object.MsgType | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @static
                 * @param {Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo} message MessageInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.MsgSeq = 0;
                        object.MsgRandom = 0;
                        object.MsgType = 0;
                    }
                    if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                        object.MsgSeq = message.MsgSeq;
                    if (message.MsgRandom != null && message.hasOwnProperty("MsgRandom"))
                        object.MsgRandom = message.MsgRandom;
                    if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                        object.MsgType = message.MsgType;
                    return object;
                };

                /**
                 * Converts this MessageInfo to JSON.
                 * @function toJSON
                 * @memberof Msg.MsgField.PbGroupMsgWithDrawReq.MessageInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageInfo;
            })();

            return PbGroupMsgWithDrawReq;
        })();

        return MsgField;
    })();

    Msg.PbMsgWithDrawReq = (function() {

        /**
         * Properties of a PbMsgWithDrawReq.
         * @memberof Msg
         * @interface IPbMsgWithDrawReq
         * @property {Array.<Msg.MsgField.IPbC2CMsgWithDrawReq>|null} [ListPbC2CMsgWithDrawReq] PbMsgWithDrawReq ListPbC2CMsgWithDrawReq
         * @property {Array.<Msg.MsgField.IPbGroupMsgWithDrawReq>|null} [ListPbGroupMsgWithDrawReq] PbMsgWithDrawReq ListPbGroupMsgWithDrawReq
         */

        /**
         * Constructs a new PbMsgWithDrawReq.
         * @memberof Msg
         * @classdesc Represents a PbMsgWithDrawReq.
         * @implements IPbMsgWithDrawReq
         * @constructor
         * @param {Msg.IPbMsgWithDrawReq=} [properties] Properties to set
         */
        function PbMsgWithDrawReq(properties) {
            this.ListPbC2CMsgWithDrawReq = [];
            this.ListPbGroupMsgWithDrawReq = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbMsgWithDrawReq ListPbC2CMsgWithDrawReq.
         * @member {Array.<Msg.MsgField.IPbC2CMsgWithDrawReq>} ListPbC2CMsgWithDrawReq
         * @memberof Msg.PbMsgWithDrawReq
         * @instance
         */
        PbMsgWithDrawReq.prototype.ListPbC2CMsgWithDrawReq = $util.emptyArray;

        /**
         * PbMsgWithDrawReq ListPbGroupMsgWithDrawReq.
         * @member {Array.<Msg.MsgField.IPbGroupMsgWithDrawReq>} ListPbGroupMsgWithDrawReq
         * @memberof Msg.PbMsgWithDrawReq
         * @instance
         */
        PbMsgWithDrawReq.prototype.ListPbGroupMsgWithDrawReq = $util.emptyArray;

        /**
         * Creates a new PbMsgWithDrawReq instance using the specified properties.
         * @function create
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {Msg.IPbMsgWithDrawReq=} [properties] Properties to set
         * @returns {Msg.PbMsgWithDrawReq} PbMsgWithDrawReq instance
         */
        PbMsgWithDrawReq.create = function create(properties) {
            return new PbMsgWithDrawReq(properties);
        };

        /**
         * Encodes the specified PbMsgWithDrawReq message. Does not implicitly {@link Msg.PbMsgWithDrawReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {Msg.IPbMsgWithDrawReq} message PbMsgWithDrawReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbMsgWithDrawReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ListPbC2CMsgWithDrawReq != null && message.ListPbC2CMsgWithDrawReq.length)
                for (var i = 0; i < message.ListPbC2CMsgWithDrawReq.length; ++i)
                    $root.Msg.MsgField.PbC2CMsgWithDrawReq.encode(message.ListPbC2CMsgWithDrawReq[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ListPbGroupMsgWithDrawReq != null && message.ListPbGroupMsgWithDrawReq.length)
                for (var i = 0; i < message.ListPbGroupMsgWithDrawReq.length; ++i)
                    $root.Msg.MsgField.PbGroupMsgWithDrawReq.encode(message.ListPbGroupMsgWithDrawReq[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PbMsgWithDrawReq message, length delimited. Does not implicitly {@link Msg.PbMsgWithDrawReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {Msg.IPbMsgWithDrawReq} message PbMsgWithDrawReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbMsgWithDrawReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbMsgWithDrawReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbMsgWithDrawReq} PbMsgWithDrawReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbMsgWithDrawReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbMsgWithDrawReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ListPbC2CMsgWithDrawReq && message.ListPbC2CMsgWithDrawReq.length))
                        message.ListPbC2CMsgWithDrawReq = [];
                    message.ListPbC2CMsgWithDrawReq.push($root.Msg.MsgField.PbC2CMsgWithDrawReq.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.ListPbGroupMsgWithDrawReq && message.ListPbGroupMsgWithDrawReq.length))
                        message.ListPbGroupMsgWithDrawReq = [];
                    message.ListPbGroupMsgWithDrawReq.push($root.Msg.MsgField.PbGroupMsgWithDrawReq.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbMsgWithDrawReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbMsgWithDrawReq} PbMsgWithDrawReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbMsgWithDrawReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbMsgWithDrawReq message.
         * @function verify
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbMsgWithDrawReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ListPbC2CMsgWithDrawReq != null && message.hasOwnProperty("ListPbC2CMsgWithDrawReq")) {
                if (!Array.isArray(message.ListPbC2CMsgWithDrawReq))
                    return "ListPbC2CMsgWithDrawReq: array expected";
                for (var i = 0; i < message.ListPbC2CMsgWithDrawReq.length; ++i) {
                    var error = $root.Msg.MsgField.PbC2CMsgWithDrawReq.verify(message.ListPbC2CMsgWithDrawReq[i]);
                    if (error)
                        return "ListPbC2CMsgWithDrawReq." + error;
                }
            }
            if (message.ListPbGroupMsgWithDrawReq != null && message.hasOwnProperty("ListPbGroupMsgWithDrawReq")) {
                if (!Array.isArray(message.ListPbGroupMsgWithDrawReq))
                    return "ListPbGroupMsgWithDrawReq: array expected";
                for (var i = 0; i < message.ListPbGroupMsgWithDrawReq.length; ++i) {
                    var error = $root.Msg.MsgField.PbGroupMsgWithDrawReq.verify(message.ListPbGroupMsgWithDrawReq[i]);
                    if (error)
                        return "ListPbGroupMsgWithDrawReq." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PbMsgWithDrawReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbMsgWithDrawReq} PbMsgWithDrawReq
         */
        PbMsgWithDrawReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbMsgWithDrawReq)
                return object;
            var message = new $root.Msg.PbMsgWithDrawReq();
            if (object.ListPbC2CMsgWithDrawReq) {
                if (!Array.isArray(object.ListPbC2CMsgWithDrawReq))
                    throw TypeError(".Msg.PbMsgWithDrawReq.ListPbC2CMsgWithDrawReq: array expected");
                message.ListPbC2CMsgWithDrawReq = [];
                for (var i = 0; i < object.ListPbC2CMsgWithDrawReq.length; ++i) {
                    if (typeof object.ListPbC2CMsgWithDrawReq[i] !== "object")
                        throw TypeError(".Msg.PbMsgWithDrawReq.ListPbC2CMsgWithDrawReq: object expected");
                    message.ListPbC2CMsgWithDrawReq[i] = $root.Msg.MsgField.PbC2CMsgWithDrawReq.fromObject(object.ListPbC2CMsgWithDrawReq[i]);
                }
            }
            if (object.ListPbGroupMsgWithDrawReq) {
                if (!Array.isArray(object.ListPbGroupMsgWithDrawReq))
                    throw TypeError(".Msg.PbMsgWithDrawReq.ListPbGroupMsgWithDrawReq: array expected");
                message.ListPbGroupMsgWithDrawReq = [];
                for (var i = 0; i < object.ListPbGroupMsgWithDrawReq.length; ++i) {
                    if (typeof object.ListPbGroupMsgWithDrawReq[i] !== "object")
                        throw TypeError(".Msg.PbMsgWithDrawReq.ListPbGroupMsgWithDrawReq: object expected");
                    message.ListPbGroupMsgWithDrawReq[i] = $root.Msg.MsgField.PbGroupMsgWithDrawReq.fromObject(object.ListPbGroupMsgWithDrawReq[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PbMsgWithDrawReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbMsgWithDrawReq
         * @static
         * @param {Msg.PbMsgWithDrawReq} message PbMsgWithDrawReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbMsgWithDrawReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.ListPbC2CMsgWithDrawReq = [];
                object.ListPbGroupMsgWithDrawReq = [];
            }
            if (message.ListPbC2CMsgWithDrawReq && message.ListPbC2CMsgWithDrawReq.length) {
                object.ListPbC2CMsgWithDrawReq = [];
                for (var j = 0; j < message.ListPbC2CMsgWithDrawReq.length; ++j)
                    object.ListPbC2CMsgWithDrawReq[j] = $root.Msg.MsgField.PbC2CMsgWithDrawReq.toObject(message.ListPbC2CMsgWithDrawReq[j], options);
            }
            if (message.ListPbGroupMsgWithDrawReq && message.ListPbGroupMsgWithDrawReq.length) {
                object.ListPbGroupMsgWithDrawReq = [];
                for (var j = 0; j < message.ListPbGroupMsgWithDrawReq.length; ++j)
                    object.ListPbGroupMsgWithDrawReq[j] = $root.Msg.MsgField.PbGroupMsgWithDrawReq.toObject(message.ListPbGroupMsgWithDrawReq[j], options);
            }
            return object;
        };

        /**
         * Converts this PbMsgWithDrawReq to JSON.
         * @function toJSON
         * @memberof Msg.PbMsgWithDrawReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbMsgWithDrawReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbMsgWithDrawReq;
    })();

    /**
     * SyncFlag enum.
     * @name Msg.SyncFlag
     * @enum {number}
     * @property {number} Start=0 Start value
     * @property {number} Continue=1 Continue value
     * @property {number} Stop=2 Stop value
     */
    Msg.SyncFlag = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Start"] = 0;
        values[valuesById[1] = "Continue"] = 1;
        values[valuesById[2] = "Stop"] = 2;
        return values;
    })();

    Msg.OnlinePushTrans = (function() {

        /**
         * Properties of an OnlinePushTrans.
         * @memberof Msg
         * @interface IOnlinePushTrans
         */

        /**
         * Constructs a new OnlinePushTrans.
         * @memberof Msg
         * @classdesc Represents an OnlinePushTrans.
         * @implements IOnlinePushTrans
         * @constructor
         * @param {Msg.IOnlinePushTrans=} [properties] Properties to set
         */
        function OnlinePushTrans(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new OnlinePushTrans instance using the specified properties.
         * @function create
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {Msg.IOnlinePushTrans=} [properties] Properties to set
         * @returns {Msg.OnlinePushTrans} OnlinePushTrans instance
         */
        OnlinePushTrans.create = function create(properties) {
            return new OnlinePushTrans(properties);
        };

        /**
         * Encodes the specified OnlinePushTrans message. Does not implicitly {@link Msg.OnlinePushTrans.verify|verify} messages.
         * @function encode
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {Msg.IOnlinePushTrans} message OnlinePushTrans message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlinePushTrans.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified OnlinePushTrans message, length delimited. Does not implicitly {@link Msg.OnlinePushTrans.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {Msg.IOnlinePushTrans} message OnlinePushTrans message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlinePushTrans.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OnlinePushTrans message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.OnlinePushTrans} OnlinePushTrans
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlinePushTrans.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.OnlinePushTrans();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OnlinePushTrans message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.OnlinePushTrans} OnlinePushTrans
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlinePushTrans.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OnlinePushTrans message.
         * @function verify
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OnlinePushTrans.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an OnlinePushTrans message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.OnlinePushTrans} OnlinePushTrans
         */
        OnlinePushTrans.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.OnlinePushTrans)
                return object;
            return new $root.Msg.OnlinePushTrans();
        };

        /**
         * Creates a plain object from an OnlinePushTrans message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.OnlinePushTrans
         * @static
         * @param {Msg.OnlinePushTrans} message OnlinePushTrans
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OnlinePushTrans.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this OnlinePushTrans to JSON.
         * @function toJSON
         * @memberof Msg.OnlinePushTrans
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OnlinePushTrans.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        OnlinePushTrans.ExtGroupKeyInfo = (function() {

            /**
             * Properties of an ExtGroupKeyInfo.
             * @memberof Msg.OnlinePushTrans
             * @interface IExtGroupKeyInfo
             * @property {number|null} [CurMaxSeq] ExtGroupKeyInfo CurMaxSeq
             * @property {number|Long|null} [CurTime] ExtGroupKeyInfo CurTime
             */

            /**
             * Constructs a new ExtGroupKeyInfo.
             * @memberof Msg.OnlinePushTrans
             * @classdesc Represents an ExtGroupKeyInfo.
             * @implements IExtGroupKeyInfo
             * @constructor
             * @param {Msg.OnlinePushTrans.IExtGroupKeyInfo=} [properties] Properties to set
             */
            function ExtGroupKeyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtGroupKeyInfo CurMaxSeq.
             * @member {number} CurMaxSeq
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @instance
             */
            ExtGroupKeyInfo.prototype.CurMaxSeq = 0;

            /**
             * ExtGroupKeyInfo CurTime.
             * @member {number|Long} CurTime
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @instance
             */
            ExtGroupKeyInfo.prototype.CurTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ExtGroupKeyInfo instance using the specified properties.
             * @function create
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {Msg.OnlinePushTrans.IExtGroupKeyInfo=} [properties] Properties to set
             * @returns {Msg.OnlinePushTrans.ExtGroupKeyInfo} ExtGroupKeyInfo instance
             */
            ExtGroupKeyInfo.create = function create(properties) {
                return new ExtGroupKeyInfo(properties);
            };

            /**
             * Encodes the specified ExtGroupKeyInfo message. Does not implicitly {@link Msg.OnlinePushTrans.ExtGroupKeyInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {Msg.OnlinePushTrans.IExtGroupKeyInfo} message ExtGroupKeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtGroupKeyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.CurMaxSeq != null && Object.hasOwnProperty.call(message, "CurMaxSeq"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CurMaxSeq);
                if (message.CurTime != null && Object.hasOwnProperty.call(message, "CurTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.CurTime);
                return writer;
            };

            /**
             * Encodes the specified ExtGroupKeyInfo message, length delimited. Does not implicitly {@link Msg.OnlinePushTrans.ExtGroupKeyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {Msg.OnlinePushTrans.IExtGroupKeyInfo} message ExtGroupKeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtGroupKeyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtGroupKeyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.OnlinePushTrans.ExtGroupKeyInfo} ExtGroupKeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtGroupKeyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.OnlinePushTrans.ExtGroupKeyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.CurMaxSeq = reader.int32();
                        break;
                    case 2:
                        message.CurTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtGroupKeyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.OnlinePushTrans.ExtGroupKeyInfo} ExtGroupKeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtGroupKeyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtGroupKeyInfo message.
             * @function verify
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtGroupKeyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.CurMaxSeq != null && message.hasOwnProperty("CurMaxSeq"))
                    if (!$util.isInteger(message.CurMaxSeq))
                        return "CurMaxSeq: integer expected";
                if (message.CurTime != null && message.hasOwnProperty("CurTime"))
                    if (!$util.isInteger(message.CurTime) && !(message.CurTime && $util.isInteger(message.CurTime.low) && $util.isInteger(message.CurTime.high)))
                        return "CurTime: integer|Long expected";
                return null;
            };

            /**
             * Creates an ExtGroupKeyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.OnlinePushTrans.ExtGroupKeyInfo} ExtGroupKeyInfo
             */
            ExtGroupKeyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.OnlinePushTrans.ExtGroupKeyInfo)
                    return object;
                var message = new $root.Msg.OnlinePushTrans.ExtGroupKeyInfo();
                if (object.CurMaxSeq != null)
                    message.CurMaxSeq = object.CurMaxSeq | 0;
                if (object.CurTime != null)
                    if ($util.Long)
                        (message.CurTime = $util.Long.fromValue(object.CurTime)).unsigned = false;
                    else if (typeof object.CurTime === "string")
                        message.CurTime = parseInt(object.CurTime, 10);
                    else if (typeof object.CurTime === "number")
                        message.CurTime = object.CurTime;
                    else if (typeof object.CurTime === "object")
                        message.CurTime = new $util.LongBits(object.CurTime.low >>> 0, object.CurTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an ExtGroupKeyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @static
             * @param {Msg.OnlinePushTrans.ExtGroupKeyInfo} message ExtGroupKeyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtGroupKeyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.CurMaxSeq = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.CurTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.CurTime = options.longs === String ? "0" : 0;
                }
                if (message.CurMaxSeq != null && message.hasOwnProperty("CurMaxSeq"))
                    object.CurMaxSeq = message.CurMaxSeq;
                if (message.CurTime != null && message.hasOwnProperty("CurTime"))
                    if (typeof message.CurTime === "number")
                        object.CurTime = options.longs === String ? String(message.CurTime) : message.CurTime;
                    else
                        object.CurTime = options.longs === String ? $util.Long.prototype.toString.call(message.CurTime) : options.longs === Number ? new $util.LongBits(message.CurTime.low >>> 0, message.CurTime.high >>> 0).toNumber() : message.CurTime;
                return object;
            };

            /**
             * Converts this ExtGroupKeyInfo to JSON.
             * @function toJSON
             * @memberof Msg.OnlinePushTrans.ExtGroupKeyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtGroupKeyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExtGroupKeyInfo;
        })();

        OnlinePushTrans.PbMsgInfo = (function() {

            /**
             * Properties of a PbMsgInfo.
             * @memberof Msg.OnlinePushTrans
             * @interface IPbMsgInfo
             * @property {number|Long|null} [Fromuin] PbMsgInfo Fromuin
             * @property {number|Long|null} [Touin] PbMsgInfo Touin
             * @property {number|null} [Msgtype] PbMsgInfo Msgtype
             * @property {number|null} [Msgsubtype] PbMsgInfo Msgsubtype
             * @property {number|null} [Msgseq] PbMsgInfo Msgseq
             * @property {number|Long|null} [Msguid] PbMsgInfo Msguid
             * @property {number|null} [Msgtime] PbMsgInfo Msgtime
             * @property {number|null} [Realmsgtime] PbMsgInfo Realmsgtime
             * @property {string|null} [Nickname] PbMsgInfo Nickname
             * @property {Uint8Array|null} [Msgdata] PbMsgInfo Msgdata
             * @property {number|null} [Svrip] PbMsgInfo Svrip
             * @property {Msg.OnlinePushTrans.IExtGroupKeyInfo|null} [Extgroupkeyinfo] PbMsgInfo Extgroupkeyinfo
             * @property {number|null} [Generalflag] PbMsgInfo Generalflag
             */

            /**
             * Constructs a new PbMsgInfo.
             * @memberof Msg.OnlinePushTrans
             * @classdesc Represents a PbMsgInfo.
             * @implements IPbMsgInfo
             * @constructor
             * @param {Msg.OnlinePushTrans.IPbMsgInfo=} [properties] Properties to set
             */
            function PbMsgInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PbMsgInfo Fromuin.
             * @member {number|Long} Fromuin
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Fromuin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PbMsgInfo Touin.
             * @member {number|Long} Touin
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Touin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PbMsgInfo Msgtype.
             * @member {number} Msgtype
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Msgtype = 0;

            /**
             * PbMsgInfo Msgsubtype.
             * @member {number} Msgsubtype
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Msgsubtype = 0;

            /**
             * PbMsgInfo Msgseq.
             * @member {number} Msgseq
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Msgseq = 0;

            /**
             * PbMsgInfo Msguid.
             * @member {number|Long} Msguid
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Msguid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PbMsgInfo Msgtime.
             * @member {number} Msgtime
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Msgtime = 0;

            /**
             * PbMsgInfo Realmsgtime.
             * @member {number} Realmsgtime
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Realmsgtime = 0;

            /**
             * PbMsgInfo Nickname.
             * @member {string} Nickname
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Nickname = "";

            /**
             * PbMsgInfo Msgdata.
             * @member {Uint8Array} Msgdata
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Msgdata = $util.newBuffer([]);

            /**
             * PbMsgInfo Svrip.
             * @member {number} Svrip
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Svrip = 0;

            /**
             * PbMsgInfo Extgroupkeyinfo.
             * @member {Msg.OnlinePushTrans.IExtGroupKeyInfo|null|undefined} Extgroupkeyinfo
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Extgroupkeyinfo = null;

            /**
             * PbMsgInfo Generalflag.
             * @member {number} Generalflag
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             */
            PbMsgInfo.prototype.Generalflag = 0;

            /**
             * Creates a new PbMsgInfo instance using the specified properties.
             * @function create
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {Msg.OnlinePushTrans.IPbMsgInfo=} [properties] Properties to set
             * @returns {Msg.OnlinePushTrans.PbMsgInfo} PbMsgInfo instance
             */
            PbMsgInfo.create = function create(properties) {
                return new PbMsgInfo(properties);
            };

            /**
             * Encodes the specified PbMsgInfo message. Does not implicitly {@link Msg.OnlinePushTrans.PbMsgInfo.verify|verify} messages.
             * @function encode
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {Msg.OnlinePushTrans.IPbMsgInfo} message PbMsgInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbMsgInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Fromuin != null && Object.hasOwnProperty.call(message, "Fromuin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Fromuin);
                if (message.Touin != null && Object.hasOwnProperty.call(message, "Touin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Touin);
                if (message.Msgtype != null && Object.hasOwnProperty.call(message, "Msgtype"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Msgtype);
                if (message.Msgsubtype != null && Object.hasOwnProperty.call(message, "Msgsubtype"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Msgsubtype);
                if (message.Msgseq != null && Object.hasOwnProperty.call(message, "Msgseq"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Msgseq);
                if (message.Msguid != null && Object.hasOwnProperty.call(message, "Msguid"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.Msguid);
                if (message.Msgtime != null && Object.hasOwnProperty.call(message, "Msgtime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Msgtime);
                if (message.Realmsgtime != null && Object.hasOwnProperty.call(message, "Realmsgtime"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Realmsgtime);
                if (message.Nickname != null && Object.hasOwnProperty.call(message, "Nickname"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.Nickname);
                if (message.Msgdata != null && Object.hasOwnProperty.call(message, "Msgdata"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.Msgdata);
                if (message.Svrip != null && Object.hasOwnProperty.call(message, "Svrip"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.Svrip);
                if (message.Extgroupkeyinfo != null && Object.hasOwnProperty.call(message, "Extgroupkeyinfo"))
                    $root.Msg.OnlinePushTrans.ExtGroupKeyInfo.encode(message.Extgroupkeyinfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.Generalflag != null && Object.hasOwnProperty.call(message, "Generalflag"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.Generalflag);
                return writer;
            };

            /**
             * Encodes the specified PbMsgInfo message, length delimited. Does not implicitly {@link Msg.OnlinePushTrans.PbMsgInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {Msg.OnlinePushTrans.IPbMsgInfo} message PbMsgInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PbMsgInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PbMsgInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.OnlinePushTrans.PbMsgInfo} PbMsgInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbMsgInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.OnlinePushTrans.PbMsgInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Fromuin = reader.int64();
                        break;
                    case 2:
                        message.Touin = reader.int64();
                        break;
                    case 3:
                        message.Msgtype = reader.int32();
                        break;
                    case 4:
                        message.Msgsubtype = reader.int32();
                        break;
                    case 5:
                        message.Msgseq = reader.int32();
                        break;
                    case 6:
                        message.Msguid = reader.int64();
                        break;
                    case 7:
                        message.Msgtime = reader.int32();
                        break;
                    case 8:
                        message.Realmsgtime = reader.int32();
                        break;
                    case 9:
                        message.Nickname = reader.string();
                        break;
                    case 10:
                        message.Msgdata = reader.bytes();
                        break;
                    case 11:
                        message.Svrip = reader.int32();
                        break;
                    case 12:
                        message.Extgroupkeyinfo = $root.Msg.OnlinePushTrans.ExtGroupKeyInfo.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.Generalflag = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PbMsgInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.OnlinePushTrans.PbMsgInfo} PbMsgInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PbMsgInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PbMsgInfo message.
             * @function verify
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PbMsgInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Fromuin != null && message.hasOwnProperty("Fromuin"))
                    if (!$util.isInteger(message.Fromuin) && !(message.Fromuin && $util.isInteger(message.Fromuin.low) && $util.isInteger(message.Fromuin.high)))
                        return "Fromuin: integer|Long expected";
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (!$util.isInteger(message.Touin) && !(message.Touin && $util.isInteger(message.Touin.low) && $util.isInteger(message.Touin.high)))
                        return "Touin: integer|Long expected";
                if (message.Msgtype != null && message.hasOwnProperty("Msgtype"))
                    if (!$util.isInteger(message.Msgtype))
                        return "Msgtype: integer expected";
                if (message.Msgsubtype != null && message.hasOwnProperty("Msgsubtype"))
                    if (!$util.isInteger(message.Msgsubtype))
                        return "Msgsubtype: integer expected";
                if (message.Msgseq != null && message.hasOwnProperty("Msgseq"))
                    if (!$util.isInteger(message.Msgseq))
                        return "Msgseq: integer expected";
                if (message.Msguid != null && message.hasOwnProperty("Msguid"))
                    if (!$util.isInteger(message.Msguid) && !(message.Msguid && $util.isInteger(message.Msguid.low) && $util.isInteger(message.Msguid.high)))
                        return "Msguid: integer|Long expected";
                if (message.Msgtime != null && message.hasOwnProperty("Msgtime"))
                    if (!$util.isInteger(message.Msgtime))
                        return "Msgtime: integer expected";
                if (message.Realmsgtime != null && message.hasOwnProperty("Realmsgtime"))
                    if (!$util.isInteger(message.Realmsgtime))
                        return "Realmsgtime: integer expected";
                if (message.Nickname != null && message.hasOwnProperty("Nickname"))
                    if (!$util.isString(message.Nickname))
                        return "Nickname: string expected";
                if (message.Msgdata != null && message.hasOwnProperty("Msgdata"))
                    if (!(message.Msgdata && typeof message.Msgdata.length === "number" || $util.isString(message.Msgdata)))
                        return "Msgdata: buffer expected";
                if (message.Svrip != null && message.hasOwnProperty("Svrip"))
                    if (!$util.isInteger(message.Svrip))
                        return "Svrip: integer expected";
                if (message.Extgroupkeyinfo != null && message.hasOwnProperty("Extgroupkeyinfo")) {
                    var error = $root.Msg.OnlinePushTrans.ExtGroupKeyInfo.verify(message.Extgroupkeyinfo);
                    if (error)
                        return "Extgroupkeyinfo." + error;
                }
                if (message.Generalflag != null && message.hasOwnProperty("Generalflag"))
                    if (!$util.isInteger(message.Generalflag))
                        return "Generalflag: integer expected";
                return null;
            };

            /**
             * Creates a PbMsgInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.OnlinePushTrans.PbMsgInfo} PbMsgInfo
             */
            PbMsgInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.OnlinePushTrans.PbMsgInfo)
                    return object;
                var message = new $root.Msg.OnlinePushTrans.PbMsgInfo();
                if (object.Fromuin != null)
                    if ($util.Long)
                        (message.Fromuin = $util.Long.fromValue(object.Fromuin)).unsigned = false;
                    else if (typeof object.Fromuin === "string")
                        message.Fromuin = parseInt(object.Fromuin, 10);
                    else if (typeof object.Fromuin === "number")
                        message.Fromuin = object.Fromuin;
                    else if (typeof object.Fromuin === "object")
                        message.Fromuin = new $util.LongBits(object.Fromuin.low >>> 0, object.Fromuin.high >>> 0).toNumber();
                if (object.Touin != null)
                    if ($util.Long)
                        (message.Touin = $util.Long.fromValue(object.Touin)).unsigned = false;
                    else if (typeof object.Touin === "string")
                        message.Touin = parseInt(object.Touin, 10);
                    else if (typeof object.Touin === "number")
                        message.Touin = object.Touin;
                    else if (typeof object.Touin === "object")
                        message.Touin = new $util.LongBits(object.Touin.low >>> 0, object.Touin.high >>> 0).toNumber();
                if (object.Msgtype != null)
                    message.Msgtype = object.Msgtype | 0;
                if (object.Msgsubtype != null)
                    message.Msgsubtype = object.Msgsubtype | 0;
                if (object.Msgseq != null)
                    message.Msgseq = object.Msgseq | 0;
                if (object.Msguid != null)
                    if ($util.Long)
                        (message.Msguid = $util.Long.fromValue(object.Msguid)).unsigned = false;
                    else if (typeof object.Msguid === "string")
                        message.Msguid = parseInt(object.Msguid, 10);
                    else if (typeof object.Msguid === "number")
                        message.Msguid = object.Msguid;
                    else if (typeof object.Msguid === "object")
                        message.Msguid = new $util.LongBits(object.Msguid.low >>> 0, object.Msguid.high >>> 0).toNumber();
                if (object.Msgtime != null)
                    message.Msgtime = object.Msgtime | 0;
                if (object.Realmsgtime != null)
                    message.Realmsgtime = object.Realmsgtime | 0;
                if (object.Nickname != null)
                    message.Nickname = String(object.Nickname);
                if (object.Msgdata != null)
                    if (typeof object.Msgdata === "string")
                        $util.base64.decode(object.Msgdata, message.Msgdata = $util.newBuffer($util.base64.length(object.Msgdata)), 0);
                    else if (object.Msgdata.length)
                        message.Msgdata = object.Msgdata;
                if (object.Svrip != null)
                    message.Svrip = object.Svrip | 0;
                if (object.Extgroupkeyinfo != null) {
                    if (typeof object.Extgroupkeyinfo !== "object")
                        throw TypeError(".Msg.OnlinePushTrans.PbMsgInfo.Extgroupkeyinfo: object expected");
                    message.Extgroupkeyinfo = $root.Msg.OnlinePushTrans.ExtGroupKeyInfo.fromObject(object.Extgroupkeyinfo);
                }
                if (object.Generalflag != null)
                    message.Generalflag = object.Generalflag | 0;
                return message;
            };

            /**
             * Creates a plain object from a PbMsgInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @static
             * @param {Msg.OnlinePushTrans.PbMsgInfo} message PbMsgInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PbMsgInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Fromuin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Fromuin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Touin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Touin = options.longs === String ? "0" : 0;
                    object.Msgtype = 0;
                    object.Msgsubtype = 0;
                    object.Msgseq = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.Msguid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.Msguid = options.longs === String ? "0" : 0;
                    object.Msgtime = 0;
                    object.Realmsgtime = 0;
                    object.Nickname = "";
                    if (options.bytes === String)
                        object.Msgdata = "";
                    else {
                        object.Msgdata = [];
                        if (options.bytes !== Array)
                            object.Msgdata = $util.newBuffer(object.Msgdata);
                    }
                    object.Svrip = 0;
                    object.Extgroupkeyinfo = null;
                    object.Generalflag = 0;
                }
                if (message.Fromuin != null && message.hasOwnProperty("Fromuin"))
                    if (typeof message.Fromuin === "number")
                        object.Fromuin = options.longs === String ? String(message.Fromuin) : message.Fromuin;
                    else
                        object.Fromuin = options.longs === String ? $util.Long.prototype.toString.call(message.Fromuin) : options.longs === Number ? new $util.LongBits(message.Fromuin.low >>> 0, message.Fromuin.high >>> 0).toNumber() : message.Fromuin;
                if (message.Touin != null && message.hasOwnProperty("Touin"))
                    if (typeof message.Touin === "number")
                        object.Touin = options.longs === String ? String(message.Touin) : message.Touin;
                    else
                        object.Touin = options.longs === String ? $util.Long.prototype.toString.call(message.Touin) : options.longs === Number ? new $util.LongBits(message.Touin.low >>> 0, message.Touin.high >>> 0).toNumber() : message.Touin;
                if (message.Msgtype != null && message.hasOwnProperty("Msgtype"))
                    object.Msgtype = message.Msgtype;
                if (message.Msgsubtype != null && message.hasOwnProperty("Msgsubtype"))
                    object.Msgsubtype = message.Msgsubtype;
                if (message.Msgseq != null && message.hasOwnProperty("Msgseq"))
                    object.Msgseq = message.Msgseq;
                if (message.Msguid != null && message.hasOwnProperty("Msguid"))
                    if (typeof message.Msguid === "number")
                        object.Msguid = options.longs === String ? String(message.Msguid) : message.Msguid;
                    else
                        object.Msguid = options.longs === String ? $util.Long.prototype.toString.call(message.Msguid) : options.longs === Number ? new $util.LongBits(message.Msguid.low >>> 0, message.Msguid.high >>> 0).toNumber() : message.Msguid;
                if (message.Msgtime != null && message.hasOwnProperty("Msgtime"))
                    object.Msgtime = message.Msgtime;
                if (message.Realmsgtime != null && message.hasOwnProperty("Realmsgtime"))
                    object.Realmsgtime = message.Realmsgtime;
                if (message.Nickname != null && message.hasOwnProperty("Nickname"))
                    object.Nickname = message.Nickname;
                if (message.Msgdata != null && message.hasOwnProperty("Msgdata"))
                    object.Msgdata = options.bytes === String ? $util.base64.encode(message.Msgdata, 0, message.Msgdata.length) : options.bytes === Array ? Array.prototype.slice.call(message.Msgdata) : message.Msgdata;
                if (message.Svrip != null && message.hasOwnProperty("Svrip"))
                    object.Svrip = message.Svrip;
                if (message.Extgroupkeyinfo != null && message.hasOwnProperty("Extgroupkeyinfo"))
                    object.Extgroupkeyinfo = $root.Msg.OnlinePushTrans.ExtGroupKeyInfo.toObject(message.Extgroupkeyinfo, options);
                if (message.Generalflag != null && message.hasOwnProperty("Generalflag"))
                    object.Generalflag = message.Generalflag;
                return object;
            };

            /**
             * Converts this PbMsgInfo to JSON.
             * @function toJSON
             * @memberof Msg.OnlinePushTrans.PbMsgInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PbMsgInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PbMsgInfo;
        })();

        return OnlinePushTrans;
    })();

    Msg.SyncCookie = (function() {

        /**
         * Properties of a SyncCookie.
         * @memberof Msg
         * @interface ISyncCookie
         * @property {number|Long|null} [time1] SyncCookie time1
         * @property {number|Long|null} [time2] SyncCookie time2
         * @property {number|Long|null} [param1] SyncCookie param1
         * @property {number|Long|null} [param2] SyncCookie param2
         * @property {number|Long|null} [param3] SyncCookie param3
         * @property {number|Long|null} [param4] SyncCookie param4
         * @property {number|Long|null} [param5] SyncCookie param5
         * @property {number|Long|null} [LastSyncTime] SyncCookie LastSyncTime
         * @property {number|Long|null} [param6] SyncCookie param6
         */

        /**
         * Constructs a new SyncCookie.
         * @memberof Msg
         * @classdesc Represents a SyncCookie.
         * @implements ISyncCookie
         * @constructor
         * @param {Msg.ISyncCookie=} [properties] Properties to set
         */
        function SyncCookie(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncCookie time1.
         * @member {number|Long} time1
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.time1 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie time2.
         * @member {number|Long} time2
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.time2 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie param1.
         * @member {number|Long} param1
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.param1 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie param2.
         * @member {number|Long} param2
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.param2 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie param3.
         * @member {number|Long} param3
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.param3 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie param4.
         * @member {number|Long} param4
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.param4 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie param5.
         * @member {number|Long} param5
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.param5 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie LastSyncTime.
         * @member {number|Long} LastSyncTime
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.LastSyncTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncCookie param6.
         * @member {number|Long} param6
         * @memberof Msg.SyncCookie
         * @instance
         */
        SyncCookie.prototype.param6 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SyncCookie instance using the specified properties.
         * @function create
         * @memberof Msg.SyncCookie
         * @static
         * @param {Msg.ISyncCookie=} [properties] Properties to set
         * @returns {Msg.SyncCookie} SyncCookie instance
         */
        SyncCookie.create = function create(properties) {
            return new SyncCookie(properties);
        };

        /**
         * Encodes the specified SyncCookie message. Does not implicitly {@link Msg.SyncCookie.verify|verify} messages.
         * @function encode
         * @memberof Msg.SyncCookie
         * @static
         * @param {Msg.ISyncCookie} message SyncCookie message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncCookie.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time1 != null && Object.hasOwnProperty.call(message, "time1"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time1);
            if (message.time2 != null && Object.hasOwnProperty.call(message, "time2"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time2);
            if (message.param1 != null && Object.hasOwnProperty.call(message, "param1"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.param1);
            if (message.param2 != null && Object.hasOwnProperty.call(message, "param2"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.param2);
            if (message.param3 != null && Object.hasOwnProperty.call(message, "param3"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.param3);
            if (message.param4 != null && Object.hasOwnProperty.call(message, "param4"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.param4);
            if (message.param5 != null && Object.hasOwnProperty.call(message, "param5"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.param5);
            if (message.LastSyncTime != null && Object.hasOwnProperty.call(message, "LastSyncTime"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.LastSyncTime);
            if (message.param6 != null && Object.hasOwnProperty.call(message, "param6"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.param6);
            return writer;
        };

        /**
         * Encodes the specified SyncCookie message, length delimited. Does not implicitly {@link Msg.SyncCookie.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.SyncCookie
         * @static
         * @param {Msg.ISyncCookie} message SyncCookie message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncCookie.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncCookie message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.SyncCookie
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.SyncCookie} SyncCookie
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncCookie.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.SyncCookie();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time1 = reader.int64();
                    break;
                case 2:
                    message.time2 = reader.int64();
                    break;
                case 3:
                    message.param1 = reader.int64();
                    break;
                case 4:
                    message.param2 = reader.int64();
                    break;
                case 5:
                    message.param3 = reader.int64();
                    break;
                case 11:
                    message.param4 = reader.int64();
                    break;
                case 12:
                    message.param5 = reader.int64();
                    break;
                case 13:
                    message.LastSyncTime = reader.int64();
                    break;
                case 14:
                    message.param6 = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncCookie message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.SyncCookie
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.SyncCookie} SyncCookie
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncCookie.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncCookie message.
         * @function verify
         * @memberof Msg.SyncCookie
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncCookie.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time1 != null && message.hasOwnProperty("time1"))
                if (!$util.isInteger(message.time1) && !(message.time1 && $util.isInteger(message.time1.low) && $util.isInteger(message.time1.high)))
                    return "time1: integer|Long expected";
            if (message.time2 != null && message.hasOwnProperty("time2"))
                if (!$util.isInteger(message.time2) && !(message.time2 && $util.isInteger(message.time2.low) && $util.isInteger(message.time2.high)))
                    return "time2: integer|Long expected";
            if (message.param1 != null && message.hasOwnProperty("param1"))
                if (!$util.isInteger(message.param1) && !(message.param1 && $util.isInteger(message.param1.low) && $util.isInteger(message.param1.high)))
                    return "param1: integer|Long expected";
            if (message.param2 != null && message.hasOwnProperty("param2"))
                if (!$util.isInteger(message.param2) && !(message.param2 && $util.isInteger(message.param2.low) && $util.isInteger(message.param2.high)))
                    return "param2: integer|Long expected";
            if (message.param3 != null && message.hasOwnProperty("param3"))
                if (!$util.isInteger(message.param3) && !(message.param3 && $util.isInteger(message.param3.low) && $util.isInteger(message.param3.high)))
                    return "param3: integer|Long expected";
            if (message.param4 != null && message.hasOwnProperty("param4"))
                if (!$util.isInteger(message.param4) && !(message.param4 && $util.isInteger(message.param4.low) && $util.isInteger(message.param4.high)))
                    return "param4: integer|Long expected";
            if (message.param5 != null && message.hasOwnProperty("param5"))
                if (!$util.isInteger(message.param5) && !(message.param5 && $util.isInteger(message.param5.low) && $util.isInteger(message.param5.high)))
                    return "param5: integer|Long expected";
            if (message.LastSyncTime != null && message.hasOwnProperty("LastSyncTime"))
                if (!$util.isInteger(message.LastSyncTime) && !(message.LastSyncTime && $util.isInteger(message.LastSyncTime.low) && $util.isInteger(message.LastSyncTime.high)))
                    return "LastSyncTime: integer|Long expected";
            if (message.param6 != null && message.hasOwnProperty("param6"))
                if (!$util.isInteger(message.param6) && !(message.param6 && $util.isInteger(message.param6.low) && $util.isInteger(message.param6.high)))
                    return "param6: integer|Long expected";
            return null;
        };

        /**
         * Creates a SyncCookie message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.SyncCookie
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.SyncCookie} SyncCookie
         */
        SyncCookie.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.SyncCookie)
                return object;
            var message = new $root.Msg.SyncCookie();
            if (object.time1 != null)
                if ($util.Long)
                    (message.time1 = $util.Long.fromValue(object.time1)).unsigned = false;
                else if (typeof object.time1 === "string")
                    message.time1 = parseInt(object.time1, 10);
                else if (typeof object.time1 === "number")
                    message.time1 = object.time1;
                else if (typeof object.time1 === "object")
                    message.time1 = new $util.LongBits(object.time1.low >>> 0, object.time1.high >>> 0).toNumber();
            if (object.time2 != null)
                if ($util.Long)
                    (message.time2 = $util.Long.fromValue(object.time2)).unsigned = false;
                else if (typeof object.time2 === "string")
                    message.time2 = parseInt(object.time2, 10);
                else if (typeof object.time2 === "number")
                    message.time2 = object.time2;
                else if (typeof object.time2 === "object")
                    message.time2 = new $util.LongBits(object.time2.low >>> 0, object.time2.high >>> 0).toNumber();
            if (object.param1 != null)
                if ($util.Long)
                    (message.param1 = $util.Long.fromValue(object.param1)).unsigned = false;
                else if (typeof object.param1 === "string")
                    message.param1 = parseInt(object.param1, 10);
                else if (typeof object.param1 === "number")
                    message.param1 = object.param1;
                else if (typeof object.param1 === "object")
                    message.param1 = new $util.LongBits(object.param1.low >>> 0, object.param1.high >>> 0).toNumber();
            if (object.param2 != null)
                if ($util.Long)
                    (message.param2 = $util.Long.fromValue(object.param2)).unsigned = false;
                else if (typeof object.param2 === "string")
                    message.param2 = parseInt(object.param2, 10);
                else if (typeof object.param2 === "number")
                    message.param2 = object.param2;
                else if (typeof object.param2 === "object")
                    message.param2 = new $util.LongBits(object.param2.low >>> 0, object.param2.high >>> 0).toNumber();
            if (object.param3 != null)
                if ($util.Long)
                    (message.param3 = $util.Long.fromValue(object.param3)).unsigned = false;
                else if (typeof object.param3 === "string")
                    message.param3 = parseInt(object.param3, 10);
                else if (typeof object.param3 === "number")
                    message.param3 = object.param3;
                else if (typeof object.param3 === "object")
                    message.param3 = new $util.LongBits(object.param3.low >>> 0, object.param3.high >>> 0).toNumber();
            if (object.param4 != null)
                if ($util.Long)
                    (message.param4 = $util.Long.fromValue(object.param4)).unsigned = false;
                else if (typeof object.param4 === "string")
                    message.param4 = parseInt(object.param4, 10);
                else if (typeof object.param4 === "number")
                    message.param4 = object.param4;
                else if (typeof object.param4 === "object")
                    message.param4 = new $util.LongBits(object.param4.low >>> 0, object.param4.high >>> 0).toNumber();
            if (object.param5 != null)
                if ($util.Long)
                    (message.param5 = $util.Long.fromValue(object.param5)).unsigned = false;
                else if (typeof object.param5 === "string")
                    message.param5 = parseInt(object.param5, 10);
                else if (typeof object.param5 === "number")
                    message.param5 = object.param5;
                else if (typeof object.param5 === "object")
                    message.param5 = new $util.LongBits(object.param5.low >>> 0, object.param5.high >>> 0).toNumber();
            if (object.LastSyncTime != null)
                if ($util.Long)
                    (message.LastSyncTime = $util.Long.fromValue(object.LastSyncTime)).unsigned = false;
                else if (typeof object.LastSyncTime === "string")
                    message.LastSyncTime = parseInt(object.LastSyncTime, 10);
                else if (typeof object.LastSyncTime === "number")
                    message.LastSyncTime = object.LastSyncTime;
                else if (typeof object.LastSyncTime === "object")
                    message.LastSyncTime = new $util.LongBits(object.LastSyncTime.low >>> 0, object.LastSyncTime.high >>> 0).toNumber();
            if (object.param6 != null)
                if ($util.Long)
                    (message.param6 = $util.Long.fromValue(object.param6)).unsigned = false;
                else if (typeof object.param6 === "string")
                    message.param6 = parseInt(object.param6, 10);
                else if (typeof object.param6 === "number")
                    message.param6 = object.param6;
                else if (typeof object.param6 === "object")
                    message.param6 = new $util.LongBits(object.param6.low >>> 0, object.param6.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SyncCookie message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.SyncCookie
         * @static
         * @param {Msg.SyncCookie} message SyncCookie
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncCookie.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time1 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time1 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time2 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.param1 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.param1 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.param2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.param2 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.param3 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.param3 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.param4 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.param4 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.param5 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.param5 = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.LastSyncTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.LastSyncTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.param6 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.param6 = options.longs === String ? "0" : 0;
            }
            if (message.time1 != null && message.hasOwnProperty("time1"))
                if (typeof message.time1 === "number")
                    object.time1 = options.longs === String ? String(message.time1) : message.time1;
                else
                    object.time1 = options.longs === String ? $util.Long.prototype.toString.call(message.time1) : options.longs === Number ? new $util.LongBits(message.time1.low >>> 0, message.time1.high >>> 0).toNumber() : message.time1;
            if (message.time2 != null && message.hasOwnProperty("time2"))
                if (typeof message.time2 === "number")
                    object.time2 = options.longs === String ? String(message.time2) : message.time2;
                else
                    object.time2 = options.longs === String ? $util.Long.prototype.toString.call(message.time2) : options.longs === Number ? new $util.LongBits(message.time2.low >>> 0, message.time2.high >>> 0).toNumber() : message.time2;
            if (message.param1 != null && message.hasOwnProperty("param1"))
                if (typeof message.param1 === "number")
                    object.param1 = options.longs === String ? String(message.param1) : message.param1;
                else
                    object.param1 = options.longs === String ? $util.Long.prototype.toString.call(message.param1) : options.longs === Number ? new $util.LongBits(message.param1.low >>> 0, message.param1.high >>> 0).toNumber() : message.param1;
            if (message.param2 != null && message.hasOwnProperty("param2"))
                if (typeof message.param2 === "number")
                    object.param2 = options.longs === String ? String(message.param2) : message.param2;
                else
                    object.param2 = options.longs === String ? $util.Long.prototype.toString.call(message.param2) : options.longs === Number ? new $util.LongBits(message.param2.low >>> 0, message.param2.high >>> 0).toNumber() : message.param2;
            if (message.param3 != null && message.hasOwnProperty("param3"))
                if (typeof message.param3 === "number")
                    object.param3 = options.longs === String ? String(message.param3) : message.param3;
                else
                    object.param3 = options.longs === String ? $util.Long.prototype.toString.call(message.param3) : options.longs === Number ? new $util.LongBits(message.param3.low >>> 0, message.param3.high >>> 0).toNumber() : message.param3;
            if (message.param4 != null && message.hasOwnProperty("param4"))
                if (typeof message.param4 === "number")
                    object.param4 = options.longs === String ? String(message.param4) : message.param4;
                else
                    object.param4 = options.longs === String ? $util.Long.prototype.toString.call(message.param4) : options.longs === Number ? new $util.LongBits(message.param4.low >>> 0, message.param4.high >>> 0).toNumber() : message.param4;
            if (message.param5 != null && message.hasOwnProperty("param5"))
                if (typeof message.param5 === "number")
                    object.param5 = options.longs === String ? String(message.param5) : message.param5;
                else
                    object.param5 = options.longs === String ? $util.Long.prototype.toString.call(message.param5) : options.longs === Number ? new $util.LongBits(message.param5.low >>> 0, message.param5.high >>> 0).toNumber() : message.param5;
            if (message.LastSyncTime != null && message.hasOwnProperty("LastSyncTime"))
                if (typeof message.LastSyncTime === "number")
                    object.LastSyncTime = options.longs === String ? String(message.LastSyncTime) : message.LastSyncTime;
                else
                    object.LastSyncTime = options.longs === String ? $util.Long.prototype.toString.call(message.LastSyncTime) : options.longs === Number ? new $util.LongBits(message.LastSyncTime.low >>> 0, message.LastSyncTime.high >>> 0).toNumber() : message.LastSyncTime;
            if (message.param6 != null && message.hasOwnProperty("param6"))
                if (typeof message.param6 === "number")
                    object.param6 = options.longs === String ? String(message.param6) : message.param6;
                else
                    object.param6 = options.longs === String ? $util.Long.prototype.toString.call(message.param6) : options.longs === Number ? new $util.LongBits(message.param6.low >>> 0, message.param6.high >>> 0).toNumber() : message.param6;
            return object;
        };

        /**
         * Converts this SyncCookie to JSON.
         * @function toJSON
         * @memberof Msg.SyncCookie
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncCookie.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncCookie;
    })();

    Msg.MsgItem = (function() {

        /**
         * Properties of a MsgItem.
         * @memberof Msg
         * @interface IMsgItem
         * @property {number|Long|null} [FromUin] MsgItem FromUin
         * @property {number|Long|null} [ToUin] MsgItem ToUin
         * @property {number|null} [MsgType] MsgItem MsgType
         * @property {number|null} [MsgSeq] MsgItem MsgSeq
         * @property {number|Long|null} [MsgUid] MsgItem MsgUid
         * @property {Uint8Array|null} [Sig] MsgItem Sig
         */

        /**
         * Constructs a new MsgItem.
         * @memberof Msg
         * @classdesc Represents a MsgItem.
         * @implements IMsgItem
         * @constructor
         * @param {Msg.IMsgItem=} [properties] Properties to set
         */
        function MsgItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgItem FromUin.
         * @member {number|Long} FromUin
         * @memberof Msg.MsgItem
         * @instance
         */
        MsgItem.prototype.FromUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MsgItem ToUin.
         * @member {number|Long} ToUin
         * @memberof Msg.MsgItem
         * @instance
         */
        MsgItem.prototype.ToUin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MsgItem MsgType.
         * @member {number} MsgType
         * @memberof Msg.MsgItem
         * @instance
         */
        MsgItem.prototype.MsgType = 0;

        /**
         * MsgItem MsgSeq.
         * @member {number} MsgSeq
         * @memberof Msg.MsgItem
         * @instance
         */
        MsgItem.prototype.MsgSeq = 0;

        /**
         * MsgItem MsgUid.
         * @member {number|Long} MsgUid
         * @memberof Msg.MsgItem
         * @instance
         */
        MsgItem.prototype.MsgUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MsgItem Sig.
         * @member {Uint8Array} Sig
         * @memberof Msg.MsgItem
         * @instance
         */
        MsgItem.prototype.Sig = $util.newBuffer([]);

        /**
         * Creates a new MsgItem instance using the specified properties.
         * @function create
         * @memberof Msg.MsgItem
         * @static
         * @param {Msg.IMsgItem=} [properties] Properties to set
         * @returns {Msg.MsgItem} MsgItem instance
         */
        MsgItem.create = function create(properties) {
            return new MsgItem(properties);
        };

        /**
         * Encodes the specified MsgItem message. Does not implicitly {@link Msg.MsgItem.verify|verify} messages.
         * @function encode
         * @memberof Msg.MsgItem
         * @static
         * @param {Msg.IMsgItem} message MsgItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FromUin != null && Object.hasOwnProperty.call(message, "FromUin"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.FromUin);
            if (message.ToUin != null && Object.hasOwnProperty.call(message, "ToUin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ToUin);
            if (message.MsgType != null && Object.hasOwnProperty.call(message, "MsgType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MsgType);
            if (message.MsgSeq != null && Object.hasOwnProperty.call(message, "MsgSeq"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MsgSeq);
            if (message.MsgUid != null && Object.hasOwnProperty.call(message, "MsgUid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.MsgUid);
            if (message.Sig != null && Object.hasOwnProperty.call(message, "Sig"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.Sig);
            return writer;
        };

        /**
         * Encodes the specified MsgItem message, length delimited. Does not implicitly {@link Msg.MsgItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.MsgItem
         * @static
         * @param {Msg.IMsgItem} message MsgItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgItem message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.MsgItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.MsgItem} MsgItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.MsgItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FromUin = reader.int64();
                    break;
                case 2:
                    message.ToUin = reader.int64();
                    break;
                case 3:
                    message.MsgType = reader.int32();
                    break;
                case 4:
                    message.MsgSeq = reader.int32();
                    break;
                case 5:
                    message.MsgUid = reader.int64();
                    break;
                case 7:
                    message.Sig = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.MsgItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.MsgItem} MsgItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgItem message.
         * @function verify
         * @memberof Msg.MsgItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                if (!$util.isInteger(message.FromUin) && !(message.FromUin && $util.isInteger(message.FromUin.low) && $util.isInteger(message.FromUin.high)))
                    return "FromUin: integer|Long expected";
            if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                if (!$util.isInteger(message.ToUin) && !(message.ToUin && $util.isInteger(message.ToUin.low) && $util.isInteger(message.ToUin.high)))
                    return "ToUin: integer|Long expected";
            if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                if (!$util.isInteger(message.MsgType))
                    return "MsgType: integer expected";
            if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                if (!$util.isInteger(message.MsgSeq))
                    return "MsgSeq: integer expected";
            if (message.MsgUid != null && message.hasOwnProperty("MsgUid"))
                if (!$util.isInteger(message.MsgUid) && !(message.MsgUid && $util.isInteger(message.MsgUid.low) && $util.isInteger(message.MsgUid.high)))
                    return "MsgUid: integer|Long expected";
            if (message.Sig != null && message.hasOwnProperty("Sig"))
                if (!(message.Sig && typeof message.Sig.length === "number" || $util.isString(message.Sig)))
                    return "Sig: buffer expected";
            return null;
        };

        /**
         * Creates a MsgItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.MsgItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.MsgItem} MsgItem
         */
        MsgItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.MsgItem)
                return object;
            var message = new $root.Msg.MsgItem();
            if (object.FromUin != null)
                if ($util.Long)
                    (message.FromUin = $util.Long.fromValue(object.FromUin)).unsigned = false;
                else if (typeof object.FromUin === "string")
                    message.FromUin = parseInt(object.FromUin, 10);
                else if (typeof object.FromUin === "number")
                    message.FromUin = object.FromUin;
                else if (typeof object.FromUin === "object")
                    message.FromUin = new $util.LongBits(object.FromUin.low >>> 0, object.FromUin.high >>> 0).toNumber();
            if (object.ToUin != null)
                if ($util.Long)
                    (message.ToUin = $util.Long.fromValue(object.ToUin)).unsigned = false;
                else if (typeof object.ToUin === "string")
                    message.ToUin = parseInt(object.ToUin, 10);
                else if (typeof object.ToUin === "number")
                    message.ToUin = object.ToUin;
                else if (typeof object.ToUin === "object")
                    message.ToUin = new $util.LongBits(object.ToUin.low >>> 0, object.ToUin.high >>> 0).toNumber();
            if (object.MsgType != null)
                message.MsgType = object.MsgType | 0;
            if (object.MsgSeq != null)
                message.MsgSeq = object.MsgSeq | 0;
            if (object.MsgUid != null)
                if ($util.Long)
                    (message.MsgUid = $util.Long.fromValue(object.MsgUid)).unsigned = false;
                else if (typeof object.MsgUid === "string")
                    message.MsgUid = parseInt(object.MsgUid, 10);
                else if (typeof object.MsgUid === "number")
                    message.MsgUid = object.MsgUid;
                else if (typeof object.MsgUid === "object")
                    message.MsgUid = new $util.LongBits(object.MsgUid.low >>> 0, object.MsgUid.high >>> 0).toNumber();
            if (object.Sig != null)
                if (typeof object.Sig === "string")
                    $util.base64.decode(object.Sig, message.Sig = $util.newBuffer($util.base64.length(object.Sig)), 0);
                else if (object.Sig.length)
                    message.Sig = object.Sig;
            return message;
        };

        /**
         * Creates a plain object from a MsgItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.MsgItem
         * @static
         * @param {Msg.MsgItem} message MsgItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.FromUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.FromUin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.ToUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ToUin = options.longs === String ? "0" : 0;
                object.MsgType = 0;
                object.MsgSeq = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.MsgUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.MsgUid = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.Sig = "";
                else {
                    object.Sig = [];
                    if (options.bytes !== Array)
                        object.Sig = $util.newBuffer(object.Sig);
                }
            }
            if (message.FromUin != null && message.hasOwnProperty("FromUin"))
                if (typeof message.FromUin === "number")
                    object.FromUin = options.longs === String ? String(message.FromUin) : message.FromUin;
                else
                    object.FromUin = options.longs === String ? $util.Long.prototype.toString.call(message.FromUin) : options.longs === Number ? new $util.LongBits(message.FromUin.low >>> 0, message.FromUin.high >>> 0).toNumber() : message.FromUin;
            if (message.ToUin != null && message.hasOwnProperty("ToUin"))
                if (typeof message.ToUin === "number")
                    object.ToUin = options.longs === String ? String(message.ToUin) : message.ToUin;
                else
                    object.ToUin = options.longs === String ? $util.Long.prototype.toString.call(message.ToUin) : options.longs === Number ? new $util.LongBits(message.ToUin.low >>> 0, message.ToUin.high >>> 0).toNumber() : message.ToUin;
            if (message.MsgType != null && message.hasOwnProperty("MsgType"))
                object.MsgType = message.MsgType;
            if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                object.MsgSeq = message.MsgSeq;
            if (message.MsgUid != null && message.hasOwnProperty("MsgUid"))
                if (typeof message.MsgUid === "number")
                    object.MsgUid = options.longs === String ? String(message.MsgUid) : message.MsgUid;
                else
                    object.MsgUid = options.longs === String ? $util.Long.prototype.toString.call(message.MsgUid) : options.longs === Number ? new $util.LongBits(message.MsgUid.low >>> 0, message.MsgUid.high >>> 0).toNumber() : message.MsgUid;
            if (message.Sig != null && message.hasOwnProperty("Sig"))
                object.Sig = options.bytes === String ? $util.base64.encode(message.Sig, 0, message.Sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.Sig) : message.Sig;
            return object;
        };

        /**
         * Converts this MsgItem to JSON.
         * @function toJSON
         * @memberof Msg.MsgItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgItem;
    })();

    Msg.PbDeleteMsgResp = (function() {

        /**
         * Properties of a PbDeleteMsgResp.
         * @memberof Msg
         * @interface IPbDeleteMsgResp
         * @property {number|null} [Result] PbDeleteMsgResp Result
         * @property {string|null} [ErrorMsg] PbDeleteMsgResp ErrorMsg
         */

        /**
         * Constructs a new PbDeleteMsgResp.
         * @memberof Msg
         * @classdesc Represents a PbDeleteMsgResp.
         * @implements IPbDeleteMsgResp
         * @constructor
         * @param {Msg.IPbDeleteMsgResp=} [properties] Properties to set
         */
        function PbDeleteMsgResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbDeleteMsgResp Result.
         * @member {number} Result
         * @memberof Msg.PbDeleteMsgResp
         * @instance
         */
        PbDeleteMsgResp.prototype.Result = 0;

        /**
         * PbDeleteMsgResp ErrorMsg.
         * @member {string} ErrorMsg
         * @memberof Msg.PbDeleteMsgResp
         * @instance
         */
        PbDeleteMsgResp.prototype.ErrorMsg = "";

        /**
         * Creates a new PbDeleteMsgResp instance using the specified properties.
         * @function create
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {Msg.IPbDeleteMsgResp=} [properties] Properties to set
         * @returns {Msg.PbDeleteMsgResp} PbDeleteMsgResp instance
         */
        PbDeleteMsgResp.create = function create(properties) {
            return new PbDeleteMsgResp(properties);
        };

        /**
         * Encodes the specified PbDeleteMsgResp message. Does not implicitly {@link Msg.PbDeleteMsgResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {Msg.IPbDeleteMsgResp} message PbDeleteMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbDeleteMsgResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && Object.hasOwnProperty.call(message, "Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            if (message.ErrorMsg != null && Object.hasOwnProperty.call(message, "ErrorMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ErrorMsg);
            return writer;
        };

        /**
         * Encodes the specified PbDeleteMsgResp message, length delimited. Does not implicitly {@link Msg.PbDeleteMsgResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {Msg.IPbDeleteMsgResp} message PbDeleteMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbDeleteMsgResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbDeleteMsgResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbDeleteMsgResp} PbDeleteMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbDeleteMsgResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbDeleteMsgResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                case 2:
                    message.ErrorMsg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbDeleteMsgResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbDeleteMsgResp} PbDeleteMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbDeleteMsgResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbDeleteMsgResp message.
         * @function verify
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbDeleteMsgResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Result != null && message.hasOwnProperty("Result"))
                if (!$util.isInteger(message.Result))
                    return "Result: integer expected";
            if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg"))
                if (!$util.isString(message.ErrorMsg))
                    return "ErrorMsg: string expected";
            return null;
        };

        /**
         * Creates a PbDeleteMsgResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbDeleteMsgResp} PbDeleteMsgResp
         */
        PbDeleteMsgResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbDeleteMsgResp)
                return object;
            var message = new $root.Msg.PbDeleteMsgResp();
            if (object.Result != null)
                message.Result = object.Result | 0;
            if (object.ErrorMsg != null)
                message.ErrorMsg = String(object.ErrorMsg);
            return message;
        };

        /**
         * Creates a plain object from a PbDeleteMsgResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbDeleteMsgResp
         * @static
         * @param {Msg.PbDeleteMsgResp} message PbDeleteMsgResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbDeleteMsgResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Result = 0;
                object.ErrorMsg = "";
            }
            if (message.Result != null && message.hasOwnProperty("Result"))
                object.Result = message.Result;
            if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg"))
                object.ErrorMsg = message.ErrorMsg;
            return object;
        };

        /**
         * Converts this PbDeleteMsgResp to JSON.
         * @function toJSON
         * @memberof Msg.PbDeleteMsgResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbDeleteMsgResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbDeleteMsgResp;
    })();

    Msg.PbDeleteMsgReq = (function() {

        /**
         * Properties of a PbDeleteMsgReq.
         * @memberof Msg
         * @interface IPbDeleteMsgReq
         * @property {Array.<Msg.IMsgItem>|null} [MsgList] PbDeleteMsgReq MsgList
         */

        /**
         * Constructs a new PbDeleteMsgReq.
         * @memberof Msg
         * @classdesc Represents a PbDeleteMsgReq.
         * @implements IPbDeleteMsgReq
         * @constructor
         * @param {Msg.IPbDeleteMsgReq=} [properties] Properties to set
         */
        function PbDeleteMsgReq(properties) {
            this.MsgList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbDeleteMsgReq MsgList.
         * @member {Array.<Msg.IMsgItem>} MsgList
         * @memberof Msg.PbDeleteMsgReq
         * @instance
         */
        PbDeleteMsgReq.prototype.MsgList = $util.emptyArray;

        /**
         * Creates a new PbDeleteMsgReq instance using the specified properties.
         * @function create
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {Msg.IPbDeleteMsgReq=} [properties] Properties to set
         * @returns {Msg.PbDeleteMsgReq} PbDeleteMsgReq instance
         */
        PbDeleteMsgReq.create = function create(properties) {
            return new PbDeleteMsgReq(properties);
        };

        /**
         * Encodes the specified PbDeleteMsgReq message. Does not implicitly {@link Msg.PbDeleteMsgReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {Msg.IPbDeleteMsgReq} message PbDeleteMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbDeleteMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MsgList != null && message.MsgList.length)
                for (var i = 0; i < message.MsgList.length; ++i)
                    $root.Msg.MsgItem.encode(message.MsgList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PbDeleteMsgReq message, length delimited. Does not implicitly {@link Msg.PbDeleteMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {Msg.IPbDeleteMsgReq} message PbDeleteMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbDeleteMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbDeleteMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbDeleteMsgReq} PbDeleteMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbDeleteMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbDeleteMsgReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.MsgList && message.MsgList.length))
                        message.MsgList = [];
                    message.MsgList.push($root.Msg.MsgItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbDeleteMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbDeleteMsgReq} PbDeleteMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbDeleteMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbDeleteMsgReq message.
         * @function verify
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbDeleteMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MsgList != null && message.hasOwnProperty("MsgList")) {
                if (!Array.isArray(message.MsgList))
                    return "MsgList: array expected";
                for (var i = 0; i < message.MsgList.length; ++i) {
                    var error = $root.Msg.MsgItem.verify(message.MsgList[i]);
                    if (error)
                        return "MsgList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PbDeleteMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbDeleteMsgReq} PbDeleteMsgReq
         */
        PbDeleteMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbDeleteMsgReq)
                return object;
            var message = new $root.Msg.PbDeleteMsgReq();
            if (object.MsgList) {
                if (!Array.isArray(object.MsgList))
                    throw TypeError(".Msg.PbDeleteMsgReq.MsgList: array expected");
                message.MsgList = [];
                for (var i = 0; i < object.MsgList.length; ++i) {
                    if (typeof object.MsgList[i] !== "object")
                        throw TypeError(".Msg.PbDeleteMsgReq.MsgList: object expected");
                    message.MsgList[i] = $root.Msg.MsgItem.fromObject(object.MsgList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PbDeleteMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbDeleteMsgReq
         * @static
         * @param {Msg.PbDeleteMsgReq} message PbDeleteMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbDeleteMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.MsgList = [];
            if (message.MsgList && message.MsgList.length) {
                object.MsgList = [];
                for (var j = 0; j < message.MsgList.length; ++j)
                    object.MsgList[j] = $root.Msg.MsgItem.toObject(message.MsgList[j], options);
            }
            return object;
        };

        /**
         * Converts this PbDeleteMsgReq to JSON.
         * @function toJSON
         * @memberof Msg.PbDeleteMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbDeleteMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbDeleteMsgReq;
    })();

    Msg.PbPushGroupMsg = (function() {

        /**
         * Properties of a PbPushGroupMsg.
         * @memberof Msg
         * @interface IPbPushGroupMsg
         * @property {Msg.MsgField.IMsg|null} [Msg] PbPushGroupMsg Msg
         * @property {number|null} [Svrip] PbPushGroupMsg Svrip
         * @property {Uint8Array|null} [PushToken] PbPushGroupMsg PushToken
         * @property {number|null} [PingFlag] PbPushGroupMsg PingFlag
         * @property {number|null} [GeneralFlag] PbPushGroupMsg GeneralFlag
         */

        /**
         * Constructs a new PbPushGroupMsg.
         * @memberof Msg
         * @classdesc Represents a PbPushGroupMsg.
         * @implements IPbPushGroupMsg
         * @constructor
         * @param {Msg.IPbPushGroupMsg=} [properties] Properties to set
         */
        function PbPushGroupMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbPushGroupMsg Msg.
         * @member {Msg.MsgField.IMsg|null|undefined} Msg
         * @memberof Msg.PbPushGroupMsg
         * @instance
         */
        PbPushGroupMsg.prototype.Msg = null;

        /**
         * PbPushGroupMsg Svrip.
         * @member {number} Svrip
         * @memberof Msg.PbPushGroupMsg
         * @instance
         */
        PbPushGroupMsg.prototype.Svrip = 0;

        /**
         * PbPushGroupMsg PushToken.
         * @member {Uint8Array} PushToken
         * @memberof Msg.PbPushGroupMsg
         * @instance
         */
        PbPushGroupMsg.prototype.PushToken = $util.newBuffer([]);

        /**
         * PbPushGroupMsg PingFlag.
         * @member {number} PingFlag
         * @memberof Msg.PbPushGroupMsg
         * @instance
         */
        PbPushGroupMsg.prototype.PingFlag = 0;

        /**
         * PbPushGroupMsg GeneralFlag.
         * @member {number} GeneralFlag
         * @memberof Msg.PbPushGroupMsg
         * @instance
         */
        PbPushGroupMsg.prototype.GeneralFlag = 0;

        /**
         * Creates a new PbPushGroupMsg instance using the specified properties.
         * @function create
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {Msg.IPbPushGroupMsg=} [properties] Properties to set
         * @returns {Msg.PbPushGroupMsg} PbPushGroupMsg instance
         */
        PbPushGroupMsg.create = function create(properties) {
            return new PbPushGroupMsg(properties);
        };

        /**
         * Encodes the specified PbPushGroupMsg message. Does not implicitly {@link Msg.PbPushGroupMsg.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {Msg.IPbPushGroupMsg} message PbPushGroupMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbPushGroupMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Msg != null && Object.hasOwnProperty.call(message, "Msg"))
                $root.Msg.MsgField.Msg.encode(message.Msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Svrip != null && Object.hasOwnProperty.call(message, "Svrip"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Svrip);
            if (message.PushToken != null && Object.hasOwnProperty.call(message, "PushToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.PushToken);
            if (message.PingFlag != null && Object.hasOwnProperty.call(message, "PingFlag"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.PingFlag);
            if (message.GeneralFlag != null && Object.hasOwnProperty.call(message, "GeneralFlag"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.GeneralFlag);
            return writer;
        };

        /**
         * Encodes the specified PbPushGroupMsg message, length delimited. Does not implicitly {@link Msg.PbPushGroupMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {Msg.IPbPushGroupMsg} message PbPushGroupMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbPushGroupMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbPushGroupMsg message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbPushGroupMsg} PbPushGroupMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbPushGroupMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbPushGroupMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Msg = $root.Msg.MsgField.Msg.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.Svrip = reader.int32();
                    break;
                case 3:
                    message.PushToken = reader.bytes();
                    break;
                case 4:
                    message.PingFlag = reader.int32();
                    break;
                case 5:
                    message.GeneralFlag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbPushGroupMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbPushGroupMsg} PbPushGroupMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbPushGroupMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbPushGroupMsg message.
         * @function verify
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbPushGroupMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Msg != null && message.hasOwnProperty("Msg")) {
                var error = $root.Msg.MsgField.Msg.verify(message.Msg);
                if (error)
                    return "Msg." + error;
            }
            if (message.Svrip != null && message.hasOwnProperty("Svrip"))
                if (!$util.isInteger(message.Svrip))
                    return "Svrip: integer expected";
            if (message.PushToken != null && message.hasOwnProperty("PushToken"))
                if (!(message.PushToken && typeof message.PushToken.length === "number" || $util.isString(message.PushToken)))
                    return "PushToken: buffer expected";
            if (message.PingFlag != null && message.hasOwnProperty("PingFlag"))
                if (!$util.isInteger(message.PingFlag))
                    return "PingFlag: integer expected";
            if (message.GeneralFlag != null && message.hasOwnProperty("GeneralFlag"))
                if (!$util.isInteger(message.GeneralFlag))
                    return "GeneralFlag: integer expected";
            return null;
        };

        /**
         * Creates a PbPushGroupMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbPushGroupMsg} PbPushGroupMsg
         */
        PbPushGroupMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbPushGroupMsg)
                return object;
            var message = new $root.Msg.PbPushGroupMsg();
            if (object.Msg != null) {
                if (typeof object.Msg !== "object")
                    throw TypeError(".Msg.PbPushGroupMsg.Msg: object expected");
                message.Msg = $root.Msg.MsgField.Msg.fromObject(object.Msg);
            }
            if (object.Svrip != null)
                message.Svrip = object.Svrip | 0;
            if (object.PushToken != null)
                if (typeof object.PushToken === "string")
                    $util.base64.decode(object.PushToken, message.PushToken = $util.newBuffer($util.base64.length(object.PushToken)), 0);
                else if (object.PushToken.length)
                    message.PushToken = object.PushToken;
            if (object.PingFlag != null)
                message.PingFlag = object.PingFlag | 0;
            if (object.GeneralFlag != null)
                message.GeneralFlag = object.GeneralFlag | 0;
            return message;
        };

        /**
         * Creates a plain object from a PbPushGroupMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbPushGroupMsg
         * @static
         * @param {Msg.PbPushGroupMsg} message PbPushGroupMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbPushGroupMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Msg = null;
                object.Svrip = 0;
                if (options.bytes === String)
                    object.PushToken = "";
                else {
                    object.PushToken = [];
                    if (options.bytes !== Array)
                        object.PushToken = $util.newBuffer(object.PushToken);
                }
                object.PingFlag = 0;
                object.GeneralFlag = 0;
            }
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                object.Msg = $root.Msg.MsgField.Msg.toObject(message.Msg, options);
            if (message.Svrip != null && message.hasOwnProperty("Svrip"))
                object.Svrip = message.Svrip;
            if (message.PushToken != null && message.hasOwnProperty("PushToken"))
                object.PushToken = options.bytes === String ? $util.base64.encode(message.PushToken, 0, message.PushToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.PushToken) : message.PushToken;
            if (message.PingFlag != null && message.hasOwnProperty("PingFlag"))
                object.PingFlag = message.PingFlag;
            if (message.GeneralFlag != null && message.hasOwnProperty("GeneralFlag"))
                object.GeneralFlag = message.GeneralFlag;
            return object;
        };

        /**
         * Converts this PbPushGroupMsg to JSON.
         * @function toJSON
         * @memberof Msg.PbPushGroupMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbPushGroupMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbPushGroupMsg;
    })();

    Msg.PbSendMsgResp = (function() {

        /**
         * Properties of a PbSendMsgResp.
         * @memberof Msg
         * @interface IPbSendMsgResp
         * @property {number|null} [Result] PbSendMsgResp Result
         * @property {string|null} [ErrorMsg] PbSendMsgResp ErrorMsg
         * @property {number|null} [SendTime] PbSendMsgResp SendTime
         * @property {number|null} [SvrbusyWaitTime] PbSendMsgResp SvrbusyWaitTime
         * @property {Msg.MsgField.IMsgSendInfo|null} [MsgSendInfo] PbSendMsgResp MsgSendInfo
         * @property {number|null} [ErrType] PbSendMsgResp ErrType
         * @property {Msg.MsgField.ITransSvrInfo|null} [TransSvrInfo] PbSendMsgResp TransSvrInfo
         * @property {Msg.MsgField.ImReceipt.IReceiptResp|null} [ReceiptResp] PbSendMsgResp ReceiptResp
         * @property {number|null} [TextAnalysisResult] PbSendMsgResp TextAnalysisResult
         */

        /**
         * Constructs a new PbSendMsgResp.
         * @memberof Msg
         * @classdesc Represents a PbSendMsgResp.
         * @implements IPbSendMsgResp
         * @constructor
         * @param {Msg.IPbSendMsgResp=} [properties] Properties to set
         */
        function PbSendMsgResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbSendMsgResp Result.
         * @member {number} Result
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.Result = 0;

        /**
         * PbSendMsgResp ErrorMsg.
         * @member {string} ErrorMsg
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.ErrorMsg = "";

        /**
         * PbSendMsgResp SendTime.
         * @member {number} SendTime
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.SendTime = 0;

        /**
         * PbSendMsgResp SvrbusyWaitTime.
         * @member {number} SvrbusyWaitTime
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.SvrbusyWaitTime = 0;

        /**
         * PbSendMsgResp MsgSendInfo.
         * @member {Msg.MsgField.IMsgSendInfo|null|undefined} MsgSendInfo
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.MsgSendInfo = null;

        /**
         * PbSendMsgResp ErrType.
         * @member {number} ErrType
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.ErrType = 0;

        /**
         * PbSendMsgResp TransSvrInfo.
         * @member {Msg.MsgField.ITransSvrInfo|null|undefined} TransSvrInfo
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.TransSvrInfo = null;

        /**
         * PbSendMsgResp ReceiptResp.
         * @member {Msg.MsgField.ImReceipt.IReceiptResp|null|undefined} ReceiptResp
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.ReceiptResp = null;

        /**
         * PbSendMsgResp TextAnalysisResult.
         * @member {number} TextAnalysisResult
         * @memberof Msg.PbSendMsgResp
         * @instance
         */
        PbSendMsgResp.prototype.TextAnalysisResult = 0;

        /**
         * Creates a new PbSendMsgResp instance using the specified properties.
         * @function create
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {Msg.IPbSendMsgResp=} [properties] Properties to set
         * @returns {Msg.PbSendMsgResp} PbSendMsgResp instance
         */
        PbSendMsgResp.create = function create(properties) {
            return new PbSendMsgResp(properties);
        };

        /**
         * Encodes the specified PbSendMsgResp message. Does not implicitly {@link Msg.PbSendMsgResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {Msg.IPbSendMsgResp} message PbSendMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbSendMsgResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && Object.hasOwnProperty.call(message, "Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            if (message.ErrorMsg != null && Object.hasOwnProperty.call(message, "ErrorMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ErrorMsg);
            if (message.SendTime != null && Object.hasOwnProperty.call(message, "SendTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.SendTime);
            if (message.SvrbusyWaitTime != null && Object.hasOwnProperty.call(message, "SvrbusyWaitTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.SvrbusyWaitTime);
            if (message.MsgSendInfo != null && Object.hasOwnProperty.call(message, "MsgSendInfo"))
                $root.Msg.MsgField.MsgSendInfo.encode(message.MsgSendInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.ErrType != null && Object.hasOwnProperty.call(message, "ErrType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.ErrType);
            if (message.TransSvrInfo != null && Object.hasOwnProperty.call(message, "TransSvrInfo"))
                $root.Msg.MsgField.TransSvrInfo.encode(message.TransSvrInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.ReceiptResp != null && Object.hasOwnProperty.call(message, "ReceiptResp"))
                $root.Msg.MsgField.ImReceipt.ReceiptResp.encode(message.ReceiptResp, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.TextAnalysisResult != null && Object.hasOwnProperty.call(message, "TextAnalysisResult"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.TextAnalysisResult);
            return writer;
        };

        /**
         * Encodes the specified PbSendMsgResp message, length delimited. Does not implicitly {@link Msg.PbSendMsgResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {Msg.IPbSendMsgResp} message PbSendMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbSendMsgResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbSendMsgResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbSendMsgResp} PbSendMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbSendMsgResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbSendMsgResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                case 2:
                    message.ErrorMsg = reader.string();
                    break;
                case 3:
                    message.SendTime = reader.int32();
                    break;
                case 4:
                    message.SvrbusyWaitTime = reader.int32();
                    break;
                case 5:
                    message.MsgSendInfo = $root.Msg.MsgField.MsgSendInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.ErrType = reader.int32();
                    break;
                case 7:
                    message.TransSvrInfo = $root.Msg.MsgField.TransSvrInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.ReceiptResp = $root.Msg.MsgField.ImReceipt.ReceiptResp.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.TextAnalysisResult = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbSendMsgResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbSendMsgResp} PbSendMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbSendMsgResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbSendMsgResp message.
         * @function verify
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbSendMsgResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Result != null && message.hasOwnProperty("Result"))
                if (!$util.isInteger(message.Result))
                    return "Result: integer expected";
            if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg"))
                if (!$util.isString(message.ErrorMsg))
                    return "ErrorMsg: string expected";
            if (message.SendTime != null && message.hasOwnProperty("SendTime"))
                if (!$util.isInteger(message.SendTime))
                    return "SendTime: integer expected";
            if (message.SvrbusyWaitTime != null && message.hasOwnProperty("SvrbusyWaitTime"))
                if (!$util.isInteger(message.SvrbusyWaitTime))
                    return "SvrbusyWaitTime: integer expected";
            if (message.MsgSendInfo != null && message.hasOwnProperty("MsgSendInfo")) {
                var error = $root.Msg.MsgField.MsgSendInfo.verify(message.MsgSendInfo);
                if (error)
                    return "MsgSendInfo." + error;
            }
            if (message.ErrType != null && message.hasOwnProperty("ErrType"))
                if (!$util.isInteger(message.ErrType))
                    return "ErrType: integer expected";
            if (message.TransSvrInfo != null && message.hasOwnProperty("TransSvrInfo")) {
                var error = $root.Msg.MsgField.TransSvrInfo.verify(message.TransSvrInfo);
                if (error)
                    return "TransSvrInfo." + error;
            }
            if (message.ReceiptResp != null && message.hasOwnProperty("ReceiptResp")) {
                var error = $root.Msg.MsgField.ImReceipt.ReceiptResp.verify(message.ReceiptResp);
                if (error)
                    return "ReceiptResp." + error;
            }
            if (message.TextAnalysisResult != null && message.hasOwnProperty("TextAnalysisResult"))
                if (!$util.isInteger(message.TextAnalysisResult))
                    return "TextAnalysisResult: integer expected";
            return null;
        };

        /**
         * Creates a PbSendMsgResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbSendMsgResp} PbSendMsgResp
         */
        PbSendMsgResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbSendMsgResp)
                return object;
            var message = new $root.Msg.PbSendMsgResp();
            if (object.Result != null)
                message.Result = object.Result | 0;
            if (object.ErrorMsg != null)
                message.ErrorMsg = String(object.ErrorMsg);
            if (object.SendTime != null)
                message.SendTime = object.SendTime | 0;
            if (object.SvrbusyWaitTime != null)
                message.SvrbusyWaitTime = object.SvrbusyWaitTime | 0;
            if (object.MsgSendInfo != null) {
                if (typeof object.MsgSendInfo !== "object")
                    throw TypeError(".Msg.PbSendMsgResp.MsgSendInfo: object expected");
                message.MsgSendInfo = $root.Msg.MsgField.MsgSendInfo.fromObject(object.MsgSendInfo);
            }
            if (object.ErrType != null)
                message.ErrType = object.ErrType | 0;
            if (object.TransSvrInfo != null) {
                if (typeof object.TransSvrInfo !== "object")
                    throw TypeError(".Msg.PbSendMsgResp.TransSvrInfo: object expected");
                message.TransSvrInfo = $root.Msg.MsgField.TransSvrInfo.fromObject(object.TransSvrInfo);
            }
            if (object.ReceiptResp != null) {
                if (typeof object.ReceiptResp !== "object")
                    throw TypeError(".Msg.PbSendMsgResp.ReceiptResp: object expected");
                message.ReceiptResp = $root.Msg.MsgField.ImReceipt.ReceiptResp.fromObject(object.ReceiptResp);
            }
            if (object.TextAnalysisResult != null)
                message.TextAnalysisResult = object.TextAnalysisResult | 0;
            return message;
        };

        /**
         * Creates a plain object from a PbSendMsgResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbSendMsgResp
         * @static
         * @param {Msg.PbSendMsgResp} message PbSendMsgResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbSendMsgResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Result = 0;
                object.ErrorMsg = "";
                object.SendTime = 0;
                object.SvrbusyWaitTime = 0;
                object.MsgSendInfo = null;
                object.ErrType = 0;
                object.TransSvrInfo = null;
                object.ReceiptResp = null;
                object.TextAnalysisResult = 0;
            }
            if (message.Result != null && message.hasOwnProperty("Result"))
                object.Result = message.Result;
            if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg"))
                object.ErrorMsg = message.ErrorMsg;
            if (message.SendTime != null && message.hasOwnProperty("SendTime"))
                object.SendTime = message.SendTime;
            if (message.SvrbusyWaitTime != null && message.hasOwnProperty("SvrbusyWaitTime"))
                object.SvrbusyWaitTime = message.SvrbusyWaitTime;
            if (message.MsgSendInfo != null && message.hasOwnProperty("MsgSendInfo"))
                object.MsgSendInfo = $root.Msg.MsgField.MsgSendInfo.toObject(message.MsgSendInfo, options);
            if (message.ErrType != null && message.hasOwnProperty("ErrType"))
                object.ErrType = message.ErrType;
            if (message.TransSvrInfo != null && message.hasOwnProperty("TransSvrInfo"))
                object.TransSvrInfo = $root.Msg.MsgField.TransSvrInfo.toObject(message.TransSvrInfo, options);
            if (message.ReceiptResp != null && message.hasOwnProperty("ReceiptResp"))
                object.ReceiptResp = $root.Msg.MsgField.ImReceipt.ReceiptResp.toObject(message.ReceiptResp, options);
            if (message.TextAnalysisResult != null && message.hasOwnProperty("TextAnalysisResult"))
                object.TextAnalysisResult = message.TextAnalysisResult;
            return object;
        };

        /**
         * Converts this PbSendMsgResp to JSON.
         * @function toJSON
         * @memberof Msg.PbSendMsgResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbSendMsgResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbSendMsgResp;
    })();

    Msg.PbSendMsg = (function() {

        /**
         * Properties of a PbSendMsg.
         * @memberof Msg
         * @interface IPbSendMsg
         * @property {Msg.MsgField.IRoutingHead|null} [RoutingHead] PbSendMsg RoutingHead
         * @property {Msg.MsgField.IContentHead|null} [ContentHead] PbSendMsg ContentHead
         * @property {Msg.MsgField.ImMsgBody.IMsgBody|null} [MsgBody] PbSendMsg MsgBody
         * @property {number|null} [MsgSeq] PbSendMsg MsgSeq
         * @property {number|null} [MsgRand] PbSendMsg MsgRand
         * @property {Uint8Array|null} [SyncCookie] PbSendMsg SyncCookie
         * @property {Msg.MsgField.IAppShareInfo|null} [AppShare] PbSendMsg AppShare
         * @property {number|null} [MsgVia] PbSendMsg MsgVia
         * @property {number|null} [DataStatist] PbSendMsg DataStatist
         * @property {Msg.MsgField.IMultiMsgAssist|null} [MultiMsgAssist] PbSendMsg MultiMsgAssist
         * @property {Msg.MsgField.IPbInputNotifyInfo|null} [PbInputNotifyInfo] PbSendMsg PbInputNotifyInfo
         * @property {Msg.MsgField.IMsgCtrl|null} [MsgCtrl] PbSendMsg MsgCtrl
         * @property {Msg.MsgField.ImReceipt.IReceiptReq|null} [ReceiptReq] PbSendMsg ReceiptReq
         * @property {number|null} [MultiSendSeq] PbSendMsg MultiSendSeq
         */

        /**
         * Constructs a new PbSendMsg.
         * @memberof Msg
         * @classdesc Represents a PbSendMsg.
         * @implements IPbSendMsg
         * @constructor
         * @param {Msg.IPbSendMsg=} [properties] Properties to set
         */
        function PbSendMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbSendMsg RoutingHead.
         * @member {Msg.MsgField.IRoutingHead|null|undefined} RoutingHead
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.RoutingHead = null;

        /**
         * PbSendMsg ContentHead.
         * @member {Msg.MsgField.IContentHead|null|undefined} ContentHead
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.ContentHead = null;

        /**
         * PbSendMsg MsgBody.
         * @member {Msg.MsgField.ImMsgBody.IMsgBody|null|undefined} MsgBody
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.MsgBody = null;

        /**
         * PbSendMsg MsgSeq.
         * @member {number} MsgSeq
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.MsgSeq = 0;

        /**
         * PbSendMsg MsgRand.
         * @member {number} MsgRand
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.MsgRand = 0;

        /**
         * PbSendMsg SyncCookie.
         * @member {Uint8Array} SyncCookie
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.SyncCookie = $util.newBuffer([]);

        /**
         * PbSendMsg AppShare.
         * @member {Msg.MsgField.IAppShareInfo|null|undefined} AppShare
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.AppShare = null;

        /**
         * PbSendMsg MsgVia.
         * @member {number} MsgVia
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.MsgVia = 0;

        /**
         * PbSendMsg DataStatist.
         * @member {number} DataStatist
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.DataStatist = 0;

        /**
         * PbSendMsg MultiMsgAssist.
         * @member {Msg.MsgField.IMultiMsgAssist|null|undefined} MultiMsgAssist
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.MultiMsgAssist = null;

        /**
         * PbSendMsg PbInputNotifyInfo.
         * @member {Msg.MsgField.IPbInputNotifyInfo|null|undefined} PbInputNotifyInfo
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.PbInputNotifyInfo = null;

        /**
         * PbSendMsg MsgCtrl.
         * @member {Msg.MsgField.IMsgCtrl|null|undefined} MsgCtrl
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.MsgCtrl = null;

        /**
         * PbSendMsg ReceiptReq.
         * @member {Msg.MsgField.ImReceipt.IReceiptReq|null|undefined} ReceiptReq
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.ReceiptReq = null;

        /**
         * PbSendMsg MultiSendSeq.
         * @member {number} MultiSendSeq
         * @memberof Msg.PbSendMsg
         * @instance
         */
        PbSendMsg.prototype.MultiSendSeq = 0;

        /**
         * Creates a new PbSendMsg instance using the specified properties.
         * @function create
         * @memberof Msg.PbSendMsg
         * @static
         * @param {Msg.IPbSendMsg=} [properties] Properties to set
         * @returns {Msg.PbSendMsg} PbSendMsg instance
         */
        PbSendMsg.create = function create(properties) {
            return new PbSendMsg(properties);
        };

        /**
         * Encodes the specified PbSendMsg message. Does not implicitly {@link Msg.PbSendMsg.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbSendMsg
         * @static
         * @param {Msg.IPbSendMsg} message PbSendMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbSendMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RoutingHead != null && Object.hasOwnProperty.call(message, "RoutingHead"))
                $root.Msg.MsgField.RoutingHead.encode(message.RoutingHead, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ContentHead != null && Object.hasOwnProperty.call(message, "ContentHead"))
                $root.Msg.MsgField.ContentHead.encode(message.ContentHead, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.MsgBody != null && Object.hasOwnProperty.call(message, "MsgBody"))
                $root.Msg.MsgField.ImMsgBody.MsgBody.encode(message.MsgBody, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.MsgSeq != null && Object.hasOwnProperty.call(message, "MsgSeq"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MsgSeq);
            if (message.MsgRand != null && Object.hasOwnProperty.call(message, "MsgRand"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.MsgRand);
            if (message.SyncCookie != null && Object.hasOwnProperty.call(message, "SyncCookie"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.SyncCookie);
            if (message.AppShare != null && Object.hasOwnProperty.call(message, "AppShare"))
                $root.Msg.MsgField.AppShareInfo.encode(message.AppShare, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.MsgVia != null && Object.hasOwnProperty.call(message, "MsgVia"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.MsgVia);
            if (message.DataStatist != null && Object.hasOwnProperty.call(message, "DataStatist"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.DataStatist);
            if (message.MultiMsgAssist != null && Object.hasOwnProperty.call(message, "MultiMsgAssist"))
                $root.Msg.MsgField.MultiMsgAssist.encode(message.MultiMsgAssist, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.PbInputNotifyInfo != null && Object.hasOwnProperty.call(message, "PbInputNotifyInfo"))
                $root.Msg.MsgField.PbInputNotifyInfo.encode(message.PbInputNotifyInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.MsgCtrl != null && Object.hasOwnProperty.call(message, "MsgCtrl"))
                $root.Msg.MsgField.MsgCtrl.encode(message.MsgCtrl, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.ReceiptReq != null && Object.hasOwnProperty.call(message, "ReceiptReq"))
                $root.Msg.MsgField.ImReceipt.ReceiptReq.encode(message.ReceiptReq, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.MultiSendSeq != null && Object.hasOwnProperty.call(message, "MultiSendSeq"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.MultiSendSeq);
            return writer;
        };

        /**
         * Encodes the specified PbSendMsg message, length delimited. Does not implicitly {@link Msg.PbSendMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbSendMsg
         * @static
         * @param {Msg.IPbSendMsg} message PbSendMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbSendMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbSendMsg message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbSendMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbSendMsg} PbSendMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbSendMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbSendMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RoutingHead = $root.Msg.MsgField.RoutingHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ContentHead = $root.Msg.MsgField.ContentHead.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.MsgBody = $root.Msg.MsgField.ImMsgBody.MsgBody.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.MsgSeq = reader.int32();
                    break;
                case 5:
                    message.MsgRand = reader.int32();
                    break;
                case 6:
                    message.SyncCookie = reader.bytes();
                    break;
                case 7:
                    message.AppShare = $root.Msg.MsgField.AppShareInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.MsgVia = reader.int32();
                    break;
                case 9:
                    message.DataStatist = reader.int32();
                    break;
                case 10:
                    message.MultiMsgAssist = $root.Msg.MsgField.MultiMsgAssist.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.PbInputNotifyInfo = $root.Msg.MsgField.PbInputNotifyInfo.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.MsgCtrl = $root.Msg.MsgField.MsgCtrl.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.ReceiptReq = $root.Msg.MsgField.ImReceipt.ReceiptReq.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.MultiSendSeq = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbSendMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbSendMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbSendMsg} PbSendMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbSendMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbSendMsg message.
         * @function verify
         * @memberof Msg.PbSendMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbSendMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RoutingHead != null && message.hasOwnProperty("RoutingHead")) {
                var error = $root.Msg.MsgField.RoutingHead.verify(message.RoutingHead);
                if (error)
                    return "RoutingHead." + error;
            }
            if (message.ContentHead != null && message.hasOwnProperty("ContentHead")) {
                var error = $root.Msg.MsgField.ContentHead.verify(message.ContentHead);
                if (error)
                    return "ContentHead." + error;
            }
            if (message.MsgBody != null && message.hasOwnProperty("MsgBody")) {
                var error = $root.Msg.MsgField.ImMsgBody.MsgBody.verify(message.MsgBody);
                if (error)
                    return "MsgBody." + error;
            }
            if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                if (!$util.isInteger(message.MsgSeq))
                    return "MsgSeq: integer expected";
            if (message.MsgRand != null && message.hasOwnProperty("MsgRand"))
                if (!$util.isInteger(message.MsgRand))
                    return "MsgRand: integer expected";
            if (message.SyncCookie != null && message.hasOwnProperty("SyncCookie"))
                if (!(message.SyncCookie && typeof message.SyncCookie.length === "number" || $util.isString(message.SyncCookie)))
                    return "SyncCookie: buffer expected";
            if (message.AppShare != null && message.hasOwnProperty("AppShare")) {
                var error = $root.Msg.MsgField.AppShareInfo.verify(message.AppShare);
                if (error)
                    return "AppShare." + error;
            }
            if (message.MsgVia != null && message.hasOwnProperty("MsgVia"))
                if (!$util.isInteger(message.MsgVia))
                    return "MsgVia: integer expected";
            if (message.DataStatist != null && message.hasOwnProperty("DataStatist"))
                if (!$util.isInteger(message.DataStatist))
                    return "DataStatist: integer expected";
            if (message.MultiMsgAssist != null && message.hasOwnProperty("MultiMsgAssist")) {
                var error = $root.Msg.MsgField.MultiMsgAssist.verify(message.MultiMsgAssist);
                if (error)
                    return "MultiMsgAssist." + error;
            }
            if (message.PbInputNotifyInfo != null && message.hasOwnProperty("PbInputNotifyInfo")) {
                var error = $root.Msg.MsgField.PbInputNotifyInfo.verify(message.PbInputNotifyInfo);
                if (error)
                    return "PbInputNotifyInfo." + error;
            }
            if (message.MsgCtrl != null && message.hasOwnProperty("MsgCtrl")) {
                var error = $root.Msg.MsgField.MsgCtrl.verify(message.MsgCtrl);
                if (error)
                    return "MsgCtrl." + error;
            }
            if (message.ReceiptReq != null && message.hasOwnProperty("ReceiptReq")) {
                var error = $root.Msg.MsgField.ImReceipt.ReceiptReq.verify(message.ReceiptReq);
                if (error)
                    return "ReceiptReq." + error;
            }
            if (message.MultiSendSeq != null && message.hasOwnProperty("MultiSendSeq"))
                if (!$util.isInteger(message.MultiSendSeq))
                    return "MultiSendSeq: integer expected";
            return null;
        };

        /**
         * Creates a PbSendMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbSendMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbSendMsg} PbSendMsg
         */
        PbSendMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbSendMsg)
                return object;
            var message = new $root.Msg.PbSendMsg();
            if (object.RoutingHead != null) {
                if (typeof object.RoutingHead !== "object")
                    throw TypeError(".Msg.PbSendMsg.RoutingHead: object expected");
                message.RoutingHead = $root.Msg.MsgField.RoutingHead.fromObject(object.RoutingHead);
            }
            if (object.ContentHead != null) {
                if (typeof object.ContentHead !== "object")
                    throw TypeError(".Msg.PbSendMsg.ContentHead: object expected");
                message.ContentHead = $root.Msg.MsgField.ContentHead.fromObject(object.ContentHead);
            }
            if (object.MsgBody != null) {
                if (typeof object.MsgBody !== "object")
                    throw TypeError(".Msg.PbSendMsg.MsgBody: object expected");
                message.MsgBody = $root.Msg.MsgField.ImMsgBody.MsgBody.fromObject(object.MsgBody);
            }
            if (object.MsgSeq != null)
                message.MsgSeq = object.MsgSeq | 0;
            if (object.MsgRand != null)
                message.MsgRand = object.MsgRand | 0;
            if (object.SyncCookie != null)
                if (typeof object.SyncCookie === "string")
                    $util.base64.decode(object.SyncCookie, message.SyncCookie = $util.newBuffer($util.base64.length(object.SyncCookie)), 0);
                else if (object.SyncCookie.length)
                    message.SyncCookie = object.SyncCookie;
            if (object.AppShare != null) {
                if (typeof object.AppShare !== "object")
                    throw TypeError(".Msg.PbSendMsg.AppShare: object expected");
                message.AppShare = $root.Msg.MsgField.AppShareInfo.fromObject(object.AppShare);
            }
            if (object.MsgVia != null)
                message.MsgVia = object.MsgVia | 0;
            if (object.DataStatist != null)
                message.DataStatist = object.DataStatist | 0;
            if (object.MultiMsgAssist != null) {
                if (typeof object.MultiMsgAssist !== "object")
                    throw TypeError(".Msg.PbSendMsg.MultiMsgAssist: object expected");
                message.MultiMsgAssist = $root.Msg.MsgField.MultiMsgAssist.fromObject(object.MultiMsgAssist);
            }
            if (object.PbInputNotifyInfo != null) {
                if (typeof object.PbInputNotifyInfo !== "object")
                    throw TypeError(".Msg.PbSendMsg.PbInputNotifyInfo: object expected");
                message.PbInputNotifyInfo = $root.Msg.MsgField.PbInputNotifyInfo.fromObject(object.PbInputNotifyInfo);
            }
            if (object.MsgCtrl != null) {
                if (typeof object.MsgCtrl !== "object")
                    throw TypeError(".Msg.PbSendMsg.MsgCtrl: object expected");
                message.MsgCtrl = $root.Msg.MsgField.MsgCtrl.fromObject(object.MsgCtrl);
            }
            if (object.ReceiptReq != null) {
                if (typeof object.ReceiptReq !== "object")
                    throw TypeError(".Msg.PbSendMsg.ReceiptReq: object expected");
                message.ReceiptReq = $root.Msg.MsgField.ImReceipt.ReceiptReq.fromObject(object.ReceiptReq);
            }
            if (object.MultiSendSeq != null)
                message.MultiSendSeq = object.MultiSendSeq | 0;
            return message;
        };

        /**
         * Creates a plain object from a PbSendMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbSendMsg
         * @static
         * @param {Msg.PbSendMsg} message PbSendMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbSendMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.RoutingHead = null;
                object.ContentHead = null;
                object.MsgBody = null;
                object.MsgSeq = 0;
                object.MsgRand = 0;
                if (options.bytes === String)
                    object.SyncCookie = "";
                else {
                    object.SyncCookie = [];
                    if (options.bytes !== Array)
                        object.SyncCookie = $util.newBuffer(object.SyncCookie);
                }
                object.AppShare = null;
                object.MsgVia = 0;
                object.DataStatist = 0;
                object.MultiMsgAssist = null;
                object.PbInputNotifyInfo = null;
                object.MsgCtrl = null;
                object.ReceiptReq = null;
                object.MultiSendSeq = 0;
            }
            if (message.RoutingHead != null && message.hasOwnProperty("RoutingHead"))
                object.RoutingHead = $root.Msg.MsgField.RoutingHead.toObject(message.RoutingHead, options);
            if (message.ContentHead != null && message.hasOwnProperty("ContentHead"))
                object.ContentHead = $root.Msg.MsgField.ContentHead.toObject(message.ContentHead, options);
            if (message.MsgBody != null && message.hasOwnProperty("MsgBody"))
                object.MsgBody = $root.Msg.MsgField.ImMsgBody.MsgBody.toObject(message.MsgBody, options);
            if (message.MsgSeq != null && message.hasOwnProperty("MsgSeq"))
                object.MsgSeq = message.MsgSeq;
            if (message.MsgRand != null && message.hasOwnProperty("MsgRand"))
                object.MsgRand = message.MsgRand;
            if (message.SyncCookie != null && message.hasOwnProperty("SyncCookie"))
                object.SyncCookie = options.bytes === String ? $util.base64.encode(message.SyncCookie, 0, message.SyncCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.SyncCookie) : message.SyncCookie;
            if (message.AppShare != null && message.hasOwnProperty("AppShare"))
                object.AppShare = $root.Msg.MsgField.AppShareInfo.toObject(message.AppShare, options);
            if (message.MsgVia != null && message.hasOwnProperty("MsgVia"))
                object.MsgVia = message.MsgVia;
            if (message.DataStatist != null && message.hasOwnProperty("DataStatist"))
                object.DataStatist = message.DataStatist;
            if (message.MultiMsgAssist != null && message.hasOwnProperty("MultiMsgAssist"))
                object.MultiMsgAssist = $root.Msg.MsgField.MultiMsgAssist.toObject(message.MultiMsgAssist, options);
            if (message.PbInputNotifyInfo != null && message.hasOwnProperty("PbInputNotifyInfo"))
                object.PbInputNotifyInfo = $root.Msg.MsgField.PbInputNotifyInfo.toObject(message.PbInputNotifyInfo, options);
            if (message.MsgCtrl != null && message.hasOwnProperty("MsgCtrl"))
                object.MsgCtrl = $root.Msg.MsgField.MsgCtrl.toObject(message.MsgCtrl, options);
            if (message.ReceiptReq != null && message.hasOwnProperty("ReceiptReq"))
                object.ReceiptReq = $root.Msg.MsgField.ImReceipt.ReceiptReq.toObject(message.ReceiptReq, options);
            if (message.MultiSendSeq != null && message.hasOwnProperty("MultiSendSeq"))
                object.MultiSendSeq = message.MultiSendSeq;
            return object;
        };

        /**
         * Converts this PbSendMsg to JSON.
         * @function toJSON
         * @memberof Msg.PbSendMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbSendMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbSendMsg;
    })();

    Msg.PbGetMsgResp = (function() {

        /**
         * Properties of a PbGetMsgResp.
         * @memberof Msg
         * @interface IPbGetMsgResp
         * @property {number|null} [Result] PbGetMsgResp Result
         * @property {string|null} [ErrorMsg] PbGetMsgResp ErrorMsg
         * @property {Uint8Array|null} [SyncCookie] PbGetMsgResp SyncCookie
         * @property {Msg.SyncFlag|null} [Flag] PbGetMsgResp Flag
         * @property {Array.<Msg.MsgField.IUinPairMsg>|null} [UinPairMsgs] PbGetMsgResp UinPairMsgs
         * @property {number|Long|null} [Binduin] PbGetMsgResp Binduin
         * @property {number|null} [Msgrsptype] PbGetMsgResp Msgrsptype
         * @property {Uint8Array|null} [Pubaccountcookie] PbGetMsgResp Pubaccountcookie
         * @property {boolean|null} [Ispartialsync] PbGetMsgResp Ispartialsync
         * @property {Uint8Array|null} [Msgctrlbuf] PbGetMsgResp Msgctrlbuf
         */

        /**
         * Constructs a new PbGetMsgResp.
         * @memberof Msg
         * @classdesc Represents a PbGetMsgResp.
         * @implements IPbGetMsgResp
         * @constructor
         * @param {Msg.IPbGetMsgResp=} [properties] Properties to set
         */
        function PbGetMsgResp(properties) {
            this.UinPairMsgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbGetMsgResp Result.
         * @member {number} Result
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.Result = 0;

        /**
         * PbGetMsgResp ErrorMsg.
         * @member {string} ErrorMsg
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.ErrorMsg = "";

        /**
         * PbGetMsgResp SyncCookie.
         * @member {Uint8Array} SyncCookie
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.SyncCookie = $util.newBuffer([]);

        /**
         * PbGetMsgResp Flag.
         * @member {Msg.SyncFlag} Flag
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.Flag = 0;

        /**
         * PbGetMsgResp UinPairMsgs.
         * @member {Array.<Msg.MsgField.IUinPairMsg>} UinPairMsgs
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.UinPairMsgs = $util.emptyArray;

        /**
         * PbGetMsgResp Binduin.
         * @member {number|Long} Binduin
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.Binduin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PbGetMsgResp Msgrsptype.
         * @member {number} Msgrsptype
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.Msgrsptype = 0;

        /**
         * PbGetMsgResp Pubaccountcookie.
         * @member {Uint8Array} Pubaccountcookie
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.Pubaccountcookie = $util.newBuffer([]);

        /**
         * PbGetMsgResp Ispartialsync.
         * @member {boolean} Ispartialsync
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.Ispartialsync = false;

        /**
         * PbGetMsgResp Msgctrlbuf.
         * @member {Uint8Array} Msgctrlbuf
         * @memberof Msg.PbGetMsgResp
         * @instance
         */
        PbGetMsgResp.prototype.Msgctrlbuf = $util.newBuffer([]);

        /**
         * Creates a new PbGetMsgResp instance using the specified properties.
         * @function create
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {Msg.IPbGetMsgResp=} [properties] Properties to set
         * @returns {Msg.PbGetMsgResp} PbGetMsgResp instance
         */
        PbGetMsgResp.create = function create(properties) {
            return new PbGetMsgResp(properties);
        };

        /**
         * Encodes the specified PbGetMsgResp message. Does not implicitly {@link Msg.PbGetMsgResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {Msg.IPbGetMsgResp} message PbGetMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbGetMsgResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && Object.hasOwnProperty.call(message, "Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            if (message.ErrorMsg != null && Object.hasOwnProperty.call(message, "ErrorMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ErrorMsg);
            if (message.SyncCookie != null && Object.hasOwnProperty.call(message, "SyncCookie"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.SyncCookie);
            if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Flag);
            if (message.UinPairMsgs != null && message.UinPairMsgs.length)
                for (var i = 0; i < message.UinPairMsgs.length; ++i)
                    $root.Msg.MsgField.UinPairMsg.encode(message.UinPairMsgs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.Binduin != null && Object.hasOwnProperty.call(message, "Binduin"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.Binduin);
            if (message.Msgrsptype != null && Object.hasOwnProperty.call(message, "Msgrsptype"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Msgrsptype);
            if (message.Pubaccountcookie != null && Object.hasOwnProperty.call(message, "Pubaccountcookie"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.Pubaccountcookie);
            if (message.Ispartialsync != null && Object.hasOwnProperty.call(message, "Ispartialsync"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.Ispartialsync);
            if (message.Msgctrlbuf != null && Object.hasOwnProperty.call(message, "Msgctrlbuf"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.Msgctrlbuf);
            return writer;
        };

        /**
         * Encodes the specified PbGetMsgResp message, length delimited. Does not implicitly {@link Msg.PbGetMsgResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {Msg.IPbGetMsgResp} message PbGetMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbGetMsgResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbGetMsgResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbGetMsgResp} PbGetMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbGetMsgResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbGetMsgResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                case 2:
                    message.ErrorMsg = reader.string();
                    break;
                case 3:
                    message.SyncCookie = reader.bytes();
                    break;
                case 4:
                    message.Flag = reader.int32();
                    break;
                case 5:
                    if (!(message.UinPairMsgs && message.UinPairMsgs.length))
                        message.UinPairMsgs = [];
                    message.UinPairMsgs.push($root.Msg.MsgField.UinPairMsg.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.Binduin = reader.int64();
                    break;
                case 7:
                    message.Msgrsptype = reader.int32();
                    break;
                case 8:
                    message.Pubaccountcookie = reader.bytes();
                    break;
                case 9:
                    message.Ispartialsync = reader.bool();
                    break;
                case 10:
                    message.Msgctrlbuf = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbGetMsgResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbGetMsgResp} PbGetMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbGetMsgResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbGetMsgResp message.
         * @function verify
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbGetMsgResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Result != null && message.hasOwnProperty("Result"))
                if (!$util.isInteger(message.Result))
                    return "Result: integer expected";
            if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg"))
                if (!$util.isString(message.ErrorMsg))
                    return "ErrorMsg: string expected";
            if (message.SyncCookie != null && message.hasOwnProperty("SyncCookie"))
                if (!(message.SyncCookie && typeof message.SyncCookie.length === "number" || $util.isString(message.SyncCookie)))
                    return "SyncCookie: buffer expected";
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                switch (message.Flag) {
                default:
                    return "Flag: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.UinPairMsgs != null && message.hasOwnProperty("UinPairMsgs")) {
                if (!Array.isArray(message.UinPairMsgs))
                    return "UinPairMsgs: array expected";
                for (var i = 0; i < message.UinPairMsgs.length; ++i) {
                    var error = $root.Msg.MsgField.UinPairMsg.verify(message.UinPairMsgs[i]);
                    if (error)
                        return "UinPairMsgs." + error;
                }
            }
            if (message.Binduin != null && message.hasOwnProperty("Binduin"))
                if (!$util.isInteger(message.Binduin) && !(message.Binduin && $util.isInteger(message.Binduin.low) && $util.isInteger(message.Binduin.high)))
                    return "Binduin: integer|Long expected";
            if (message.Msgrsptype != null && message.hasOwnProperty("Msgrsptype"))
                if (!$util.isInteger(message.Msgrsptype))
                    return "Msgrsptype: integer expected";
            if (message.Pubaccountcookie != null && message.hasOwnProperty("Pubaccountcookie"))
                if (!(message.Pubaccountcookie && typeof message.Pubaccountcookie.length === "number" || $util.isString(message.Pubaccountcookie)))
                    return "Pubaccountcookie: buffer expected";
            if (message.Ispartialsync != null && message.hasOwnProperty("Ispartialsync"))
                if (typeof message.Ispartialsync !== "boolean")
                    return "Ispartialsync: boolean expected";
            if (message.Msgctrlbuf != null && message.hasOwnProperty("Msgctrlbuf"))
                if (!(message.Msgctrlbuf && typeof message.Msgctrlbuf.length === "number" || $util.isString(message.Msgctrlbuf)))
                    return "Msgctrlbuf: buffer expected";
            return null;
        };

        /**
         * Creates a PbGetMsgResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbGetMsgResp} PbGetMsgResp
         */
        PbGetMsgResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbGetMsgResp)
                return object;
            var message = new $root.Msg.PbGetMsgResp();
            if (object.Result != null)
                message.Result = object.Result | 0;
            if (object.ErrorMsg != null)
                message.ErrorMsg = String(object.ErrorMsg);
            if (object.SyncCookie != null)
                if (typeof object.SyncCookie === "string")
                    $util.base64.decode(object.SyncCookie, message.SyncCookie = $util.newBuffer($util.base64.length(object.SyncCookie)), 0);
                else if (object.SyncCookie.length)
                    message.SyncCookie = object.SyncCookie;
            switch (object.Flag) {
            case "Start":
            case 0:
                message.Flag = 0;
                break;
            case "Continue":
            case 1:
                message.Flag = 1;
                break;
            case "Stop":
            case 2:
                message.Flag = 2;
                break;
            }
            if (object.UinPairMsgs) {
                if (!Array.isArray(object.UinPairMsgs))
                    throw TypeError(".Msg.PbGetMsgResp.UinPairMsgs: array expected");
                message.UinPairMsgs = [];
                for (var i = 0; i < object.UinPairMsgs.length; ++i) {
                    if (typeof object.UinPairMsgs[i] !== "object")
                        throw TypeError(".Msg.PbGetMsgResp.UinPairMsgs: object expected");
                    message.UinPairMsgs[i] = $root.Msg.MsgField.UinPairMsg.fromObject(object.UinPairMsgs[i]);
                }
            }
            if (object.Binduin != null)
                if ($util.Long)
                    (message.Binduin = $util.Long.fromValue(object.Binduin)).unsigned = false;
                else if (typeof object.Binduin === "string")
                    message.Binduin = parseInt(object.Binduin, 10);
                else if (typeof object.Binduin === "number")
                    message.Binduin = object.Binduin;
                else if (typeof object.Binduin === "object")
                    message.Binduin = new $util.LongBits(object.Binduin.low >>> 0, object.Binduin.high >>> 0).toNumber();
            if (object.Msgrsptype != null)
                message.Msgrsptype = object.Msgrsptype | 0;
            if (object.Pubaccountcookie != null)
                if (typeof object.Pubaccountcookie === "string")
                    $util.base64.decode(object.Pubaccountcookie, message.Pubaccountcookie = $util.newBuffer($util.base64.length(object.Pubaccountcookie)), 0);
                else if (object.Pubaccountcookie.length)
                    message.Pubaccountcookie = object.Pubaccountcookie;
            if (object.Ispartialsync != null)
                message.Ispartialsync = Boolean(object.Ispartialsync);
            if (object.Msgctrlbuf != null)
                if (typeof object.Msgctrlbuf === "string")
                    $util.base64.decode(object.Msgctrlbuf, message.Msgctrlbuf = $util.newBuffer($util.base64.length(object.Msgctrlbuf)), 0);
                else if (object.Msgctrlbuf.length)
                    message.Msgctrlbuf = object.Msgctrlbuf;
            return message;
        };

        /**
         * Creates a plain object from a PbGetMsgResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbGetMsgResp
         * @static
         * @param {Msg.PbGetMsgResp} message PbGetMsgResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbGetMsgResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.UinPairMsgs = [];
            if (options.defaults) {
                object.Result = 0;
                object.ErrorMsg = "";
                if (options.bytes === String)
                    object.SyncCookie = "";
                else {
                    object.SyncCookie = [];
                    if (options.bytes !== Array)
                        object.SyncCookie = $util.newBuffer(object.SyncCookie);
                }
                object.Flag = options.enums === String ? "Start" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Binduin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Binduin = options.longs === String ? "0" : 0;
                object.Msgrsptype = 0;
                if (options.bytes === String)
                    object.Pubaccountcookie = "";
                else {
                    object.Pubaccountcookie = [];
                    if (options.bytes !== Array)
                        object.Pubaccountcookie = $util.newBuffer(object.Pubaccountcookie);
                }
                object.Ispartialsync = false;
                if (options.bytes === String)
                    object.Msgctrlbuf = "";
                else {
                    object.Msgctrlbuf = [];
                    if (options.bytes !== Array)
                        object.Msgctrlbuf = $util.newBuffer(object.Msgctrlbuf);
                }
            }
            if (message.Result != null && message.hasOwnProperty("Result"))
                object.Result = message.Result;
            if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg"))
                object.ErrorMsg = message.ErrorMsg;
            if (message.SyncCookie != null && message.hasOwnProperty("SyncCookie"))
                object.SyncCookie = options.bytes === String ? $util.base64.encode(message.SyncCookie, 0, message.SyncCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.SyncCookie) : message.SyncCookie;
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                object.Flag = options.enums === String ? $root.Msg.SyncFlag[message.Flag] : message.Flag;
            if (message.UinPairMsgs && message.UinPairMsgs.length) {
                object.UinPairMsgs = [];
                for (var j = 0; j < message.UinPairMsgs.length; ++j)
                    object.UinPairMsgs[j] = $root.Msg.MsgField.UinPairMsg.toObject(message.UinPairMsgs[j], options);
            }
            if (message.Binduin != null && message.hasOwnProperty("Binduin"))
                if (typeof message.Binduin === "number")
                    object.Binduin = options.longs === String ? String(message.Binduin) : message.Binduin;
                else
                    object.Binduin = options.longs === String ? $util.Long.prototype.toString.call(message.Binduin) : options.longs === Number ? new $util.LongBits(message.Binduin.low >>> 0, message.Binduin.high >>> 0).toNumber() : message.Binduin;
            if (message.Msgrsptype != null && message.hasOwnProperty("Msgrsptype"))
                object.Msgrsptype = message.Msgrsptype;
            if (message.Pubaccountcookie != null && message.hasOwnProperty("Pubaccountcookie"))
                object.Pubaccountcookie = options.bytes === String ? $util.base64.encode(message.Pubaccountcookie, 0, message.Pubaccountcookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.Pubaccountcookie) : message.Pubaccountcookie;
            if (message.Ispartialsync != null && message.hasOwnProperty("Ispartialsync"))
                object.Ispartialsync = message.Ispartialsync;
            if (message.Msgctrlbuf != null && message.hasOwnProperty("Msgctrlbuf"))
                object.Msgctrlbuf = options.bytes === String ? $util.base64.encode(message.Msgctrlbuf, 0, message.Msgctrlbuf.length) : options.bytes === Array ? Array.prototype.slice.call(message.Msgctrlbuf) : message.Msgctrlbuf;
            return object;
        };

        /**
         * Converts this PbGetMsgResp to JSON.
         * @function toJSON
         * @memberof Msg.PbGetMsgResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbGetMsgResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbGetMsgResp;
    })();

    Msg.PbGetMsgReq = (function() {

        /**
         * Properties of a PbGetMsgReq.
         * @memberof Msg
         * @interface IPbGetMsgReq
         * @property {Msg.SyncFlag|null} [Flag] PbGetMsgReq Flag
         * @property {Uint8Array|null} [SyncCookie] PbGetMsgReq SyncCookie
         * @property {number|null} [RambleFlag] PbGetMsgReq RambleFlag
         * @property {number|null} [LatestRambleNumber] PbGetMsgReq LatestRambleNumber
         * @property {number|null} [OtherRambleNumber] PbGetMsgReq OtherRambleNumber
         * @property {number|null} [OnlineSyncFlag] PbGetMsgReq OnlineSyncFlag
         * @property {number|null} [ContextFlag] PbGetMsgReq ContextFlag
         * @property {number|null} [WhisperSessionId] PbGetMsgReq WhisperSessionId
         * @property {number|null} [MsgReqType] PbGetMsgReq MsgReqType
         * @property {Uint8Array|null} [PubaccountCookie] PbGetMsgReq PubaccountCookie
         * @property {Uint8Array|null} [MsgCtrlBuf] PbGetMsgReq MsgCtrlBuf
         * @property {Uint8Array|null} [ServerBuf] PbGetMsgReq ServerBuf
         */

        /**
         * Constructs a new PbGetMsgReq.
         * @memberof Msg
         * @classdesc Represents a PbGetMsgReq.
         * @implements IPbGetMsgReq
         * @constructor
         * @param {Msg.IPbGetMsgReq=} [properties] Properties to set
         */
        function PbGetMsgReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbGetMsgReq Flag.
         * @member {Msg.SyncFlag} Flag
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.Flag = 0;

        /**
         * PbGetMsgReq SyncCookie.
         * @member {Uint8Array} SyncCookie
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.SyncCookie = $util.newBuffer([]);

        /**
         * PbGetMsgReq RambleFlag.
         * @member {number} RambleFlag
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.RambleFlag = 0;

        /**
         * PbGetMsgReq LatestRambleNumber.
         * @member {number} LatestRambleNumber
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.LatestRambleNumber = 0;

        /**
         * PbGetMsgReq OtherRambleNumber.
         * @member {number} OtherRambleNumber
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.OtherRambleNumber = 0;

        /**
         * PbGetMsgReq OnlineSyncFlag.
         * @member {number} OnlineSyncFlag
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.OnlineSyncFlag = 0;

        /**
         * PbGetMsgReq ContextFlag.
         * @member {number} ContextFlag
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.ContextFlag = 0;

        /**
         * PbGetMsgReq WhisperSessionId.
         * @member {number} WhisperSessionId
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.WhisperSessionId = 0;

        /**
         * PbGetMsgReq MsgReqType.
         * @member {number} MsgReqType
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.MsgReqType = 0;

        /**
         * PbGetMsgReq PubaccountCookie.
         * @member {Uint8Array} PubaccountCookie
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.PubaccountCookie = $util.newBuffer([]);

        /**
         * PbGetMsgReq MsgCtrlBuf.
         * @member {Uint8Array} MsgCtrlBuf
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.MsgCtrlBuf = $util.newBuffer([]);

        /**
         * PbGetMsgReq ServerBuf.
         * @member {Uint8Array} ServerBuf
         * @memberof Msg.PbGetMsgReq
         * @instance
         */
        PbGetMsgReq.prototype.ServerBuf = $util.newBuffer([]);

        /**
         * Creates a new PbGetMsgReq instance using the specified properties.
         * @function create
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {Msg.IPbGetMsgReq=} [properties] Properties to set
         * @returns {Msg.PbGetMsgReq} PbGetMsgReq instance
         */
        PbGetMsgReq.create = function create(properties) {
            return new PbGetMsgReq(properties);
        };

        /**
         * Encodes the specified PbGetMsgReq message. Does not implicitly {@link Msg.PbGetMsgReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {Msg.IPbGetMsgReq} message PbGetMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbGetMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Flag != null && Object.hasOwnProperty.call(message, "Flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Flag);
            if (message.SyncCookie != null && Object.hasOwnProperty.call(message, "SyncCookie"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.SyncCookie);
            if (message.RambleFlag != null && Object.hasOwnProperty.call(message, "RambleFlag"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.RambleFlag);
            if (message.LatestRambleNumber != null && Object.hasOwnProperty.call(message, "LatestRambleNumber"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.LatestRambleNumber);
            if (message.OtherRambleNumber != null && Object.hasOwnProperty.call(message, "OtherRambleNumber"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.OtherRambleNumber);
            if (message.OnlineSyncFlag != null && Object.hasOwnProperty.call(message, "OnlineSyncFlag"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.OnlineSyncFlag);
            if (message.ContextFlag != null && Object.hasOwnProperty.call(message, "ContextFlag"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.ContextFlag);
            if (message.WhisperSessionId != null && Object.hasOwnProperty.call(message, "WhisperSessionId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.WhisperSessionId);
            if (message.MsgReqType != null && Object.hasOwnProperty.call(message, "MsgReqType"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.MsgReqType);
            if (message.PubaccountCookie != null && Object.hasOwnProperty.call(message, "PubaccountCookie"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.PubaccountCookie);
            if (message.MsgCtrlBuf != null && Object.hasOwnProperty.call(message, "MsgCtrlBuf"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.MsgCtrlBuf);
            if (message.ServerBuf != null && Object.hasOwnProperty.call(message, "ServerBuf"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.ServerBuf);
            return writer;
        };

        /**
         * Encodes the specified PbGetMsgReq message, length delimited. Does not implicitly {@link Msg.PbGetMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {Msg.IPbGetMsgReq} message PbGetMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbGetMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbGetMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PbGetMsgReq} PbGetMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbGetMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PbGetMsgReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Flag = reader.int32();
                    break;
                case 2:
                    message.SyncCookie = reader.bytes();
                    break;
                case 3:
                    message.RambleFlag = reader.int32();
                    break;
                case 4:
                    message.LatestRambleNumber = reader.int32();
                    break;
                case 5:
                    message.OtherRambleNumber = reader.int32();
                    break;
                case 6:
                    message.OnlineSyncFlag = reader.int32();
                    break;
                case 7:
                    message.ContextFlag = reader.int32();
                    break;
                case 8:
                    message.WhisperSessionId = reader.int32();
                    break;
                case 9:
                    message.MsgReqType = reader.int32();
                    break;
                case 10:
                    message.PubaccountCookie = reader.bytes();
                    break;
                case 11:
                    message.MsgCtrlBuf = reader.bytes();
                    break;
                case 12:
                    message.ServerBuf = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbGetMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PbGetMsgReq} PbGetMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbGetMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbGetMsgReq message.
         * @function verify
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbGetMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                switch (message.Flag) {
                default:
                    return "Flag: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.SyncCookie != null && message.hasOwnProperty("SyncCookie"))
                if (!(message.SyncCookie && typeof message.SyncCookie.length === "number" || $util.isString(message.SyncCookie)))
                    return "SyncCookie: buffer expected";
            if (message.RambleFlag != null && message.hasOwnProperty("RambleFlag"))
                if (!$util.isInteger(message.RambleFlag))
                    return "RambleFlag: integer expected";
            if (message.LatestRambleNumber != null && message.hasOwnProperty("LatestRambleNumber"))
                if (!$util.isInteger(message.LatestRambleNumber))
                    return "LatestRambleNumber: integer expected";
            if (message.OtherRambleNumber != null && message.hasOwnProperty("OtherRambleNumber"))
                if (!$util.isInteger(message.OtherRambleNumber))
                    return "OtherRambleNumber: integer expected";
            if (message.OnlineSyncFlag != null && message.hasOwnProperty("OnlineSyncFlag"))
                if (!$util.isInteger(message.OnlineSyncFlag))
                    return "OnlineSyncFlag: integer expected";
            if (message.ContextFlag != null && message.hasOwnProperty("ContextFlag"))
                if (!$util.isInteger(message.ContextFlag))
                    return "ContextFlag: integer expected";
            if (message.WhisperSessionId != null && message.hasOwnProperty("WhisperSessionId"))
                if (!$util.isInteger(message.WhisperSessionId))
                    return "WhisperSessionId: integer expected";
            if (message.MsgReqType != null && message.hasOwnProperty("MsgReqType"))
                if (!$util.isInteger(message.MsgReqType))
                    return "MsgReqType: integer expected";
            if (message.PubaccountCookie != null && message.hasOwnProperty("PubaccountCookie"))
                if (!(message.PubaccountCookie && typeof message.PubaccountCookie.length === "number" || $util.isString(message.PubaccountCookie)))
                    return "PubaccountCookie: buffer expected";
            if (message.MsgCtrlBuf != null && message.hasOwnProperty("MsgCtrlBuf"))
                if (!(message.MsgCtrlBuf && typeof message.MsgCtrlBuf.length === "number" || $util.isString(message.MsgCtrlBuf)))
                    return "MsgCtrlBuf: buffer expected";
            if (message.ServerBuf != null && message.hasOwnProperty("ServerBuf"))
                if (!(message.ServerBuf && typeof message.ServerBuf.length === "number" || $util.isString(message.ServerBuf)))
                    return "ServerBuf: buffer expected";
            return null;
        };

        /**
         * Creates a PbGetMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PbGetMsgReq} PbGetMsgReq
         */
        PbGetMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PbGetMsgReq)
                return object;
            var message = new $root.Msg.PbGetMsgReq();
            switch (object.Flag) {
            case "Start":
            case 0:
                message.Flag = 0;
                break;
            case "Continue":
            case 1:
                message.Flag = 1;
                break;
            case "Stop":
            case 2:
                message.Flag = 2;
                break;
            }
            if (object.SyncCookie != null)
                if (typeof object.SyncCookie === "string")
                    $util.base64.decode(object.SyncCookie, message.SyncCookie = $util.newBuffer($util.base64.length(object.SyncCookie)), 0);
                else if (object.SyncCookie.length)
                    message.SyncCookie = object.SyncCookie;
            if (object.RambleFlag != null)
                message.RambleFlag = object.RambleFlag | 0;
            if (object.LatestRambleNumber != null)
                message.LatestRambleNumber = object.LatestRambleNumber | 0;
            if (object.OtherRambleNumber != null)
                message.OtherRambleNumber = object.OtherRambleNumber | 0;
            if (object.OnlineSyncFlag != null)
                message.OnlineSyncFlag = object.OnlineSyncFlag | 0;
            if (object.ContextFlag != null)
                message.ContextFlag = object.ContextFlag | 0;
            if (object.WhisperSessionId != null)
                message.WhisperSessionId = object.WhisperSessionId | 0;
            if (object.MsgReqType != null)
                message.MsgReqType = object.MsgReqType | 0;
            if (object.PubaccountCookie != null)
                if (typeof object.PubaccountCookie === "string")
                    $util.base64.decode(object.PubaccountCookie, message.PubaccountCookie = $util.newBuffer($util.base64.length(object.PubaccountCookie)), 0);
                else if (object.PubaccountCookie.length)
                    message.PubaccountCookie = object.PubaccountCookie;
            if (object.MsgCtrlBuf != null)
                if (typeof object.MsgCtrlBuf === "string")
                    $util.base64.decode(object.MsgCtrlBuf, message.MsgCtrlBuf = $util.newBuffer($util.base64.length(object.MsgCtrlBuf)), 0);
                else if (object.MsgCtrlBuf.length)
                    message.MsgCtrlBuf = object.MsgCtrlBuf;
            if (object.ServerBuf != null)
                if (typeof object.ServerBuf === "string")
                    $util.base64.decode(object.ServerBuf, message.ServerBuf = $util.newBuffer($util.base64.length(object.ServerBuf)), 0);
                else if (object.ServerBuf.length)
                    message.ServerBuf = object.ServerBuf;
            return message;
        };

        /**
         * Creates a plain object from a PbGetMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PbGetMsgReq
         * @static
         * @param {Msg.PbGetMsgReq} message PbGetMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbGetMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Flag = options.enums === String ? "Start" : 0;
                if (options.bytes === String)
                    object.SyncCookie = "";
                else {
                    object.SyncCookie = [];
                    if (options.bytes !== Array)
                        object.SyncCookie = $util.newBuffer(object.SyncCookie);
                }
                object.RambleFlag = 0;
                object.LatestRambleNumber = 0;
                object.OtherRambleNumber = 0;
                object.OnlineSyncFlag = 0;
                object.ContextFlag = 0;
                object.WhisperSessionId = 0;
                object.MsgReqType = 0;
                if (options.bytes === String)
                    object.PubaccountCookie = "";
                else {
                    object.PubaccountCookie = [];
                    if (options.bytes !== Array)
                        object.PubaccountCookie = $util.newBuffer(object.PubaccountCookie);
                }
                if (options.bytes === String)
                    object.MsgCtrlBuf = "";
                else {
                    object.MsgCtrlBuf = [];
                    if (options.bytes !== Array)
                        object.MsgCtrlBuf = $util.newBuffer(object.MsgCtrlBuf);
                }
                if (options.bytes === String)
                    object.ServerBuf = "";
                else {
                    object.ServerBuf = [];
                    if (options.bytes !== Array)
                        object.ServerBuf = $util.newBuffer(object.ServerBuf);
                }
            }
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                object.Flag = options.enums === String ? $root.Msg.SyncFlag[message.Flag] : message.Flag;
            if (message.SyncCookie != null && message.hasOwnProperty("SyncCookie"))
                object.SyncCookie = options.bytes === String ? $util.base64.encode(message.SyncCookie, 0, message.SyncCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.SyncCookie) : message.SyncCookie;
            if (message.RambleFlag != null && message.hasOwnProperty("RambleFlag"))
                object.RambleFlag = message.RambleFlag;
            if (message.LatestRambleNumber != null && message.hasOwnProperty("LatestRambleNumber"))
                object.LatestRambleNumber = message.LatestRambleNumber;
            if (message.OtherRambleNumber != null && message.hasOwnProperty("OtherRambleNumber"))
                object.OtherRambleNumber = message.OtherRambleNumber;
            if (message.OnlineSyncFlag != null && message.hasOwnProperty("OnlineSyncFlag"))
                object.OnlineSyncFlag = message.OnlineSyncFlag;
            if (message.ContextFlag != null && message.hasOwnProperty("ContextFlag"))
                object.ContextFlag = message.ContextFlag;
            if (message.WhisperSessionId != null && message.hasOwnProperty("WhisperSessionId"))
                object.WhisperSessionId = message.WhisperSessionId;
            if (message.MsgReqType != null && message.hasOwnProperty("MsgReqType"))
                object.MsgReqType = message.MsgReqType;
            if (message.PubaccountCookie != null && message.hasOwnProperty("PubaccountCookie"))
                object.PubaccountCookie = options.bytes === String ? $util.base64.encode(message.PubaccountCookie, 0, message.PubaccountCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.PubaccountCookie) : message.PubaccountCookie;
            if (message.MsgCtrlBuf != null && message.hasOwnProperty("MsgCtrlBuf"))
                object.MsgCtrlBuf = options.bytes === String ? $util.base64.encode(message.MsgCtrlBuf, 0, message.MsgCtrlBuf.length) : options.bytes === Array ? Array.prototype.slice.call(message.MsgCtrlBuf) : message.MsgCtrlBuf;
            if (message.ServerBuf != null && message.hasOwnProperty("ServerBuf"))
                object.ServerBuf = options.bytes === String ? $util.base64.encode(message.ServerBuf, 0, message.ServerBuf.length) : options.bytes === Array ? Array.prototype.slice.call(message.ServerBuf) : message.ServerBuf;
            return object;
        };

        /**
         * Converts this PbGetMsgReq to JSON.
         * @function toJSON
         * @memberof Msg.PbGetMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbGetMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbGetMsgReq;
    })();

    return Msg;
})();

module.exports = $root;
